<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Cocos3D: Cocos3D API reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-cocos3d.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">
	   <a href="http://cocos3d.org"><img src="http://cocos3d.org/images/cocos3d-Banner-55h.png" /></a>
	   <span id="projectnumber">v2.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_c_c3_mesh_particle_emitter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CC3MeshParticleEmitter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#import &lt;CC3MeshParticles.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3MeshParticleEmitter:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_mesh_particle_emitter__inherit__graph.png" border="0" usemap="#_c_c3_mesh_particle_emitter_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_mesh_particle_emitter_inherit__map" id="_c_c3_mesh_particle_emitter_inherit__map">
<area shape="rect" id="node18" href="interface_c_c3_multi_template_mesh_particle_emitter.html" title="CC3MultiTemplateMeshParticleEmitter is a type of CC3MeshParticleEmitter that supports multiple partic..." alt="" coords="1953,175,2162,217"/><area shape="rect" id="node2" href="interface_c_c3_common_vertex_array_particle_emitter.html" title="A CC3CommonVertexArrayParticleEmitter maintains the vertices of all particles in common vertex arrays..." alt="" coords="1470,175,1687,217"/><area shape="rect" id="node3" href="interface_c_c3_particle_emitter.html" title="A CC3MeshNode that emits 3D particles. " alt="" coords="1285,183,1421,209"/><area shape="rect" id="node4" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. " alt="" coords="1123,183,1237,209"/><area shape="rect" id="node5" href="interface_c_c3_local_content_node.html" title="CC3LocalContentNode is an abstract class that forms the basis for nodes that have local content to dr..." alt="" coords="915,183,1074,209"/><area shape="rect" id="node6" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D scene, including visible mesh..." alt="" coords="787,183,867,209"/><area shape="rect" id="node7" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="583,77,697,104"/><area shape="rect" id="node9" href="protocol_c_c3_cacheable-p.html" title="Defines the behaviour required for an object that can be held in a cache. " alt="" coords="333,56,461,83"/><area shape="rect" id="node10" href="protocol_c_c3_object-p.html" title="Extension to support Cocos3D functionality. " alt="" coords="150,107,253,133"/><area shape="rect" id="node17" href="protocol_c_c3_node_listener_protocol-p.html" title="This protocol defines the behaviour requirements for objects that wish to be notified about the basic..." alt="" coords="301,157,493,184"/><area shape="rect" id="node13" href="protocol_c_c_r_g_b_a_protocol-p.html" title="\&lt;CCRGBAProtocol\&gt;" alt="" coords="568,212,712,239"/><area shape="rect" id="node16" href="protocol_c_c3_node_transform_listener_protocol-p.html" title="This protocol defines the behaviour requirements for objects that wish to be notified whenever the tr..." alt="" coords="542,146,738,187"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:adc2c9d410fa9a9055f4ff3bfc8fdaf64"><td class="memItemLeft" align="right" valign="top">(id&lt; <a class="el" href="protocol_c_c3_mesh_particle_protocol-p.html">CC3MeshParticleProtocol</a> &gt;)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh_particle_emitter.html#adc2c9d410fa9a9055f4ff3bfc8fdaf64">acquireParticle</a></td></tr>
<tr class="separator:adc2c9d410fa9a9055f4ff3bfc8fdaf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4d2f946b6fd760911269a0ef3b311c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh_particle_emitter.html#acc4d2f946b6fd760911269a0ef3b311c">assignTemplateMeshToParticle:</a></td></tr>
<tr class="separator:acc4d2f946b6fd760911269a0ef3b311c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab2f3572a4f6ef7eb0ee6771979a709"><td class="memItemLeft" align="right" valign="top">(id&lt; <a class="el" href="protocol_c_c3_mesh_particle_protocol-p.html">CC3MeshParticleProtocol</a> &gt;)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh_particle_emitter.html#a8ab2f3572a4f6ef7eb0ee6771979a709">emitParticle</a></td></tr>
<tr class="separator:a8ab2f3572a4f6ef7eb0ee6771979a709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31f6713e9f4dd3a7e11e67093063f7e"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh_particle_emitter.html#ad31f6713e9f4dd3a7e11e67093063f7e">emitParticle:</a></td></tr>
<tr class="separator:ad31f6713e9f4dd3a7e11e67093063f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bd19f5aedace69e1c9ef7c1cf207ff"><td class="memItemLeft" align="right" valign="top">(id&lt; <a class="el" href="protocol_c_c3_mesh_particle_protocol-p.html">CC3MeshParticleProtocol</a> &gt;)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh_particle_emitter.html#a51bd19f5aedace69e1c9ef7c1cf207ff">makeParticle</a></td></tr>
<tr class="separator:a51bd19f5aedace69e1c9ef7c1cf207ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcdc48628e82a68fb67c1b7aa14ab62"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh_particle_emitter.html#a7dcdc48628e82a68fb67c1b7aa14ab62">markParticleTransformDirty</a></td></tr>
<tr class="separator:a7dcdc48628e82a68fb67c1b7aa14ab62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4020617ae79359d00e188e87f6cf443a"><td class="memItemLeft" align="right" valign="top">(id&lt; <a class="el" href="protocol_c_c3_mesh_particle_protocol-p.html">CC3MeshParticleProtocol</a> &gt;)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh_particle_emitter.html#a4020617ae79359d00e188e87f6cf443a">meshParticleAt:</a></td></tr>
<tr class="separator:a4020617ae79359d00e188e87f6cf443a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed93555c0059b6a7a87e3fc135e1108"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh_particle_emitter.html#a0ed93555c0059b6a7a87e3fc135e1108">setParticleTemplate:</a></td></tr>
<tr class="separator:a0ed93555c0059b6a7a87e3fc135e1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a70c58078177590c4e0326791eac2f679"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_particle_emitter.html#a70c58078177590c4e0326791eac2f679">isParticleTransformDirty</a></td></tr>
<tr class="separator:a70c58078177590c4e0326791eac2f679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a014eee90b7d24ce9afc28642937b49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_mesh.html">CC3Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_particle_emitter.html#a8a014eee90b7d24ce9afc28642937b49">particleTemplateMesh</a></td></tr>
<tr class="separator:a8a014eee90b7d24ce9afc28642937b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d694453ca8f5b9bb40ff748b413edca"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_particle_emitter.html#a5d694453ca8f5b9bb40ff748b413edca">shouldTransformUnseenParticles</a></td></tr>
<tr class="separator:a5d694453ca8f5b9bb40ff748b413edca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_interface_c_c3_local_content_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_interface_c_c3_local_content_node')"><img src="closed.png" alt="-"/>&#160;Class Methods inherited from <a class="el" href="interface_c_c3_local_content_node.html">CC3LocalContentNode</a></td></tr>
<tr class="memitem:ab7a59b652a27e55b2c6374886841c50a inherit pub_static_methods_interface_c_c3_local_content_node"><td class="memItemLeft" align="right" valign="top">(ccColor4F)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_local_content_node.html#ab7a59b652a27e55b2c6374886841c50a">localContentWireframeBoxColor</a></td></tr>
<tr class="separator:ab7a59b652a27e55b2c6374886841c50a inherit pub_static_methods_interface_c_c3_local_content_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af031429a9b5f69a229714ee263b36c0a inherit pub_static_methods_interface_c_c3_local_content_node"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_local_content_node.html#af031429a9b5f69a229714ee263b36c0a">setLocalContentWireframeBoxColor:</a></td></tr>
<tr class="separator:af031429a9b5f69a229714ee263b36c0a inherit pub_static_methods_interface_c_c3_local_content_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_mesh_particle_emitter.html" title="CC3MeshParticleEmitter emits particles that conform to the CC3MeshParticleProtocol protocol...">CC3MeshParticleEmitter</a> emits particles that conform to the <a class="el" href="protocol_c_c3_mesh_particle_protocol-p.html" title="CC3MeshParticleProtocol defines the requirements for mesh particles that are emitted and managed by t...">CC3MeshParticleProtocol</a> protocol. </p>
<p>Each mesh particle is comprised of an individual mesh. Like any mesh, a mesh particle represents a true 3D object that can have length, width and depth, can be moved, rotated and scaled, and can be colored and covered with a texture.</p>
<p>Each mesh particle uses a <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> as a template. But, because it is a particle, this basic mesh template is copied into the mesh arrays of the <a class="el" href="interface_c_c3_mesh_particle_emitter.html" title="CC3MeshParticleEmitter emits particles that conform to the CC3MeshParticleProtocol protocol...">CC3MeshParticleEmitter</a>, where it is merged with the meshes of the other particles managed by the emitter, and is submitted to the GL engine in a single draw call.</p>
<p>Like mesh nodes, mesh particles may be transformed (moved, rotated &amp; scaled). However, unlike mesh nodes, the vertices of a mesh particle are transformed by the CPU in application memory, and the transformed vertices are drawn without further individual transformation by the GPU.</p>
<p>Mesh particles are transformed by this emitter through the transformVertices method on the particle. This method is invoked automatically by the emitter when a particle has been changed, and the mesh particle implementation defines what type of transform occurs when this method is invoked.</p>
<p>This creates a trade-off, where, relative to mesh nodes, the GPU rendering performance is dramatically improved for large numbers of mesh particles, but the CPU load is increased when mesh particles are constantly being transformed, particularly for larger meshes.</p>
<p>Relative to mesh nodes, mesh particles work best when there are many small meshes that are transfomed slowly, where the benefit of drawing in a single call outweighs the cost of processing the vertices in the CPU. For larger meshes, it is more effective to use mesh nodes, where the transformations can be carried out by the GPU.</p>
<p>Each mesh particle added to or emitted by this mesh emitter uses a <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> as a template. For particles created by the application outside the emitter, and added to the emitter with the emitParticle: method, the application can directly set the templateMesh property of the mesh particle prior to invoking the emitParticle: method of this emitter. With this technique, each particle can use a different mesh template, and so each paticle can be a different shape. If the templateMesh property of a particle submitted to the emitParticle: method is nil, this emitter will assign the template mesh in the particleTemplateMesh property to the particle.</p>
<p>For particles created within the emitter, and emitted automatically, or via the emitParticle method, each particle will be assigned the template mesh specified in the particleTemplateMesh property of this emitter. In this scenario, each particle will be the same shape. Subclasses, such as <a class="el" href="interface_c_c3_multi_template_mesh_particle_emitter.html" title="CC3MultiTemplateMeshParticleEmitter is a type of CC3MeshParticleEmitter that supports multiple partic...">CC3MultiTemplateMeshParticleEmitter</a>, can extend this functionality to allow particles that are automatically emitted to be assigned a template mesh that is randomly selected from a collection of template meshes.</p>
<p>Because all particles managed by this emitter are drawn with a single GL draw call, all particles added to or emitted by this emitter are covered by the same material and texture.</p>
<p>However, you can assign a different color to each particle by configuring this emitter to use vertex color content by including the kCC3VertexContentColor component when setting the vertexContentTypes property of this emitter.</p>
<p>Similarly, if the vertexContentTypes property of this emitter includes the kCC3VertexContentTextureCoordinates component, then the particles will be covered by a texture. By assigning the texture coordinates of each particle to different sections of the texture assigned to this emitter, each particle can effectively be textured separately.</p>
<p>All memory used by the particles and the underlying vertex mesh is managed by the emitter node, and is deallocated automatically when the emitter is released. </p>
</div><h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="adc2c9d410fa9a9055f4ff3bfc8fdaf64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id&lt;<a class="el" href="protocol_c_c3_mesh_particle_protocol-p.html">CC3MeshParticleProtocol</a>&gt;) acquireParticle </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a particle suitable for emission by this emitter. </p>
<p>The returned particle can subsequently be emitted from this emitter using the emitParticle: method.</p>
<p>The particle emitted may be an existing expired particle that is being reused, or it may be a newly instantiated particle. If an expired particle is available within this emitter, it will be reused. If not, this method invokes the makeParticle method to create a new particle.</p>
<p>The returned particle will be assigned the template mesh defined in the particleTemplateMesh property. If the particle is being reused and originally had a different particle mesh, the template mesh of the reused particle is replaced.</p>
<p>You can also use the makeParticle method directly to ensure that a new particle has been created. </p>

<p>Implements <a class="el" href="interface_c_c3_particle_emitter.html#a26557a264d0031840fa9047c94611e74">CC3ParticleEmitter</a>.</p>

</div>
</div>
<a class="anchor" id="acc4d2f946b6fd760911269a0ef3b311c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) assignTemplateMeshToParticle: </td>
          <td></td>
          <td class="paramtype">(id&lt; <a class="el" href="protocol_c_c3_mesh_particle_protocol-p.html">CC3MeshParticleProtocol</a> &gt;)&#160;</td>
          <td class="paramname"><em>aParticle</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template method that sets the templateMesh property of the specified particle. </p>
<p>This implementation sets the particle's templateMesh property to the mesh in the particleTemplateMesh property of this emitter.</p>
<p>Subclasses may override this implementation to create some other selection and assignment methodology.</p>
<p>This method is invoked automatically when a particle is emitted, or the emitParticle: method is invoked with a particle that does not already have a templateMesh. The application should never need to invoke this method directly. </p>

<p>Implemented in <a class="el" href="interface_c_c3_multi_template_mesh_particle_emitter.html#a9a111f9f3682d196fe6e83781ae7acdb">CC3MultiTemplateMeshParticleEmitter</a>.</p>

</div>
</div>
<a class="anchor" id="a8ab2f3572a4f6ef7eb0ee6771979a709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id&lt;<a class="el" href="protocol_c_c3_mesh_particle_protocol-p.html">CC3MeshParticleProtocol</a>&gt;) emitParticle </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a single particle of the type specified in the particleClass property. </p>
<p>Refer the the documentation of this method in the parent <a class="el" href="interface_c_c3_particle_emitter.html" title="A CC3MeshNode that emits 3D particles. ">CC3ParticleEmitter</a> class for a complete description of the emission process.</p>
<p>The emitted particle will be assigned the template mesh defined in the particleTemplateMesh property. </p>

<p>Implements <a class="el" href="interface_c_c3_particle_emitter.html#affef820405e61e19db8a032d4e997ae9">CC3ParticleEmitter</a>.</p>

</div>
</div>
<a class="anchor" id="ad31f6713e9f4dd3a7e11e67093063f7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) emitParticle: </td>
          <td></td>
          <td class="paramtype">(id&lt; <a class="el" href="protocol_c_c3_mesh_particle_protocol-p.html">CC3MeshParticleProtocol</a> &gt;)&#160;</td>
          <td class="paramname"><em>aParticle</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified particle to the emitter and emits it. </p>
<p>Refer the the documentation of this method in the parent <a class="el" href="interface_c_c3_particle_emitter.html" title="A CC3MeshNode that emits 3D particles. ">CC3ParticleEmitter</a> class for a complete description of the emission process.</p>
<p>If the specified particle does not have a templateMesh, it will be assigned the template mesh defined in the particleTemplateMesh property of this emitter. </p>

</div>
</div>
<a class="anchor" id="a51bd19f5aedace69e1c9ef7c1cf207ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id&lt;<a class="el" href="protocol_c_c3_mesh_particle_protocol-p.html">CC3MeshParticleProtocol</a>&gt;) makeParticle </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new autoreleased instance of a particle of the type specified by the particleClass property. </p>
<p>The returned particle can subsequently be emitted from this emitter using the emitParticle: method.</p>
<p>The returned particle will be assigned the template mesh defined in the particleTemplateMesh property.</p>
<p>Distinct from the acquireParticle method, this method bypasses the reuse of expired particles and always creates a new autoreleased particle instance. </p>

<p>Implements <a class="el" href="interface_c_c3_particle_emitter.html#a58845cf28211d9cb9c30fc4bb4114a3a">CC3ParticleEmitter</a>.</p>

</div>
</div>
<a class="anchor" id="a7dcdc48628e82a68fb67c1b7aa14ab62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) markParticleTransformDirty </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that a particle has been transformed in some way, and that the vertices need to be transformed accordingly prior to the next drawing frame. </p>
<p>This method is invoked automatically whenever any of the transform properties of any particle (location, rotation (including any type of rotation), or scale) are changed. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a4020617ae79359d00e188e87f6cf443a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id&lt;<a class="el" href="protocol_c_c3_mesh_particle_protocol-p.html">CC3MeshParticleProtocol</a>&gt;) meshParticleAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>aParticleIndex</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the particle at the specified index within the particles array, cast as a mesh particle. </p>

</div>
</div>
<a class="anchor" id="a0ed93555c0059b6a7a87e3fc135e1108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setParticleTemplate: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a> *)&#160;</td>
          <td class="paramname"><em>aParticleTemplate</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures this emitter to emit particles as defined by the specified template mesh node. </p>
<p>This is a convenience method that simply sets the particleTemplateMesh and material properties of this emitter (including the texture) from the corresponding properties of the specified mesh node.</p>
<p>When these properties are set, the template mesh is simply retained, but the template material is copied, so that the material of the emitter can be configured independently from that of the template mesh node. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a70c58078177590c4e0326791eac2f679"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isParticleTransformDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether any of the transform properties on any of the particles have been changed, and so the vertices of the particle need to be transformed. </p>
<p>This property is automatically set to YES when one of those properties have been changed on any of the particles and is reset to NO once the particles have been transformed.</p>
<p>Transformation of the particles occurs automatically when the emitter is transformed. </p>

</div>
</div>
<a class="anchor" id="a8a014eee90b7d24ce9afc28642937b49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_mesh.html">CC3Mesh</a>*) particleTemplateMesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mesh used as a template for the mesh of each particle emitted automatically by this emitter. </p>
<p>Each particle created within the emitter, and emitted automatically, or via the emitParticle method, will be assigned the template mesh specified in this property.</p>
<p>When a particle is created by the application outside the emitter, and submitted to the emitter via the emitParticle: method, the application can assign a different template mesh to it via the templateMesh property of the particle, before invoking the emitParticle: method.</p>
<p>However, when using the emitParticle: method, the application does not have to assign a template mesh directly. If the templateMesh property of a particle submitted to the emitParticle: method is nil, this emitter will assign the template mesh in this particleTemplateMesh property to the particle.</p>
<p>Each particle emitted by this emitter uses the vertices of this mesh as a starting point, however, each particle has access to its own copy of its mesh vertices. In this way, different particles can have different locations, rotations, vertex colors and texture coordinates.</p>
<p>If the value of the vertexContentTypes property of this emitter have not yet been set, that property is set to the value of the vertexContentTypes property of the specified particle template mesh. Therefore, by default, the particles of this emitter will contain the same vertex content types as this template mesh.</p>
<p>This emitter can be configured with vertex content types that are different than the template mesh, by setting the value of the vertexContentTypes property of this emitter explicitly. When vertex content is copied from the template mesh to a particle, vertex content types that do not appear in this mesh will be ignored, and particle content for content types not available in the template mesh will be given default values, and can be set during initializaton of each particle. For example, if the particle template mesh does not contain individual vertex color information, you can still define color as vertex content type for this emitter, and set the color of each particle when it is initialized.</p>
<p>This property must be set prior to this emitter emitting any particles. It is possible to change the value of this property during emission. </p>

</div>
</div>
<a class="anchor" id="a5d694453ca8f5b9bb40ff748b413edca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldTransformUnseenParticles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether particles should be transformed when the emitter is not within view of the camera. </p>
<p>As particles move and rotate, their vertices are transformed. This can consume significant processing when the number of particles and the complexity of the particle meshes is large.</p>
<p>Setting this property to NO will stop the particles from being transformed when the bounding volume of the emitter does not intersect the frustum of the camera, improving application performance when the particles are offscreen. Particles will still be updated, but their vertices will not be transformed until the emitter comes within the view of the camera.</p>
<p>Care should be taken when setting this property to NO, because the bounding volume of an emitter is calculated from the current vertices of the particles. When the particles stop being transformed, under the action of this property, the bounding volume will stop being updated. Since the particles are still updated even when not visible, this can cause a jarring visual effect when the emitter comes back into view of the camera and the particles may seem to jump unexpectedly into space that was not part of the emitter bounding volume when it previously stopped being updated. If such an effect occurs and is undesirable, this property can be left set to YES so that particles will continue to be transformed even when outside the view of the camera.</p>
<p>When the bounding volume of the emitter is fixed, as indicated by the shouldUseFixedBoundingVolume property, it is assumed that the bounding volume has already been sized to encompass all possible paths of the particles. As a result, when this emitter uses a fixed bounding volume, the particles are never transformed when that bounding volume is outside the view of the camera. Therefore, when a fixed bounding volume is used (the shouldUseFixedBoundingVolume is set to YES), the value of this property has no effect.</p>
<p>The initial value of this property is YES, indicating that particles will be transformed even when not visible to the camera, unless the shouldUseFixedBoundingVolume property is also set to YES, indicating that emitter has a fixed bounding volume that encompasses all particles. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_c_c3_mesh_particles_8h.html">CC3MeshParticles.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<address class="footer">
<p class="footer"/>© 2010 - 2014 The Brenwill Workshop Ltd.</p>
</address>
</body>
</html>
