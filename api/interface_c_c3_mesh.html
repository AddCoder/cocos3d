<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Cocos3D: Cocos3D API reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-cocos3d.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">
	   <a href="http://cocos3d.org"><img src="http://cocos3d.org/images/cocos3d-Banner-55h.png" /></a>
	   <span id="projectnumber">v2.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="#pub-static-methods">Class Methods</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_c_c3_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CC3Mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#import &lt;CC3Mesh.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3Mesh:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_mesh__inherit__graph.png" border="0" usemap="#_c_c3_mesh_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_mesh_inherit__map" id="_c_c3_mesh_inherit__map">
<area shape="rect" id="node8" href="interface_c_c3_mesh_model.html" title="CC3MeshModel" alt="" coords="807,5,924,32"/><area shape="rect" id="node9" href="interface_c_c3_p_o_d_mesh.html" title="A CC3Mesh whose content originates from POD resource data. " alt="" coords="810,56,921,83"/><area shape="rect" id="node10" href="interface_c_c3_point_particle_mesh.html" title="Deprecated. " alt="" coords="787,107,943,133"/><area shape="rect" id="node11" href="interface_c_c3_vertex_array_mesh.html" title="Deprecated. " alt="" coords="789,157,941,184"/><area shape="rect" id="node12" href="interface_c_c3_vertex_array_mesh_model.html" title="Deprecated. " alt="" coords="771,208,959,235"/><area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="478,107,591,133"/><area shape="rect" id="node4" href="protocol_c_c3_cacheable-p.html" title="Defines the behaviour required for an object that can be held in a cache. " alt="" coords="301,107,429,133"/><area shape="rect" id="node5" href="protocol_c_c3_object-p.html" title="Extension to support Cocos3D functionality. " alt="" coords="150,107,253,133"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a45862be4c44c2b5a6e477a61f575a0ea">__deprecated</a></td></tr>
<tr class="separator:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a45862be4c44c2b5a6e477a61f575a0ea">__deprecated</a></td></tr>
<tr class="separator:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60058461d064b188aafaec395d909551"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node_bounding_volume.html">CC3NodeBoundingVolume</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a60058461d064b188aafaec395d909551">__deprecated</a></td></tr>
<tr class="separator:a60058461d064b188aafaec395d909551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a45862be4c44c2b5a6e477a61f575a0ea">__deprecated</a></td></tr>
<tr class="separator:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a45862be4c44c2b5a6e477a61f575a0ea">__deprecated</a></td></tr>
<tr class="separator:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a45862be4c44c2b5a6e477a61f575a0ea">__deprecated</a></td></tr>
<tr class="separator:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a45862be4c44c2b5a6e477a61f575a0ea">__deprecated</a></td></tr>
<tr class="separator:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a45862be4c44c2b5a6e477a61f575a0ea">__deprecated</a></td></tr>
<tr class="separator:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a45862be4c44c2b5a6e477a61f575a0ea">__deprecated</a></td></tr>
<tr class="separator:a45862be4c44c2b5a6e477a61f575a0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52db2e2d5c6d7237ab8affd6bc2a69a"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ad52db2e2d5c6d7237ab8affd6bc2a69a">addTextureCoordinates:</a></td></tr>
<tr class="separator:ad52db2e2d5c6d7237ab8affd6bc2a69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c31fa7e139566921be59f533f0dfd3"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ae9c31fa7e139566921be59f533f0dfd3">alignTextureUnit:withTexture:</a></td></tr>
<tr class="separator:ae9c31fa7e139566921be59f533f0dfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac018f86eee6ea8a566883bd3384c8dd5"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ac018f86eee6ea8a566883bd3384c8dd5">alignWithInvertedTexturesIn:</a></td></tr>
<tr class="separator:ac018f86eee6ea8a566883bd3384c8dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41d0da06fc63339b5267edc0dfe9846"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aa41d0da06fc63339b5267edc0dfe9846">alignWithTexturesIn:</a></td></tr>
<tr class="separator:aa41d0da06fc63339b5267edc0dfe9846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc48788e518515bb85d9607546eee23b"><td class="memItemLeft" align="right" valign="top">(GLushort *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#acc48788e518515bb85d9607546eee23b">allocateIndexedTriangles:</a></td></tr>
<tr class="separator:acc48788e518515bb85d9607546eee23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad828d0d73dd2aca5da2abab520ae6f40"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_textured_vertex.html">CC3TexturedVertex</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ad828d0d73dd2aca5da2abab520ae6f40">allocateTexturedVertices:</a></td></tr>
<tr class="separator:ad828d0d73dd2aca5da2abab520ae6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b60ba6fb792a8d414e4bc3c75c77e59"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a4b60ba6fb792a8d414e4bc3c75c77e59">bindWithVisitor:</a></td></tr>
<tr class="separator:a4b60ba6fb792a8d414e4bc3c75c77e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b5fda661ccbed22ffc50a18e1c2c41"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a46b5fda661ccbed22ffc50a18e1c2c41">copyVertexAt:from:to:</a></td></tr>
<tr class="separator:a46b5fda661ccbed22ffc50a18e1c2c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e0b37f47f8d3c553f8e8257043f265"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#af1e0b37f47f8d3c553f8e8257043f265">copyVertexIndices:from:inMesh:to:offsettingBy:</a></td></tr>
<tr class="separator:af1e0b37f47f8d3c553f8e8257043f265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdf61ab2ca6faee09c30b72a7aaad6a"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a6bdf61ab2ca6faee09c30b72a7aaad6a">copyVertexIndices:from:to:offsettingBy:</a></td></tr>
<tr class="separator:a6bdf61ab2ca6faee09c30b72a7aaad6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd621575151edf636d0412fd73a68ee"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a7bd621575151edf636d0412fd73a68ee">copyVertices:from:inMesh:to:</a></td></tr>
<tr class="separator:a7bd621575151edf636d0412fd73a68ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9471d2dafbd6ad9b5f86a1756b814dab"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a9471d2dafbd6ad9b5f86a1756b814dab">copyVertices:from:to:</a></td></tr>
<tr class="separator:a9471d2dafbd6ad9b5f86a1756b814dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9407049ba2360bd1e4fb7d71528f72"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#add9407049ba2360bd1e4fb7d71528f72">createGLBuffers</a></td></tr>
<tr class="separator:add9407049ba2360bd1e4fb7d71528f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229ebe05173b24083df7670142329dc0"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a229ebe05173b24083df7670142329dc0">deleteGLBuffers</a></td></tr>
<tr class="separator:a229ebe05173b24083df7670142329dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5a60c9141db6300b8c133b7df6dc30"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aaa5a60c9141db6300b8c133b7df6dc30">doNotBufferVertexBitangents</a></td></tr>
<tr class="separator:aaa5a60c9141db6300b8c133b7df6dc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72a75deb7faca166830b7e0fb10a860"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ac72a75deb7faca166830b7e0fb10a860">doNotBufferVertexBoneIndices</a></td></tr>
<tr class="separator:ac72a75deb7faca166830b7e0fb10a860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a47cdad8636977c4b17600d83385bca"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a1a47cdad8636977c4b17600d83385bca">doNotBufferVertexBoneWeights</a></td></tr>
<tr class="separator:a1a47cdad8636977c4b17600d83385bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf52e2f315042f9d460fe498ce2e49ae"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#abf52e2f315042f9d460fe498ce2e49ae">doNotBufferVertexColors</a></td></tr>
<tr class="separator:abf52e2f315042f9d460fe498ce2e49ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7d45545ec9e0b0686529611c58b30"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a0af7d45545ec9e0b0686529611c58b30">doNotBufferVertexContent</a></td></tr>
<tr class="separator:a0af7d45545ec9e0b0686529611c58b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90ec5e09f1e234180493efa7cffeba9"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ad90ec5e09f1e234180493efa7cffeba9">doNotBufferVertexIndices</a></td></tr>
<tr class="separator:ad90ec5e09f1e234180493efa7cffeba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13c4436396a1f7665419abaa6e36d2b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#af13c4436396a1f7665419abaa6e36d2b">doNotBufferVertexLocations</a></td></tr>
<tr class="separator:af13c4436396a1f7665419abaa6e36d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af143643024e51626d7964ab32e42640b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#af143643024e51626d7964ab32e42640b">doNotBufferVertexNormals</a></td></tr>
<tr class="separator:af143643024e51626d7964ab32e42640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04965c5cafe44856da4aab445ea1b437"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a04965c5cafe44856da4aab445ea1b437">doNotBufferVertexPointSizes</a></td></tr>
<tr class="separator:a04965c5cafe44856da4aab445ea1b437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebed80647564c5fcc6cb0fece391beb"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#afebed80647564c5fcc6cb0fece391beb">doNotBufferVertexTangents</a></td></tr>
<tr class="separator:afebed80647564c5fcc6cb0fece391beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2aac3eaa854c47447ffb2012b80343"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#acf2aac3eaa854c47447ffb2012b80343">doNotBufferVertexTextureCoordinates</a></td></tr>
<tr class="separator:acf2aac3eaa854c47447ffb2012b80343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88ac2a93a7d9d69744a3042062b85b0"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ae88ac2a93a7d9d69744a3042062b85b0">drawFrom:forCount:withVisitor:</a></td></tr>
<tr class="separator:ae88ac2a93a7d9d69744a3042062b85b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6349c01b70f4a2bad6b542407e2ee1"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a5e6349c01b70f4a2bad6b542407e2ee1">drawWithVisitor:</a></td></tr>
<tr class="separator:a5e6349c01b70f4a2bad6b542407e2ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfa32a6d5e4f0fe53321cf808e100b4"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a3dfa32a6d5e4f0fe53321cf808e100b4">ensureCapacity:</a></td></tr>
<tr class="separator:a3dfa32a6d5e4f0fe53321cf808e100b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca4d7682c16135cf0f58fb92dae2e1"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ad1ca4d7682c16135cf0f58fb92dae2e1">ensureVertexCapacity:</a></td></tr>
<tr class="separator:ad1ca4d7682c16135cf0f58fb92dae2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd98fc4ffd062e375c4e7d6f89b1ffe"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a1fd98fc4ffd062e375c4e7d6f89b1ffe">ensureVertexContent</a></td></tr>
<tr class="separator:a1fd98fc4ffd062e375c4e7d6f89b1ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d4e3afa03babe33fad4922d8b4d484"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a54d4e3afa03babe33fad4922d8b4d484">expectsVerticallyFlippedTexture:inTextureUnit:</a></td></tr>
<tr class="separator:a54d4e3afa03babe33fad4922d8b4d484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf19da7c2aa873c6398c96ce933eb543"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#abf19da7c2aa873c6398c96ce933eb543">expectsVerticallyFlippedTextureInTextureUnit:</a></td></tr>
<tr class="separator:abf19da7c2aa873c6398c96ce933eb543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4407d6e4d4f446e0c9f50556d5fcc80"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_face.html">CC3Face</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ac4407d6e4d4f446e0c9f50556d5fcc80">faceAt:</a></td></tr>
<tr class="separator:ac4407d6e4d4f446e0c9f50556d5fcc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa0ff6380b79119cb88759091a4d18b"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#afaa0ff6380b79119cb88759091a4d18b">faceCenterAt:</a></td></tr>
<tr class="separator:afaa0ff6380b79119cb88759091a4d18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485dc052c49c39fe7ff132fd77bf2a92"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a485dc052c49c39fe7ff132fd77bf2a92">faceCountFromVertexCount:</a></td></tr>
<tr class="separator:a485dc052c49c39fe7ff132fd77bf2a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e78c71964d5098813400d6693a0e7ca"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a4e78c71964d5098813400d6693a0e7ca">faceCountFromVertexIndexCount:</a></td></tr>
<tr class="separator:a4e78c71964d5098813400d6693a0e7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a129e5e04d1fe3c2888df7aa98e23c"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_face.html">CC3Face</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a59a129e5e04d1fe3c2888df7aa98e23c">faceFromIndices:</a></td></tr>
<tr class="separator:a59a129e5e04d1fe3c2888df7aa98e23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5a1dc025773491c8ff8c5341148f6f"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_face_indices.html">CC3FaceIndices</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a1b5a1dc025773491c8ff8c5341148f6f">faceIndicesAt:</a></td></tr>
<tr class="separator:a1b5a1dc025773491c8ff8c5341148f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a31c487bf762d872d095a3e8d52bf1"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_face_neighbours.html">CC3FaceNeighbours</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a94a31c487bf762d872d095a3e8d52bf1">faceNeighboursAt:</a></td></tr>
<tr class="separator:a94a31c487bf762d872d095a3e8d52bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fde3c7682514ff7aabc7497014d1f2a"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a8fde3c7682514ff7aabc7497014d1f2a">faceNormalAt:</a></td></tr>
<tr class="separator:a8fde3c7682514ff7aabc7497014d1f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a14b0cc30e32e31727641fff7b7a3f"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_plane.html">CC3Plane</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ab0a14b0cc30e32e31727641fff7b7a3f">facePlaneAt:</a></td></tr>
<tr class="separator:ab0a14b0cc30e32e31727641fff7b7a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dddc107949f65f7ffe4d898d217528"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a35dddc107949f65f7ffe4d898d217528">findFirst:intersections:ofLocalRay:acceptBackFaces:acceptBehindRay:</a></td></tr>
<tr class="separator:a35dddc107949f65f7ffe4d898d217528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb6b53816984679eba96a80abac7e55"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#abfb6b53816984679eba96a80abac7e55">flipHorizontallyTextureUnit:</a></td></tr>
<tr class="separator:abfb6b53816984679eba96a80abac7e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8d6c1777c085f61249e28083c8a5c2"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a5f8d6c1777c085f61249e28083c8a5c2">flipNormals</a></td></tr>
<tr class="separator:a5f8d6c1777c085f61249e28083c8a5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a19bb219d6559b58d1b31a179d44c98"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a2a19bb219d6559b58d1b31a179d44c98">flipTexturesHorizontally</a></td></tr>
<tr class="separator:a2a19bb219d6559b58d1b31a179d44c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f38fa308e856531720632778d9528f5"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a7f38fa308e856531720632778d9528f5">flipTexturesVertically</a></td></tr>
<tr class="separator:a7f38fa308e856531720632778d9528f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd29948a5051b553ff3dbea90907b80"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a3fd29948a5051b553ff3dbea90907b80">flipVerticallyTextureUnit:</a></td></tr>
<tr class="separator:a3fd29948a5051b553ff3dbea90907b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062074189efa26646f47a67e458acdfd"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_vertex_texture_coordinates.html">CC3VertexTextureCoordinates</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a062074189efa26646f47a67e458acdfd">getTextureCoordinatesNamed:</a></td></tr>
<tr class="separator:a062074189efa26646f47a67e458acdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195cd5c55b0beb7aa5ed74be08c27d6a"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a195cd5c55b0beb7aa5ed74be08c27d6a">moveMeshOriginTo:</a></td></tr>
<tr class="separator:a195cd5c55b0beb7aa5ed74be08c27d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fae78d622549776f43e7d228382962d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a3fae78d622549776f43e7d228382962d">moveMeshOriginToCenterOfGeometry</a></td></tr>
<tr class="separator:a3fae78d622549776f43e7d228382962d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dde07fc6ec999f61c20f1cbf71e6f2e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a3dde07fc6ec999f61c20f1cbf71e6f2e">movePivotTo:</a></td></tr>
<tr class="separator:a3dde07fc6ec999f61c20f1cbf71e6f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95332ae63912bd91b2731d10dd1c693f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a95332ae63912bd91b2731d10dd1c693f">populateAsBitmapFontLabelFromString:andFont:andLineHeight:andTextAlignment:andRelativeOrigin:andTessellation:</a></td></tr>
<tr class="separator:a95332ae63912bd91b2731d10dd1c693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bd5a646995672c1fe27a5b0c54df1d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a98bd5a646995672c1fe27a5b0c54df1d">populateAsCenteredRectangleWithSize:</a></td></tr>
<tr class="separator:a98bd5a646995672c1fe27a5b0c54df1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac516a0e20127107db00247a6eb37b06e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ac516a0e20127107db00247a6eb37b06e">populateAsCenteredRectangleWithSize:andTessellation:</a></td></tr>
<tr class="separator:ac516a0e20127107db00247a6eb37b06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a12aee31ef691ea699cb7565c8dcb9"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a87a12aee31ef691ea699cb7565c8dcb9">populateAsCubeMappedSolidBox:</a></td></tr>
<tr class="separator:a87a12aee31ef691ea699cb7565c8dcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276591a31024060be5166bb48dd98307"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a276591a31024060be5166bb48dd98307">populateAsDiskWithRadius:andTessellation:</a></td></tr>
<tr class="separator:a276591a31024060be5166bb48dd98307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa647f1105acb757f3c30de865559f67"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aaa647f1105acb757f3c30de865559f67">populateAsHollowConeWithRadius:height:andTessellation:</a></td></tr>
<tr class="separator:aaa647f1105acb757f3c30de865559f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5aab8b6ab6777b50c564816d14d86a"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#acc5aab8b6ab6777b50c564816d14d86a">populateAsLineStripWith:vertices:andRetain:</a></td></tr>
<tr class="separator:acc5aab8b6ab6777b50c564816d14d86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb889980907f2a86b8e6557807c73cd"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a8cb889980907f2a86b8e6557807c73cd">populateAsRectangleWithSize:andRelativeOrigin:</a></td></tr>
<tr class="separator:a8cb889980907f2a86b8e6557807c73cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8619cf9746d7b4b8f39d11952720773f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a8619cf9746d7b4b8f39d11952720773f">populateAsRectangleWithSize:andRelativeOrigin:andTessellation:</a></td></tr>
<tr class="separator:a8619cf9746d7b4b8f39d11952720773f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3839f11d94d436961ae959bbaed4e89"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ae3839f11d94d436961ae959bbaed4e89">populateAsSolidBox:</a></td></tr>
<tr class="separator:ae3839f11d94d436961ae959bbaed4e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb56e8d12756fa43e6e59b8d12092d6"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#abcb56e8d12756fa43e6e59b8d12092d6">populateAsSolidBox:withCorner:</a></td></tr>
<tr class="separator:abcb56e8d12756fa43e6e59b8d12092d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7733df5e671cae7d60369862c79b86d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#af7733df5e671cae7d60369862c79b86d">populateAsSphereWithRadius:andTessellation:</a></td></tr>
<tr class="separator:af7733df5e671cae7d60369862c79b86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadca0656abb5e235ba0eb2e2727e12de"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aadca0656abb5e235ba0eb2e2727e12de">populateAsTriangle:withTexCoords:andTessellation:</a></td></tr>
<tr class="separator:aadca0656abb5e235ba0eb2e2727e12de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f12125bc3e8bddf96dd852e46588abe"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a8f12125bc3e8bddf96dd852e46588abe">populateAsWireBox:</a></td></tr>
<tr class="separator:a8f12125bc3e8bddf96dd852e46588abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953388a5a8fa3acb287690e968fcf79f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a953388a5a8fa3acb287690e968fcf79f">releaseRedundantContent</a></td></tr>
<tr class="separator:a953388a5a8fa3acb287690e968fcf79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785f176851843f39be841484ec169846"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a785f176851843f39be841484ec169846">removeAllTextureCoordinates</a></td></tr>
<tr class="separator:a785f176851843f39be841484ec169846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c180e5e4c35a2eae2ee0bffe1a496e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a16c180e5e4c35a2eae2ee0bffe1a496e">removeTextureCoordinates:</a></td></tr>
<tr class="separator:a16c180e5e4c35a2eae2ee0bffe1a496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa256b77a007dc390ca8b4af81bf329ab"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aa256b77a007dc390ca8b4af81bf329ab">repeatTexture:</a></td></tr>
<tr class="separator:aa256b77a007dc390ca8b4af81bf329ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb0407a4f49543196cdd61c851830ff"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#afcb0407a4f49543196cdd61c851830ff">repeatTexture:forTextureUnit:</a></td></tr>
<tr class="separator:afcb0407a4f49543196cdd61c851830ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fd302dcc2569352cbf14f711b03729"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a63fd302dcc2569352cbf14f711b03729">retainVertexBitangents</a></td></tr>
<tr class="separator:a63fd302dcc2569352cbf14f711b03729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab092d3925c9c04de3094633825ea7449"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ab092d3925c9c04de3094633825ea7449">retainVertexBoneIndices</a></td></tr>
<tr class="separator:ab092d3925c9c04de3094633825ea7449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5690999af1e8a0dd7503d3e1283081b8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a5690999af1e8a0dd7503d3e1283081b8">retainVertexBoneWeights</a></td></tr>
<tr class="separator:a5690999af1e8a0dd7503d3e1283081b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4e4f796b40b81f5041c7db69692de5"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a4d4e4f796b40b81f5041c7db69692de5">retainVertexColors</a></td></tr>
<tr class="separator:a4d4e4f796b40b81f5041c7db69692de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e7d3a41bd79af9d1dad898f417809"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ad88e7d3a41bd79af9d1dad898f417809">retainVertexContent</a></td></tr>
<tr class="separator:ad88e7d3a41bd79af9d1dad898f417809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9418b19b821c6127392eddeed7730d8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#af9418b19b821c6127392eddeed7730d8">retainVertexIndices</a></td></tr>
<tr class="separator:af9418b19b821c6127392eddeed7730d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa5bd30d6c22ab7fb3d9b43627e9a95"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a4aa5bd30d6c22ab7fb3d9b43627e9a95">retainVertexLocations</a></td></tr>
<tr class="separator:a4aa5bd30d6c22ab7fb3d9b43627e9a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087f4bde149868930686af3bdac971f8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a087f4bde149868930686af3bdac971f8">retainVertexNormals</a></td></tr>
<tr class="separator:a087f4bde149868930686af3bdac971f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc57b27d389a09353bc22d1e2382b3a"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a1bc57b27d389a09353bc22d1e2382b3a">retainVertexPointSizes</a></td></tr>
<tr class="separator:a1bc57b27d389a09353bc22d1e2382b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303e65417e99c6bc597d6650138e2cd8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a303e65417e99c6bc597d6650138e2cd8">retainVertexTangents</a></td></tr>
<tr class="separator:a303e65417e99c6bc597d6650138e2cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e83fd5ac13c16e87948ef08bb09b8c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ab8e83fd5ac13c16e87948ef08bb09b8c">retainVertexTextureCoordinates</a></td></tr>
<tr class="separator:ab8e83fd5ac13c16e87948ef08bb09b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d44e89f08f928d4202f53c47407a600"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a1d44e89f08f928d4202f53c47407a600">setTextureCoordinates:forTextureUnit:</a></td></tr>
<tr class="separator:a1d44e89f08f928d4202f53c47407a600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4b01c5368d3425072124f59b2ad7a6"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a6d4b01c5368d3425072124f59b2ad7a6">setTextureRectangle:forTextureUnit:</a></td></tr>
<tr class="separator:a6d4b01c5368d3425072124f59b2ad7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab284e9f42e9ad699c52b26e898b08c8c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ab284e9f42e9ad699c52b26e898b08c8c">setVertexBitangent:at:</a></td></tr>
<tr class="separator:ab284e9f42e9ad699c52b26e898b08c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6112ae83444c9b6301bb85540b691221"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a6112ae83444c9b6301bb85540b691221">setVertexBoneIndex:forBoneInfluence:at:</a></td></tr>
<tr class="separator:a6112ae83444c9b6301bb85540b691221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad997be4b80139f831fc3a83fd76fcfcd"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ad997be4b80139f831fc3a83fd76fcfcd">setVertexBoneIndices:at:</a></td></tr>
<tr class="separator:ad997be4b80139f831fc3a83fd76fcfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4309734405f485320428c5fff5bd9fd"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ae4309734405f485320428c5fff5bd9fd">setVertexBoneWeights:at:</a></td></tr>
<tr class="separator:ae4309734405f485320428c5fff5bd9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5656a6edc8be3aadd1bfa4d8fe3e727"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aa5656a6edc8be3aadd1bfa4d8fe3e727">setVertexColor4B:at:</a></td></tr>
<tr class="separator:aa5656a6edc8be3aadd1bfa4d8fe3e727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a05712439b021b212e51e402ccc0d1"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#af0a05712439b021b212e51e402ccc0d1">setVertexColor4F:at:</a></td></tr>
<tr class="separator:af0a05712439b021b212e51e402ccc0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5bd3c99a10063d1d9e755507d1edf4"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ada5bd3c99a10063d1d9e755507d1edf4">setVertexHomogeneousLocation:at:</a></td></tr>
<tr class="separator:ada5bd3c99a10063d1d9e755507d1edf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3166d599922702a93b5e5bbd49510b48"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a3166d599922702a93b5e5bbd49510b48">setVertexIndex:at:</a></td></tr>
<tr class="separator:a3166d599922702a93b5e5bbd49510b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8895f4c5763420cc32efa3c771c407"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a5c8895f4c5763420cc32efa3c771c407">setVertexLocation:at:</a></td></tr>
<tr class="separator:a5c8895f4c5763420cc32efa3c771c407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4868f458c4402749922ac7a6df0011"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aae4868f458c4402749922ac7a6df0011">setVertexMatrixIndex:forVertexUnit:at:</a></td></tr>
<tr class="separator:aae4868f458c4402749922ac7a6df0011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac004fc56847fc7e060dde21ffdfa7628"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ac004fc56847fc7e060dde21ffdfa7628">setVertexMatrixIndices:at:</a></td></tr>
<tr class="separator:ac004fc56847fc7e060dde21ffdfa7628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa682abd0d8464017b983d5ff362c317d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aa682abd0d8464017b983d5ff362c317d">setVertexNormal:at:</a></td></tr>
<tr class="separator:aa682abd0d8464017b983d5ff362c317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6c2ce6c498d7029b546e233f4448d0"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aca6c2ce6c498d7029b546e233f4448d0">setVertexPointSize:at:</a></td></tr>
<tr class="separator:aca6c2ce6c498d7029b546e233f4448d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cadb4ecb56f1b13aa9e2e0e43b0c968"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a3cadb4ecb56f1b13aa9e2e0e43b0c968">setVertexTangent:at:</a></td></tr>
<tr class="separator:a3cadb4ecb56f1b13aa9e2e0e43b0c968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bc4d8f5320d37fce02f4bf0c086bb5"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ad9bc4d8f5320d37fce02f4bf0c086bb5">setVertexTexCoord2F:at:</a></td></tr>
<tr class="separator:ad9bc4d8f5320d37fce02f4bf0c086bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7117e2f396a5c60ee7d984dd28fc761"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ae7117e2f396a5c60ee7d984dd28fc761">setVertexTexCoord2F:at:forTextureUnit:</a></td></tr>
<tr class="separator:ae7117e2f396a5c60ee7d984dd28fc761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0947df4d24d3b6608fcc77a4eb41309"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ad0947df4d24d3b6608fcc77a4eb41309">setVertexTexCoord2F:forTextureUnit:at:</a></td></tr>
<tr class="separator:ad0947df4d24d3b6608fcc77a4eb41309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cc67be65c67a47cd64b103da50c143"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a48cc67be65c67a47cd64b103da50c143">setVertexWeight:forBoneInfluence:at:</a></td></tr>
<tr class="separator:a48cc67be65c67a47cd64b103da50c143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0901f3364f28f602d9545bf735e9a6b0"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a0901f3364f28f602d9545bf735e9a6b0">setVertexWeight:forVertexUnit:at:</a></td></tr>
<tr class="separator:a0901f3364f28f602d9545bf735e9a6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc31e3c4cb02dc997862294f5553713"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a5dc31e3c4cb02dc997862294f5553713">setVertexWeights:at:</a></td></tr>
<tr class="separator:a5dc31e3c4cb02dc997862294f5553713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3fb0cb7631dd21c1a63646e5ffea49"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_vertex_texture_coordinates.html">CC3VertexTextureCoordinates</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aea3fb0cb7631dd21c1a63646e5ffea49">textureCoordinatesForTextureUnit:</a></td></tr>
<tr class="separator:aea3fb0cb7631dd21c1a63646e5ffea49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bcbd2a4349f0cac6c4f43b6368ccce"><td class="memItemLeft" align="right" valign="top">(CGRect)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a50bcbd2a4349f0cac6c4f43b6368ccce">textureRectangleForTextureUnit:</a></td></tr>
<tr class="separator:a50bcbd2a4349f0cac6c4f43b6368ccce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c045f4997ea4f9b95c722c54b907892"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a9c045f4997ea4f9b95c722c54b907892">updateGLBuffers</a></td></tr>
<tr class="separator:a9c045f4997ea4f9b95c722c54b907892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c55790238cb61204de6d0e47b8b616b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a2c55790238cb61204de6d0e47b8b616b">updateGLBuffersStartingAt:forLength:</a></td></tr>
<tr class="separator:a2c55790238cb61204de6d0e47b8b616b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2deb8975b90dbcfbcdd712d248b2aa"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aea2deb8975b90dbcfbcdd712d248b2aa">updatePointSizesGLBuffer</a></td></tr>
<tr class="separator:aea2deb8975b90dbcfbcdd712d248b2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ffd0cf2afa3b1c653e923fac351a7f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#af8ffd0cf2afa3b1c653e923fac351a7f">updateVertexBitangentsGLBuffer</a></td></tr>
<tr class="separator:af8ffd0cf2afa3b1c653e923fac351a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb8aebc296b6538176565d76b4aff96"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#adfb8aebc296b6538176565d76b4aff96">updateVertexBoneIndicesGLBuffer</a></td></tr>
<tr class="separator:adfb8aebc296b6538176565d76b4aff96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0a80c53f8de77a51307a26652603c2"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a9a0a80c53f8de77a51307a26652603c2">updateVertexBoneWeightsGLBuffer</a></td></tr>
<tr class="separator:a9a0a80c53f8de77a51307a26652603c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94e31962b7d39013aeb746d6d2c4160"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#af94e31962b7d39013aeb746d6d2c4160">updateVertexColorsGLBuffer</a></td></tr>
<tr class="separator:af94e31962b7d39013aeb746d6d2c4160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab925a11366aa934f5cf797b666258998"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ab925a11366aa934f5cf797b666258998">updateVertexIndicesGLBuffer</a></td></tr>
<tr class="separator:ab925a11366aa934f5cf797b666258998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff690a5a325fef4f05e50c3f0958e82"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a2ff690a5a325fef4f05e50c3f0958e82">updateVertexLocationsGLBuffer</a></td></tr>
<tr class="separator:a2ff690a5a325fef4f05e50c3f0958e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c94d644d9c71eea23e24b559f9982c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a03c94d644d9c71eea23e24b559f9982c">updateVertexNormalsGLBuffer</a></td></tr>
<tr class="separator:a03c94d644d9c71eea23e24b559f9982c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17ffbec86d316d89da937ba83355fb0"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aa17ffbec86d316d89da937ba83355fb0">updateVertexStride</a></td></tr>
<tr class="separator:aa17ffbec86d316d89da937ba83355fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3695ea875ad95c6d7cc6f59f439bc8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a6e3695ea875ad95c6d7cc6f59f439bc8">updateVertexTangentsGLBuffer</a></td></tr>
<tr class="separator:a6e3695ea875ad95c6d7cc6f59f439bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc3dee48200842097c95a0dbcb6812d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aedc3dee48200842097c95a0dbcb6812d">updateVertexTextureCoordinatesGLBuffer</a></td></tr>
<tr class="separator:aedc3dee48200842097c95a0dbcb6812d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2b7a99b8db027d40207a7ce3f0532a"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a4f2b7a99b8db027d40207a7ce3f0532a">updateVertexTextureCoordinatesGLBufferForTextureUnit:</a></td></tr>
<tr class="separator:a4f2b7a99b8db027d40207a7ce3f0532a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc9d5e7f1297c8afd0345086139f318"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_vertex_array.html">CC3VertexArray</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a5fc9d5e7f1297c8afd0345086139f318">vertexArrayForSemantic:at:</a></td></tr>
<tr class="separator:a5fc9d5e7f1297c8afd0345086139f318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0682eff71603afc5569c722aed479de6"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a0682eff71603afc5569c722aed479de6">vertexBitangentAt:</a></td></tr>
<tr class="separator:a0682eff71603afc5569c722aed479de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c58270b39d7074ec9867f55980b379d"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a6c58270b39d7074ec9867f55980b379d">vertexBoneIndexForBoneInfluence:at:</a></td></tr>
<tr class="separator:a6c58270b39d7074ec9867f55980b379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf4ff7f839a2ef598101b1972c9bb0e"><td class="memItemLeft" align="right" valign="top">(GLvoid *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#abdf4ff7f839a2ef598101b1972c9bb0e">vertexBoneIndicesAt:</a></td></tr>
<tr class="separator:abdf4ff7f839a2ef598101b1972c9bb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae007aed1ce47c2fca384cbec1112d8cd"><td class="memItemLeft" align="right" valign="top">(GLfloat *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ae007aed1ce47c2fca384cbec1112d8cd">vertexBoneWeightsAt:</a></td></tr>
<tr class="separator:ae007aed1ce47c2fca384cbec1112d8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa23e90220c69559e274a0d6b2b091b"><td class="memItemLeft" align="right" valign="top">(ccColor4B)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#aaaa23e90220c69559e274a0d6b2b091b">vertexColor4BAt:</a></td></tr>
<tr class="separator:aaaa23e90220c69559e274a0d6b2b091b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282a07b33f02899284c49b444acf247f"><td class="memItemLeft" align="right" valign="top">(ccColor4F)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a282a07b33f02899284c49b444acf247f">vertexColor4FAt:</a></td></tr>
<tr class="separator:a282a07b33f02899284c49b444acf247f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09464c08e267e648f18ae6a06b65666"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ab09464c08e267e648f18ae6a06b65666">vertexCountFromFaceCount:</a></td></tr>
<tr class="separator:ab09464c08e267e648f18ae6a06b65666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5813f5c1f1be1f4bd67d5b3d0a2c8c"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a9f5813f5c1f1be1f4bd67d5b3d0a2c8c">vertexHomogeneousLocationAt:</a></td></tr>
<tr class="separator:a9f5813f5c1f1be1f4bd67d5b3d0a2c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1158fcc73de87584dc20a1b8ca36078a"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a1158fcc73de87584dc20a1b8ca36078a">vertexIndexAt:</a></td></tr>
<tr class="separator:a1158fcc73de87584dc20a1b8ca36078a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ce026f9f9c620b3c3767d393f7353e"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a22ce026f9f9c620b3c3767d393f7353e">vertexIndexCountFromFaceCount:</a></td></tr>
<tr class="separator:a22ce026f9f9c620b3c3767d393f7353e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55929ef758b8d2352df12052276c48a4"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a55929ef758b8d2352df12052276c48a4">vertexLocationAt:</a></td></tr>
<tr class="separator:a55929ef758b8d2352df12052276c48a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac168dd774ac7f613a37320d095de3be5"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ac168dd774ac7f613a37320d095de3be5">vertexMatrixIndexForVertexUnit:at:</a></td></tr>
<tr class="separator:ac168dd774ac7f613a37320d095de3be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980e214841939ce900c7824f57d9f60e"><td class="memItemLeft" align="right" valign="top">(GLvoid *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a980e214841939ce900c7824f57d9f60e">vertexMatrixIndicesAt:</a></td></tr>
<tr class="separator:a980e214841939ce900c7824f57d9f60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3f552bdf2bca51201b78045bfb826e"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a5c3f552bdf2bca51201b78045bfb826e">vertexNormalAt:</a></td></tr>
<tr class="separator:a5c3f552bdf2bca51201b78045bfb826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a972f4df733f53d3698deaa96b17b6"><td class="memItemLeft" align="right" valign="top">(GLfloat)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a92a972f4df733f53d3698deaa96b17b6">vertexPointSizeAt:</a></td></tr>
<tr class="separator:a92a972f4df733f53d3698deaa96b17b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36c8b1cc658d33cb15bcf1e5e2c4c5f"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#af36c8b1cc658d33cb15bcf1e5e2c4c5f">vertexTangentAt:</a></td></tr>
<tr class="separator:af36c8b1cc658d33cb15bcf1e5e2c4c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4188e0c98e379b8f6082edd896707946"><td class="memItemLeft" align="right" valign="top">(ccTex2F)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a4188e0c98e379b8f6082edd896707946">vertexTexCoord2FAt:</a></td></tr>
<tr class="separator:a4188e0c98e379b8f6082edd896707946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cb57766654b3c9f03dcb3adcb88151"><td class="memItemLeft" align="right" valign="top">(ccTex2F)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a63cb57766654b3c9f03dcb3adcb88151">vertexTexCoord2FAt:forTextureUnit:</a></td></tr>
<tr class="separator:a63cb57766654b3c9f03dcb3adcb88151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f389ae33ed3ef4b42f8a7d64a092292"><td class="memItemLeft" align="right" valign="top">(ccTex2F)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a9f389ae33ed3ef4b42f8a7d64a092292">vertexTexCoord2FForTextureUnit:at:</a></td></tr>
<tr class="separator:a9f389ae33ed3ef4b42f8a7d64a092292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cddf30c65fc1af604a780c56362c8c"><td class="memItemLeft" align="right" valign="top">(GLfloat)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#ae0cddf30c65fc1af604a780c56362c8c">vertexWeightForBoneInfluence:at:</a></td></tr>
<tr class="separator:ae0cddf30c65fc1af604a780c56362c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c72a3d0e5c15148a48e952e7723dfc3"><td class="memItemLeft" align="right" valign="top">(GLfloat)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a4c72a3d0e5c15148a48e952e7723dfc3">vertexWeightForVertexUnit:at:</a></td></tr>
<tr class="separator:a4c72a3d0e5c15148a48e952e7723dfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b434e313ccbbffb9d6b88001e5f6070"><td class="memItemLeft" align="right" valign="top">(GLfloat *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_mesh.html#a4b434e313ccbbffb9d6b88001e5f6070">vertexWeightsAt:</a></td></tr>
<tr class="separator:a4b434e313ccbbffb9d6b88001e5f6070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Instance Methods inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:ac177c497bf19de1f8208eb375edfef37 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#ac177c497bf19de1f8208eb375edfef37">copy</a></td></tr>
<tr class="separator:ac177c497bf19de1f8208eb375edfef37 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6048039af7b953470a6be1640f3f8fa8 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a6048039af7b953470a6be1640f3f8fa8">copyAsClass:</a></td></tr>
<tr class="separator:a6048039af7b953470a6be1640f3f8fa8 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba6f6333ec6b859b17394fa95a549f1 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aaba6f6333ec6b859b17394fa95a549f1">copyUserDataFrom:</a></td></tr>
<tr class="separator:aaba6f6333ec6b859b17394fa95a549f1 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc25bb52f8f0815c0985e02aeac0e35 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a2fc25bb52f8f0815c0985e02aeac0e35">copyWithName:</a></td></tr>
<tr class="separator:a2fc25bb52f8f0815c0985e02aeac0e35 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3b74491add447b79ad63f7f9912b9e inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aff3b74491add447b79ad63f7f9912b9e">copyWithName:asClass:</a></td></tr>
<tr class="separator:aff3b74491add447b79ad63f7f9912b9e inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5698b73dad043a09dd57c19290c1dcf inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aa5698b73dad043a09dd57c19290c1dcf">copyWithZone:withName:</a></td></tr>
<tr class="separator:aa5698b73dad043a09dd57c19290c1dcf inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6788277bbfff67ed111f2392db9f685a inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a6788277bbfff67ed111f2392db9f685a">copyWithZone:withName:asClass:</a></td></tr>
<tr class="separator:a6788277bbfff67ed111f2392db9f685a inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c7dcbb20dd8712720519d0d0c2410b inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#ae9c7dcbb20dd8712720519d0d0c2410b">deriveNameFrom:</a></td></tr>
<tr class="separator:ae9c7dcbb20dd8712720519d0d0c2410b inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60ad034ddbb26e568589c5254c12bff inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aa60ad034ddbb26e568589c5254c12bff">deriveNameFrom:usingSuffix:</a></td></tr>
<tr class="separator:aa60ad034ddbb26e568589c5254c12bff inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84be89f3c9397c4247d406009137b5d inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#af84be89f3c9397c4247d406009137b5d">fullDescription</a></td></tr>
<tr class="separator:af84be89f3c9397c4247d406009137b5d inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51802b824fd430e3281e22574f1266ed inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a51802b824fd430e3281e22574f1266ed">init</a></td></tr>
<tr class="separator:a51802b824fd430e3281e22574f1266ed inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf728516905642fd71b913636fab13c0 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#adf728516905642fd71b913636fab13c0">initAtIndex:fromPODResource:</a></td></tr>
<tr class="separator:adf728516905642fd71b913636fab13c0 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096bc5294d2cc78dd979782504456569 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a096bc5294d2cc78dd979782504456569">initUserData</a></td></tr>
<tr class="separator:a096bc5294d2cc78dd979782504456569 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc220d9cffa20a01ecebefa44a44f354 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#afc220d9cffa20a01ecebefa44a44f354">initWithName:</a></td></tr>
<tr class="separator:afc220d9cffa20a01ecebefa44a44f354 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d154e055437d2e0ba9e707a69e3ec0 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#af7d154e055437d2e0ba9e707a69e3ec0">initWithTag:</a></td></tr>
<tr class="separator:af7d154e055437d2e0ba9e707a69e3ec0 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e0ab825fd6f3e9a703d28039c98886 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a36e0ab825fd6f3e9a703d28039c98886">initWithTag:withName:</a></td></tr>
<tr class="separator:a36e0ab825fd6f3e9a703d28039c98886 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30472ca8359ea9480479ed8301a93eb8 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a30472ca8359ea9480479ed8301a93eb8">nextTag</a></td></tr>
<tr class="separator:a30472ca8359ea9480479ed8301a93eb8 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b647607269d0c6bce0d69459d4b7dea inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a5b647607269d0c6bce0d69459d4b7dea">populateFrom:</a></td></tr>
<tr class="separator:a5b647607269d0c6bce0d69459d4b7dea inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Class Methods</h2></td></tr>
<tr class="memitem:aba5a511998a9ba82ac2d0e886d01b6b8"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_mesh.html#aba5a511998a9ba82ac2d0e886d01b6b8">mesh</a></td></tr>
<tr class="separator:aba5a511998a9ba82ac2d0e886d01b6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ea242a3cef763c53dc9d2e4e9f67e6"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_mesh.html#ac1ea242a3cef763c53dc9d2e4e9f67e6">meshAtIndex:fromPODResource:</a></td></tr>
<tr class="separator:ac1ea242a3cef763c53dc9d2e4e9f67e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdc6046a3a3702348138f0ed58565f8"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_mesh.html#a8bdc6046a3a3702348138f0ed58565f8">meshWithName:</a></td></tr>
<tr class="separator:a8bdc6046a3a3702348138f0ed58565f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7917909ad2887d109ef4ba508a87d9"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_mesh.html#a2f7917909ad2887d109ef4ba508a87d9">meshWithTag:</a></td></tr>
<tr class="separator:a2f7917909ad2887d109ef4ba508a87d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5202c876913aa8043e226ea32df8ec2"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_mesh.html#ab5202c876913aa8043e226ea32df8ec2">meshWithTag:withName:</a></td></tr>
<tr class="separator:ab5202c876913aa8043e226ea32df8ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Class Methods inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:a13ae00555f231e938fcfed31769b8fef inherit pub_static_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(GLint)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_identifiable.html#a13ae00555f231e938fcfed31769b8fef">instanceCount</a></td></tr>
<tr class="separator:a13ae00555f231e938fcfed31769b8fef inherit pub_static_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb2e642c739adb8e0a70f98cf1bfcde inherit pub_static_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_identifiable.html#a0eb2e642c739adb8e0a70f98cf1bfcde">resetTagAllocation</a></td></tr>
<tr class="separator:a0eb2e642c739adb8e0a70f98cf1bfcde inherit pub_static_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ab5fba4899d83894ac06bfbb6710510fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_bone_indices.html">CC3VertexBoneIndices</a> <br class="typebreak"/>
*vertexMatrixIndices&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ab5fba4899d83894ac06bfbb6710510fb">__deprecated</a></td></tr>
<tr class="separator:ab5fba4899d83894ac06bfbb6710510fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7cef079e8c13e6d77110a95ce3e161"><td class="memItemLeft" align="right" valign="top">BOOL hasVertexMatrixIndices&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a1b7cef079e8c13e6d77110a95ce3e161">__deprecated</a></td></tr>
<tr class="separator:a1b7cef079e8c13e6d77110a95ce3e161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf40765d2c2ab6fd15b5afaeb59cee8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_bone_weights.html">CC3VertexBoneWeights</a> *vertexWeights&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aabf40765d2c2ab6fd15b5afaeb59cee8">__deprecated</a></td></tr>
<tr class="separator:aabf40765d2c2ab6fd15b5afaeb59cee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78667b35b79bb7e8211ab5607d1032f7"><td class="memItemLeft" align="right" valign="top">BOOL hasVertexWeights&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a78667b35b79bb7e8211ab5607d1032f7">__deprecated</a></td></tr>
<tr class="separator:a78667b35b79bb7e8211ab5607d1032f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a144155cabacb51b85c0f689a26565"><td class="memItemLeft" align="right" valign="top">GLuint vertexUnitCount&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aa4a144155cabacb51b85c0f689a26565">__deprecated</a></td></tr>
<tr class="separator:aa4a144155cabacb51b85c0f689a26565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35563e05790ebcbad8c0a85f554efccb"><td class="memItemLeft" align="right" valign="top">GLenum matrixIndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a35563e05790ebcbad8c0a85f554efccb">__deprecated</a></td></tr>
<tr class="separator:a35563e05790ebcbad8c0a85f554efccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd8143fd04160ebd01f7f145381106c"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a2cd8143fd04160ebd01f7f145381106c">allocatedVertexCapacity</a></td></tr>
<tr class="separator:a2cd8143fd04160ebd01f7f145381106c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a0fddccf63b95a9757de8a0f2625f5"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ab4a0fddccf63b95a9757de8a0f2625f5">allocatedVertexIndexCapacity</a></td></tr>
<tr class="separator:ab4a0fddccf63b95a9757de8a0f2625f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc37f1c5ac4d3317f6157af5695c9109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_box.html">CC3Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#adc37f1c5ac4d3317f6157af5695c9109">boundingBox</a></td></tr>
<tr class="separator:adc37f1c5ac4d3317f6157af5695c9109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e56739af65416894c3fe1a0775e4f07"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a7e56739af65416894c3fe1a0775e4f07">capacityExpansionFactor</a></td></tr>
<tr class="separator:a7e56739af65416894c3fe1a0775e4f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fd7f1ae2d25f3cd9efe260b554cde5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a70fd7f1ae2d25f3cd9efe260b554cde5">centerOfGeometry</a></td></tr>
<tr class="separator:a70fd7f1ae2d25f3cd9efe260b554cde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67829ffbe68afe9f971e468f7b9bd935"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_c_c2_extensions_8h.html#a9ee2c61886665ba64b5de7be1a1bf83d">CCColorRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a67829ffbe68afe9f971e468f7b9bd935">color</a></td></tr>
<tr class="separator:a67829ffbe68afe9f971e468f7b9bd935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fea1edb0a5bc45a98e02fe2add1e29e"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a6fea1edb0a5bc45a98e02fe2add1e29e">drawingMode</a></td></tr>
<tr class="separator:a6fea1edb0a5bc45a98e02fe2add1e29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c813b311bf7450f5273303fb65ea54b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a8c813b311bf7450f5273303fb65ea54b">expectsVerticallyFlippedTextures</a></td></tr>
<tr class="separator:a8c813b311bf7450f5273303fb65ea54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c46b735abbec7668ae46630700f88f8"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a7c46b735abbec7668ae46630700f88f8">faceCount</a></td></tr>
<tr class="separator:a7c46b735abbec7668ae46630700f88f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944152dc02eda998579be52bf564591b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_face_array.html">CC3FaceArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a944152dc02eda998579be52bf564591b">faces</a></td></tr>
<tr class="separator:a944152dc02eda998579be52bf564591b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739c89fbfaafd15e8826ce88d034b926"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a739c89fbfaafd15e8826ce88d034b926">hasVertexBitangents</a></td></tr>
<tr class="separator:a739c89fbfaafd15e8826ce88d034b926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185eb874a2d5807e5f673718a72692d9"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a185eb874a2d5807e5f673718a72692d9">hasVertexBoneIndices</a></td></tr>
<tr class="separator:a185eb874a2d5807e5f673718a72692d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e66ad3a0e5c6cbab997fac0b99e9dea"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a1e66ad3a0e5c6cbab997fac0b99e9dea">hasVertexBoneWeights</a></td></tr>
<tr class="separator:a1e66ad3a0e5c6cbab997fac0b99e9dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac347e27de3bbb1cf2593be372547f782"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ac347e27de3bbb1cf2593be372547f782">hasVertexColors</a></td></tr>
<tr class="separator:ac347e27de3bbb1cf2593be372547f782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a4effcf34a2331366bab51e72d6833"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a94a4effcf34a2331366bab51e72d6833">hasVertexIndices</a></td></tr>
<tr class="separator:a94a4effcf34a2331366bab51e72d6833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeced0ec2348c6d6a8981986f0ce5e64a"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aeced0ec2348c6d6a8981986f0ce5e64a">hasVertexLocations</a></td></tr>
<tr class="separator:aeced0ec2348c6d6a8981986f0ce5e64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c9b64417c963f2707167b8ad4516c7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a68c9b64417c963f2707167b8ad4516c7">hasVertexNormals</a></td></tr>
<tr class="separator:a68c9b64417c963f2707167b8ad4516c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b847a5ffc6266337f7206feb0ac00f"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ae5b847a5ffc6266337f7206feb0ac00f">hasVertexPointSizes</a></td></tr>
<tr class="separator:ae5b847a5ffc6266337f7206feb0ac00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3004967ec1484d8707b133483a070fd3"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a3004967ec1484d8707b133483a070fd3">hasVertexTangents</a></td></tr>
<tr class="separator:a3004967ec1484d8707b133483a070fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d43189a7abdf66c0908dbf7a6c056b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#af2d43189a7abdf66c0908dbf7a6c056b">hasVertexTextureCoordinates</a></td></tr>
<tr class="separator:af2d43189a7abdf66c0908dbf7a6c056b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e733f11bf78bb7f5f519c6ea3a8638"><td class="memItemLeft" align="right" valign="top">GLvoid *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a07e733f11bf78bb7f5f519c6ea3a8638">interleavedVertices</a></td></tr>
<tr class="separator:a07e733f11bf78bb7f5f519c6ea3a8638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74753e0641e099a30237713591fc257"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ab74753e0641e099a30237713591fc257">isUsingGLBuffers</a></td></tr>
<tr class="separator:ab74753e0641e099a30237713591fc257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3ab53dc69fe91c1b8b41b20186466d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_c_c2_extensions_8h.html#aa13d5a16c4c3791576122915480e1772">CCOpacity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a9b3ab53dc69fe91c1b8b41b20186466d">opacity</a></td></tr>
<tr class="separator:a9b3ab53dc69fe91c1b8b41b20186466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6111e778ad97e6f9bc2ad8724534f921"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a6111e778ad97e6f9bc2ad8724534f921">radius</a></td></tr>
<tr class="separator:a6111e778ad97e6f9bc2ad8724534f921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ab0b1cec2c1378e1418afa511f6f9c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a13ab0b1cec2c1378e1418afa511f6f9c">shouldCacheFaces</a></td></tr>
<tr class="separator:a13ab0b1cec2c1378e1418afa511f6f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1c30e89cdb14e86c1ed7c9f81041ea"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aed1c30e89cdb14e86c1ed7c9f81041ea">shouldInterleaveVertices</a></td></tr>
<tr class="separator:aed1c30e89cdb14e86c1ed7c9f81041ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cd3b5195c0a61e2619e7fb486d5ae6"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ad4cd3b5195c0a61e2619e7fb486d5ae6">textureCoordinatesArrayCount</a></td></tr>
<tr class="separator:ad4cd3b5195c0a61e2619e7fb486d5ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0451580686743d8bbf5baf0745cf7f"><td class="memItemLeft" align="right" valign="top">CGRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aec0451580686743d8bbf5baf0745cf7f">textureRectangle</a></td></tr>
<tr class="separator:aec0451580686743d8bbf5baf0745cf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8283b1283317e1b0f1f684f77d163e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_tangents.html">CC3VertexTangents</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a8283b1283317e1b0f1f684f77d163e93">vertexBitangents</a></td></tr>
<tr class="separator:a8283b1283317e1b0f1f684f77d163e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a9845c404d8f2b54abcce45e95358b"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a79a9845c404d8f2b54abcce45e95358b">vertexBoneCount</a></td></tr>
<tr class="separator:a79a9845c404d8f2b54abcce45e95358b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28acfb1b63f33712cef047b313c4baba"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a28acfb1b63f33712cef047b313c4baba">vertexBoneIndexType</a></td></tr>
<tr class="separator:a28acfb1b63f33712cef047b313c4baba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4351497373ffcff0a5b2857152ce0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_bone_indices.html">CC3VertexBoneIndices</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a9f4351497373ffcff0a5b2857152ce0d">vertexBoneIndices</a></td></tr>
<tr class="separator:a9f4351497373ffcff0a5b2857152ce0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1765a528be5c930c6ec0973b8948b1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_bone_weights.html">CC3VertexBoneWeights</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ae1765a528be5c930c6ec0973b8948b1f">vertexBoneWeights</a></td></tr>
<tr class="separator:ae1765a528be5c930c6ec0973b8948b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae239b202fba4cbbd2c87ddc35731bfae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_colors.html">CC3VertexColors</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ae239b202fba4cbbd2c87ddc35731bfae">vertexColors</a></td></tr>
<tr class="separator:ae239b202fba4cbbd2c87ddc35731bfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcbc934c27858d65d5185bc9708675a"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a7fcbc934c27858d65d5185bc9708675a">vertexColorType</a></td></tr>
<tr class="separator:a7fcbc934c27858d65d5185bc9708675a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4db5ea6ffeefce87e27f9bac0ef6d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_mesh_8h.html#a026556c0ec4fa50f2dab794fdf218d01">CC3VertexContent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aab4db5ea6ffeefce87e27f9bac0ef6d0">vertexContentTypes</a></td></tr>
<tr class="separator:aab4db5ea6ffeefce87e27f9bac0ef6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c40ec899a167c70a246cbe6b764f9c"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a90c40ec899a167c70a246cbe6b764f9c">vertexCount</a></td></tr>
<tr class="separator:a90c40ec899a167c70a246cbe6b764f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55a9dd79522edbd8e9cb5e3b0207abc"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ac55a9dd79522edbd8e9cb5e3b0207abc">vertexIndexCount</a></td></tr>
<tr class="separator:ac55a9dd79522edbd8e9cb5e3b0207abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72231ba14ef8b065704fec46b1e6fe61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_indices.html">CC3VertexIndices</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a72231ba14ef8b065704fec46b1e6fe61">vertexIndices</a></td></tr>
<tr class="separator:a72231ba14ef8b065704fec46b1e6fe61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4129889b4359efd94392c13e9e7b8496"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_locations.html">CC3VertexLocations</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a4129889b4359efd94392c13e9e7b8496">vertexLocations</a></td></tr>
<tr class="separator:a4129889b4359efd94392c13e9e7b8496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759320925da536ec2fe39195bac3fe91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_normals.html">CC3VertexNormals</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a759320925da536ec2fe39195bac3fe91">vertexNormals</a></td></tr>
<tr class="separator:a759320925da536ec2fe39195bac3fe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b308254ced0f1f2c53dc49c0ffd99df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_point_sizes.html">CC3VertexPointSizes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a9b308254ced0f1f2c53dc49c0ffd99df">vertexPointSizes</a></td></tr>
<tr class="separator:a9b308254ced0f1f2c53dc49c0ffd99df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b467f2d94b7aaa44430e4fca87f9fb2"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a1b467f2d94b7aaa44430e4fca87f9fb2">vertexStride</a></td></tr>
<tr class="separator:a1b467f2d94b7aaa44430e4fca87f9fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6d7fc3c5612df7fd66c3fef041ec8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_tangents.html">CC3VertexTangents</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a6e6d7fc3c5612df7fd66c3fef041ec8c">vertexTangents</a></td></tr>
<tr class="separator:a6e6d7fc3c5612df7fd66c3fef041ec8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b82f5b33a840a8149e7cbfda3c0c14f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_texture_coordinates.html">CC3VertexTextureCoordinates</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a6b82f5b33a840a8149e7cbfda3c0c14f">vertexTextureCoordinates</a></td></tr>
<tr class="separator:a6b82f5b33a840a8149e7cbfda3c0c14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('properties_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:af603104494fba5d4791f720823528f9d inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSObject *sharedUserData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#af603104494fba5d4791f720823528f9d">__deprecated</a></td></tr>
<tr class="separator:af603104494fba5d4791f720823528f9d inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cccaa59a3f724bff77683237e271b6 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#ac8cccaa59a3f724bff77683237e271b6">name</a></td></tr>
<tr class="separator:ac8cccaa59a3f724bff77683237e271b6 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deeaefbf8e9fdc758bace96cb88b716 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a2deeaefbf8e9fdc758bace96cb88b716">nameSuffix</a></td></tr>
<tr class="separator:a2deeaefbf8e9fdc758bace96cb88b716 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93489bf1874209effdcb78761e7e3480 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a93489bf1874209effdcb78761e7e3480">podIndex</a></td></tr>
<tr class="separator:a93489bf1874209effdcb78761e7e3480 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65202edca1a66ef060b5b0411cb547c3 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a65202edca1a66ef060b5b0411cb547c3">shouldIncludeInDeepCopy</a></td></tr>
<tr class="separator:a65202edca1a66ef060b5b0411cb547c3 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe2d1079602a9b93e1803b5d8aefdcc inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a4fe2d1079602a9b93e1803b5d8aefdcc">tag</a></td></tr>
<tr class="separator:a4fe2d1079602a9b93e1803b5d8aefdcc inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82555dcf853eeb9fcdcc5fae1c1fcd5c inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a82555dcf853eeb9fcdcc5fae1c1fcd5c">userData</a></td></tr>
<tr class="separator:a82555dcf853eeb9fcdcc5fae1c1fcd5c inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_protocol_c_c3_cacheable-p"><td colspan="2" onclick="javascript:toggleInherit('properties_protocol_c_c3_cacheable-p')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="protocol_c_c3_cacheable-p.html">&lt;CC3Cacheable&gt;</a></td></tr>
<tr class="memitem:af3f0574df825aa03a7b7646918212512 inherit properties_protocol_c_c3_cacheable-p"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_c_c3_cacheable-p.html#af3f0574df825aa03a7b7646918212512">name</a></td></tr>
<tr class="separator:af3f0574df825aa03a7b7646918212512 inherit properties_protocol_c_c3_cacheable-p"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> holds the 3D mesh for a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>. </p>
<p>In 3D models, the mesh generally remains fixed, and transformations such as translation, rotation, and scaling are applied at the node level. A single <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> instance, which typically contains a large set of data points, can be used by many nodes simultaneously, and each node instance can be transformed, colored, and textured independently.</p>
<p>With this in mind, and following best practices to consevere memory and processing time, you should strive to create only one <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> instance for each distinct mesh in your application, and assign that single <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> instance to any number of separate <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> instances that make use of it.</p>
<p>The vertex content in this mesh is kept in a set of CC3VertexArrays instances. Each of the contained <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> instances manages the data for one aspect of the vertices (locations, normals, colors, texture mapping, bone weights...).</p>
<p>Vertex data can be interleaved into a single underlying memory buffer that is shared between the contained CC3VertexArrays, or it can be separated into distinct memory buffers for each vertex aspect.</p>
<p>The only vertex array that is required is the vertexLocations property. The others are optional, depending on the nature of the mesh. If the vertexIndices property is provided, it will be used during drawing. If ther vertexIndices property is nil, the vertices will be drawn in linear order as they appear in the vertexLocations property.</p>
<p>This class supports multi-texturing. In most situations, the mesh will use the same texture mapping for all texture units. In this case, the single texture coordinates array in the vertexTexureCoordinates property will be applied to all textures in the material applied to a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> using this mesh.</p>
<p>If multi-texturing is used, and separate texture coordinate mapping is required for each texture unit, additional texture coordinate arrays can be added using the addTextureCoordinates: method.</p>
<p>For consistency, the addTextureCoordinates:, removeTextureCoordinates:, and getTextureCoordinatesNamed: methods all interact with the vertexTextureCoordinates property. If that property has not been set, the first texture coordinate array that is added via addTextureCoordinates: will be set into the vertexTextureCoordinates array. And the removeTextureCoordinates:, and getTextureCoordinatesNamed: methods each check the vertexTextureCoordinates property as well as the overlayTextureCoordinates collection. This design can simplify configurations in that all texture coordinate arrays can be treated the same.</p>
<p>If there are more textures applied to a node than there are texture coordinate arrays in the mesh (including the vertexTextureCoordinates and the those in the overlayTextureCoordinates collection), the last texture coordinate array is reused.</p>
<p>This class supports covering the mesh with a repeating texture through the repeatTexture: method.</p>
<p>This class also supports covering the mesh with only a fractional part of the texture through the use of the textureRectangle property, effectlivly permitting sprite-sheet textures to be used with 3D meshes.</p>
<p>When a copy is made of a <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> instance, copies are not made of the vertex arrays. Instead, they are retained by reference and shared between both the original mesh, and the new copy.</p>
<p><a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> manages data for one contiguous set of vertices that can be drawn with a single call to the GL engine, or a single set of draw-strip calls to the GL engine, using the same material properties. To assemble a large, complex mesh containing several distinct vertex groups, assign each vertex group to its own <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> instance, wrap each mesh instance in a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> instance, and create an structural assembly of the nodes. See the class notes for <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> for more information on assembling mesh nodes.</p>
<p>When drawing the mesh to the GL engine, this class remembers which mesh was last drawn and only binds the mesh data to the GL engine when a different mesh is drawn. This allows the application to organize the CC3MeshNodes within the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> so that nodes using the same mesh are drawn together, before moving on to other mesh models. This strategy can minimize the number of mesh switches in the GL engine, which improves performance.</p>
<p><a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> is an abstract class. Subclasses can be created for loading and managing meshes from different sources and third-party libraries. </p>
</div><h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="a45862be4c44c2b5a6e477a61f575a0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated:</a></b></dt><dd>Renamed to releaseRedundantContent. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_point_particle_mesh.html#aeabdeb14fe5a540d3628305289ca6392">CC3PointParticleMesh</a>.</p>

</div>
</div>
<a class="anchor" id="a45862be4c44c2b5a6e477a61f575a0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000048">Deprecated:</a></b></dt><dd>Renamed to moveMeshOriginToCenterOfGeometry. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_point_particle_mesh.html#aeabdeb14fe5a540d3628305289ca6392">CC3PointParticleMesh</a>.</p>

</div>
</div>
<a class="anchor" id="a60058461d064b188aafaec395d909551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node_bounding_volume.html">CC3NodeBoundingVolume</a>*) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>No longer used. The bounding volume is now created in the same method in <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_point_particle_mesh.html#aeabdeb14fe5a540d3628305289ca6392">CC3PointParticleMesh</a>.</p>

</div>
</div>
<a class="anchor" id="a45862be4c44c2b5a6e477a61f575a0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000066">Deprecated:</a></b></dt><dd>Renamed to updateVertexBoneWeightsGLBuffer. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_point_particle_mesh.html#aeabdeb14fe5a540d3628305289ca6392">CC3PointParticleMesh</a>.</p>

</div>
</div>
<a class="anchor" id="a45862be4c44c2b5a6e477a61f575a0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000067">Deprecated:</a></b></dt><dd>Renamed to updateVertexBoneIndicesGLBuffer. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_point_particle_mesh.html#aeabdeb14fe5a540d3628305289ca6392">CC3PointParticleMesh</a>.</p>

</div>
</div>
<a class="anchor" id="a45862be4c44c2b5a6e477a61f575a0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000068">Deprecated:</a></b></dt><dd>Renamed to retainVertexBoneWeights. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_point_particle_mesh.html#aeabdeb14fe5a540d3628305289ca6392">CC3PointParticleMesh</a>.</p>

</div>
</div>
<a class="anchor" id="a45862be4c44c2b5a6e477a61f575a0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>Renamed to retainVertexBoneIndices. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_point_particle_mesh.html#aeabdeb14fe5a540d3628305289ca6392">CC3PointParticleMesh</a>.</p>

</div>
</div>
<a class="anchor" id="a45862be4c44c2b5a6e477a61f575a0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000070">Deprecated:</a></b></dt><dd>Renamed to doNotBufferVertexBoneWeights. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_point_particle_mesh.html#aeabdeb14fe5a540d3628305289ca6392">CC3PointParticleMesh</a>.</p>

</div>
</div>
<a class="anchor" id="a45862be4c44c2b5a6e477a61f575a0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000071">Deprecated:</a></b></dt><dd>Renamed to doNotBufferVertexBoneIndices. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_point_particle_mesh.html#aeabdeb14fe5a540d3628305289ca6392">CC3PointParticleMesh</a>.</p>

</div>
</div>
<a class="anchor" id="ad52db2e2d5c6d7237ab8affd6bc2a69a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addTextureCoordinates: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_vertex_texture_coordinates.html">CC3VertexTextureCoordinates</a> *)&#160;</td>
          <td class="paramname"><em>aTexCoord</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This class supports multi-texturing. </p>
<p>In most situations, the mesh will use the same texture mapping for all texture units. In such a case, the single texture coordinates array in the vertexTexureCoordinates property will be applied to all texture units.</p>
<p>However, if multi-texturing is used, and separate texture coordinate mapping is required for each texture unit, additional texture coordinate arrays can be added using this method.</p>
<p>If the vertexTextureCoordinates property has not been set already, the first texture coordinate array that is added via this method will be placed in the vertexTextureCoordinates property. This can simplify configurations in that all texture coordinate arrays can be treated the same.</p>
<p>If there are more textures applied to a node than there are texture coordinate arrays in the mesh (including the vertexTextureCoordinates and the those in the overlayTextureCoordinates collection), the last texture coordinate array is reused. </p>

</div>
</div>
<a class="anchor" id="ae9c31fa7e139566921be59f533f0dfd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) alignTextureUnit: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTexture:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *)&#160;</td>
          <td class="paramname"><em>aTexture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns the texture coordinates of the specified texture unit to the specified texture. </p>
<p>Under iOS, textures that do not have dimensions that are a power-of-two, will be padded to dimensions of a power-of-two on loading. The result is that the texture will be physically larger than is expected by these texture coordinates.</p>
<p>The usable area of the texture is indicated by its mapSize property, and invoking this method will align these texture coordinates with the usable size of the specified texture.</p>
<p>If the value of the expectsVerticallyFlippedTexture:InTextureUnit: property is different than the value of the isUpsideDown property of the specified texture, the texture coordinates are not oriented vertically for the texture. If so, this method also flips the texture coordinates to align with the texture.</p>
<p>This method is invoked automatically when a texture is assigned to cover this mesh in the mesh node. Normally, the application has no need to invoke this method directly. However, you can invoke this method manually if you have changed the texture coordinate alignment using the expectsVerticallyFlippedTexture:inTextureUnit: method.</p>
<p>To avoid updating the texture coordinates when no change has occurred, if the coordinates do not need to be flipped vertically, and the specified texture has the same usable area as the texture used on the previous invocation (or has a full usable area on the first invocation), this method does nothing.</p>
<p>If the number of texture coordinate arrays is less than the number of textures, the last texture coordinate array will be used by all remaining texture units. In this case, it will only be aligned for the texture in the same texture unit. Subsequent textures will use that same alignment.</p>
<p>Care should be taken when using this method, as it changes the actual vertex content. This may cause mapping conflicts if the same vertex content is shared by other CC3MeshNodes that use different textures. </p>

</div>
</div>
<a class="anchor" id="ac018f86eee6ea8a566883bd3384c8dd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) alignWithInvertedTexturesIn: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_material.html">CC3Material</a> *)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>The alignment performed by this method is now performed automatically whenever a texture or material is attached to the mesh node holding this mesh. Use the property-setting method expectsVerticallyFlippedTexture:inTextureUnit: to indicate whether the texture mesh is aligned with vertically-flipped textures prior to setting the texture or material into your mesh node. </dd></dl>

</div>
</div>
<a class="anchor" id="aa41d0da06fc63339b5267edc0dfe9846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) alignWithTexturesIn: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_material.html">CC3Material</a> *)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>The alignment performed by this method is now performed automatically whenever a texture or material is attached to the mesh node holding this mesh. Use the property-setting method expectsVerticallyFlippedTexture:inTextureUnit: to indicate whether the texture mesh is aligned with vertically-flipped textures prior to setting the texture or material into your mesh node. </dd></dl>

</div>
</div>
<a class="anchor" id="acc48788e518515bb85d9607546eee23b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLushort*) allocateIndexedTriangles: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>triangleCount</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000073">Deprecated:</a></b></dt><dd>Use allocatedVertexIndexCapacity = (triangleCount * 3) instead. </dd></dl>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#acc48788e518515bb85d9607546eee23b">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="ad828d0d73dd2aca5da2abab520ae6f40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_textured_vertex.html">CC3TexturedVertex</a>*) allocateTexturedVertices: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexCount</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000072">Deprecated:</a></b></dt><dd>Use the vertexContentTypes property, followed by the allocatedVertexCapacity property, instead. You can also use the prepareParametricMesh method to automatically established textured vertices if the vertexContentTypes property has not been set. </dd></dl>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#ad828d0d73dd2aca5da2abab520ae6f40">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="a4b60ba6fb792a8d414e4bc3c75c77e59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) bindWithVisitor: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the mesh data to the GL engine without drawing. </p>
<p>The specified visitor encapsulates the currently active camera, and certain drawing options.</p>
<p>If this mesh is different than the last mesh drawn, this method binds this mesh data to the GL engine. Otherwise, if this mesh is the same as the mesh already bound, it is not bound again.</p>
<p>Most drawing operations will use the drawWithVisitor: method instead of this method. This method can be used for those situations where the binding and drawing operations are manged separately, such as with vertex skinning. </p>

</div>
</div>
<a class="anchor" id="a46b5fda661ccbed22ffc50a18e1c2c41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyVertexAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>srcIdx</em></td>
        </tr>
        <tr>
          <td class="paramkey">from:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_mesh.html">CC3Mesh</a> *)&#160;</td>
          <td class="paramname"><em>srcMesh</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>dstIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the vertex content at the specified vertex index in the specified mesh to this mesh at the specified vertex index. </p>
<p>It is permissible for the two meshes to have different vertex content types. Only the vertex content applicable to this mesh will be copied over. If this mesh has vertex content that is not available in the source mesh, default content is applied to the vertex in this mesh. </p>

</div>
</div>
<a class="anchor" id="af1e0b37f47f8d3c553f8e8257043f265"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyVertexIndices: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">from:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>srcIdx</em></td>
        </tr>
        <tr>
          <td class="paramkey">inMesh:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_mesh.html">CC3Mesh</a> *)&#160;</td>
          <td class="paramname"><em>srcMesh</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>dstIdx</em></td>
        </tr>
        <tr>
          <td class="paramkey">offsettingBy:</td>
          <td></td>
          <td class="paramtype">(GLint)&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies vertex content for the specified number of vertices from memory starting at the specified source vertex index, in the specified source mesh, to memory starting at the specified destination vertex index in this mesh. </p>
<p>You can use this method to copy vertex indices from another mesh to this mesh, while adjusting for differences in where the vertex content lies in each mesh. This method compensates correctly if the vertex indices in the source mesh are of a different type (GL_UNSIGNED_BYTE or GL_UNSIGNED_SHORT) than the vertex indices of this mesh.</p>
<p>If this mesh has no vertex indices, this method does nothing. If the source mesh has no vertex indices, the specified offset is taken as the starting index of the vertex content in this mesh, and vertex indices are manufactured automatically to simply point directly to the corresponding vertex content, in a 1:1 relationship. </p>

</div>
</div>
<a class="anchor" id="a6bdf61ab2ca6faee09c30b72a7aaad6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyVertexIndices: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">from:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>srcIdx</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>dstIdx</em></td>
        </tr>
        <tr>
          <td class="paramkey">offsettingBy:</td>
          <td></td>
          <td class="paramtype">(GLint)&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies vertex indices for the specified number of vertices from memory starting at the specified source vertex index to memory starting at the specified destination vertex index, and offsets each value by the specified offset amount. </p>
<p>The value at the destination vertex will be that of the source vertex, plus the specified offset.</p>
<p>You can use this method to copy content from one area in the vertex indices array to another area, while adjusting for movement of the underlying vertex content pointed to by these vertex indices.</p>
<p>If this mesh has no vertex indices, this method does nothing. </p>

</div>
</div>
<a class="anchor" id="a7bd621575151edf636d0412fd73a68ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyVertices: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">from:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>srcIdx</em></td>
        </tr>
        <tr>
          <td class="paramkey">inMesh:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_mesh.html">CC3Mesh</a> *)&#160;</td>
          <td class="paramname"><em>srcMesh</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>dstIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies vertex content for the specified number of vertices from memory starting at the specified source vertex index, in the specified source mesh, to memory starting at the specified destination vertex index in this mesh. </p>
<p>You can use this method to copy data from another mesh to this mesh. </p>

</div>
</div>
<a class="anchor" id="a9471d2dafbd6ad9b5f86a1756b814dab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyVertices: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">from:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>srcIdx</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>dstIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies vertex content for the specified number of vertices from memory starting at the specified source vertex index to memory starting at the specified destination vertex index. </p>
<p>You can use this method to copy data from one area in the mesh to another. </p>

</div>
</div>
<a class="anchor" id="add9407049ba2360bd1e4fb7d71528f72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) createGLBuffers </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to create GL buffers for all vertex arrays used by this mesh. </p>
<p>This method may safely be called more than once, or on more than one mesh that shares vertex arrays, since vertex array GL buffers are only created if they don't already exist. </p>

</div>
</div>
<a class="anchor" id="a229ebe05173b24083df7670142329dc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) deleteGLBuffers </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to delete any GL buffers for all vertex arrays used by this mesh. </p>
<p>The arrays may continue to be used, and the arrays will be passed from the client during each draw instead of bound to the GL server as a vertex buffer.</p>
<p>This is a convenience method. Because vertex arrays may be shared between arrays, this method should likely be used when it is known that this mesh is the only user of the array, or to clear GL memory for any rarely used meshes. A more general design is to simply release the vertex array. The GL buffer will be deleted when the vertex array is deallocated.</p>
<p>This method may safely be called more than once, or on more than one mesh that shares vertex arrays, since vertex array GL buffers are only deleted if they exist. </p>

</div>
</div>
<a class="anchor" id="aaa5a60c9141db6300b8c133b7df6dc30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexBitangents </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bitangent content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex normals will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexBitangents method. </p>

</div>
</div>
<a class="anchor" id="ac72a75deb7faca166830b7e0fb10a860"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexBoneIndices </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bone index content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex bone index will not be buffered to a GL VBO. Any other vertex content, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexBoneIndices method. </p>

</div>
</div>
<a class="anchor" id="a1a47cdad8636977c4b17600d83385bca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexBoneWeights </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bone weight content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex bone weight will not be buffered to a GL VBO. Any other vertex content, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexBoneWeights method. </p>

</div>
</div>
<a class="anchor" id="abf52e2f315042f9d460fe498ce2e49ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexColors </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex color content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex colors will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexColors method. </p>

</div>
</div>
<a class="anchor" id="a0af7d45545ec9e0b0686529611c58b30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexContent </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause all vertex content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexContent method. </p>

</div>
</div>
<a class="anchor" id="ad90ec5e09f1e234180493efa7cffeba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexIndices </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex index content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex indices will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexColors method. </p>

</div>
</div>
<a class="anchor" id="af13c4436396a1f7665419abaa6e36d2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexLocations </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex location content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex locations will not be buffered to a GL VBO. Any other vertex data, such as normals, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexLocations method. </p>

</div>
</div>
<a class="anchor" id="af143643024e51626d7964ab32e42640b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexNormals </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex normal content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex normals will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexNormals method. </p>

</div>
</div>
<a class="anchor" id="a04965c5cafe44856da4aab445ea1b437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexPointSizes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex point size content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex point sizes will not be buffered to a GL VBO. Any other vertex content, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexPointSizes method. </p>

</div>
</div>
<a class="anchor" id="afebed80647564c5fcc6cb0fece391beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexTangents </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex tangent content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex normals will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexTangents method. </p>

</div>
</div>
<a class="anchor" id="acf2aac3eaa854c47447ffb2012b80343"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexTextureCoordinates </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex texture coordinate content for all texture units used by this mesh to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex texture coordinates will not be buffered to a GL VBO. Any other vertex content, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexTextureCoordinates method. </p>

</div>
</div>
<a class="anchor" id="ae88ac2a93a7d9d69744a3042062b85b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) drawFrom: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">forCount:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">withVisitor:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the mesh data to the GL engine, and draws a portion of the mesh data, starting at the vertex at the specified index, and drawing the specified number of vertices. </p>
<p>The specified visitor encapsulates the currently active camera, and certain drawing options.</p>
<p>If this mesh is different than the last mesh drawn, this method binds this mesh data to the GL engine by invoking the bindWithVisitor: method. Otherwise, if this mesh is the same as the mesh already bound, it is not bound again,</p>
<p>Once binding is complete, this method then performs the GL draw operations.</p>
<p>This is invoked automatically from the draw method of the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> instance that is using this mesh. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a5e6349c01b70f4a2bad6b542407e2ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) drawWithVisitor: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the mesh data to the GL engine and draws the mesh data. </p>
<p>The specified visitor encapsulates the currently active camera, and certain drawing options.</p>
<p>If this mesh is different than the last mesh drawn, this method binds this mesh data to the GL engine by invoking the bindWithVisitor: method. Otherwise, if this mesh is the same as the mesh already bound, it is not bound again,</p>
<p>Once binding is complete, this method then performs the GL draw operations.</p>
<p>This is invoked automatically from the draw method of the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> instance that is using this mesh. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a3dfa32a6d5e4f0fe53321cf808e100b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) ensureCapacity: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd>Renamed to ensureVertexCapacity. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1ca4d7682c16135cf0f58fb92dae2e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) ensureVertexCapacity: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if the previously-allocated, underlying vertex capacity is large enough to hold the specified number of vertices, and if not, expands the memory allocations accordingly. </p>
<p>If exansion is required, vertex capacity is expanded to hold the specified number of vertices, multiplied by the capacityExpansionFactor property, to provide a buffer for future requirements.</p>
<p>Returns whether the underlying vertex memory had to be expanded. The application can use this response value to determine whether or not to reset GL buffers, etc. </p>

</div>
</div>
<a class="anchor" id="a1fd98fc4ffd062e375c4e7d6f89b1ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) ensureVertexContent </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that this mesh has vertexContentType defined. </p>
<p>This method is invoked by each of the populateAs... family of methods, prior to populating the mesh contents.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking any of the populateAs... family of methods, to define the content type for each vertex.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate). and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If you do not need either of the normal or texture coordinates, set the vertexContentTypes property accordingly prior to invoking any of the populateAs... methods. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a1fd98fc4ffd062e375c4e7d6f89b1ffe">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="a54d4e3afa03babe33fad4922d8b4d484"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) expectsVerticallyFlippedTexture: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>expectsFlipped</em></td>
        </tr>
        <tr>
          <td class="paramkey">inTextureUnit:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the texture coordinates for the specified texture unit expects that the texture was flipped upside-down during texture loading. </p>
<p>See the notes of the expectsVerticallyFlippedTextureInTextureUnit: method for a discussion of texture coordinate orientation.</p>
<p>Setting the value of this property will change the way the texture coordinates are aligned when a texture is assigned to cover this texture unit for this mesh. </p>

</div>
</div>
<a class="anchor" id="abf19da7c2aa873c6398c96ce933eb543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) expectsVerticallyFlippedTextureInTextureUnit: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the texture coordinates for the specfied texture unit expects that the texture was flipped upside-down during texture loading. </p>
<p>The vertical axis of the coordinate system of OpenGL is inverted relative to the CoreGraphics view coordinate system. As a result, some texture file formats may be loaded upside down. Most common file formats, including JPG, PNG &amp; PVR are loaded right-way up, but using proprietary texture formats developed for other platforms may result in textures being loaded upside-down.</p>
<p>The value of this property is used in combination with the value of the isUpsideDown property of a texture to determine whether the texture will be oriented correctly when displayed using these texture coordinates.</p>
<p>The alignTextureUnit:withTexture: method compares the value of this property with the isUpsideDown property of the texture to automatically determine whether these texture coordinates need to be flipped vertically in order to display the texture correctly, and will do so if needed. As part of that inversion, the value of this property for the specified texture unit will also be flipped, to indicate that the texture coordinates are now aligned differently.</p>
<p>The alignTextureUnit:withTexture: method is invoked automatically when a texture is assigned to cover this mesh in the mesh node. If you need to adjust the value of this property, you sould do so before setting a texture or material into the mesh node.</p>
<p>The initial value of this property is set when the underlying mesh texture coordinates are built or loaded. See the expectsVerticallyFlippedTextures property on the <a class="el" href="interface_c_c3_nodes_resource.html" title="CC3NodesResource is a wrapper class around a resource structure loaded from a data file containing 3D...">CC3NodesResource</a> class to understand how this property is set during mesh resource loading.</p>
<p>When building meshes programmatically, you should endeavour to design the mesh so that this property will be YES if you will be using vertically-flipped textures (all texture file formats except PVR). </p>

</div>
</div>
<a class="anchor" id="ac4407d6e4d4f446e0c9f50556d5fcc80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_face.html">CC3Face</a>) faceAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>faceIndex</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the face from the mesh at the specified index. </p>
<p>The specified faceIndex value refers to the index of the face, not the vertices themselves. So, a value of 5 will retrieve the three vertices that make up the fifth triangular face in this mesh. The specified index must be between zero, inclusive, and the value of the faceCount property, exclusive.</p>
<p>The returned face structure contains only the locations of the vertices. If the vertex locations are interleaved with other vertex content, such as color or texture coordinates, or other padding, that data will not appear in the returned face structure. For that remaining vertex content, you can use the faceIndicesAt: method to retrieve the indices of the vertex content, and then use the vertex accessor methods to retrieve the individual vertex content components.</p>
<p>If you will be invoking this method frequently, you can optionally set the shouldCacheFaces property to YES to speed access, and possibly improve performance. However, be aware that setting the shouldCacheFaces property to YES can significantly increase the amount of memory used by the mesh. </p>

</div>
</div>
<a class="anchor" id="afaa0ff6380b79119cb88759091a4d18b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) faceCenterAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>faceIndex</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the center of the mesh face at the specified index. </p>
<p>If you will be invoking this method frequently, you can optionally set the shouldCacheFaces property to YES to speed access, and possibly improve performance. However, be aware that setting the shouldCacheFaces property to YES can significantly increase the amount of memory used by the mesh. </p>

</div>
</div>
<a class="anchor" id="a485dc052c49c39fe7ff132fd77bf2a92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) faceCountFromVertexCount: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>Renamed to faceCountFromVertexIndexCount:. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e78c71964d5098813400d6693a0e7ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) faceCountFromVertexIndexCount: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vc</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of faces to be drawn from the specified number of vertex indices, based on the type of primitives that this mesh is drawing. </p>

</div>
</div>
<a class="anchor" id="a59a129e5e04d1fe3c2888df7aa98e23c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_face.html">CC3Face</a>) faceFromIndices: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_face_indices.html">CC3FaceIndices</a>)&#160;</td>
          <td class="paramname"><em>faceIndices</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mesh face that is made up of the three vertices at the three indices within the specified face indices structure. </p>
<p>The returned face structure contains only the locations of the vertices. If the vertex locations are interleaved with other vertex content, such as color or texture coordinates, or other padding, that data will not appear in the returned face structure. For that remaining vertex content, you can use the faceIndicesAt: method to retrieve the indices of the vertex content, and then use the vertex accessor methods to retrieve the individual vertex content components. </p>

</div>
</div>
<a class="anchor" id="a1b5a1dc025773491c8ff8c5341148f6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_face_indices.html">CC3FaceIndices</a>) faceIndicesAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>faceIndex</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the face from the mesh at the specified index, as indices into the mesh vertices. </p>
<p>The specified faceIndex value refers to the index of the face, not the vertices themselves. So, a value of 5 will retrieve the three vertices that make up the fifth triangular face in this mesh. The specified index must be between zero, inclusive, and the value of the faceCount property, exclusive.</p>
<p>The returned structure reference contains the indices of the three vertices that make up the triangular face. These indices index into the actual vertex content within the layout of the mesh.</p>
<p>This method takes into consideration any padding (stride) between the vertex indices.</p>
<p>If you will be invoking this method frequently, you can optionally set the shouldCacheFaces property to YES to speed access, and possibly improve performance. However, be aware that setting the shouldCacheFaces property to YES can significantly increase the amount of memory used by the mesh. </p>

</div>
</div>
<a class="anchor" id="a94a31c487bf762d872d095a3e8d52bf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_face_neighbours.html">CC3FaceNeighbours</a>) faceNeighboursAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>faceIndex</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the indices of the neighbours of the mesh face at the specified index. </p>

</div>
</div>
<a class="anchor" id="a8fde3c7682514ff7aabc7497014d1f2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) faceNormalAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>faceIndex</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the normal of the mesh face at the specified index. </p>
<p>If you will be invoking this method frequently, you can optionally set the shouldCacheFaces property to YES to speed access, and possibly improve performance. However, be aware that setting the shouldCacheFaces property to YES can significantly increase the amount of memory used by the mesh. </p>

</div>
</div>
<a class="anchor" id="ab0a14b0cc30e32e31727641fff7b7a3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_plane.html">CC3Plane</a>) facePlaneAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>faceIndex</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the plane of the mesh face at the specified index. </p>
<p>If you will be invoking this method frequently, you can optionally set the shouldCacheFaces property to YES to speed access, and possibly improve performance. However, be aware that setting the shouldCacheFaces property to YES can significantly increase the amount of memory used by the mesh. </p>

</div>
</div>
<a class="anchor" id="a35dddc107949f65f7ffe4d898d217528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) findFirst: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>maxHitCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">intersections:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_mesh_intersection.html">CC3MeshIntersection</a> *)&#160;</td>
          <td class="paramname"><em>intersections</em></td>
        </tr>
        <tr>
          <td class="paramkey">ofLocalRay:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_ray.html">CC3Ray</a>)&#160;</td>
          <td class="paramname"><em>aRay</em></td>
        </tr>
        <tr>
          <td class="paramkey">acceptBackFaces:</td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>acceptBackFaces</em></td>
        </tr>
        <tr>
          <td class="paramkey">acceptBehindRay:</td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>acceptBehind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the specified array with information about the intersections of the specified ray and this mesh, up to the specified maximum number of intersections. </p>
<p>This method returns the actual number of intersections found (up to the specified maximum). This value indicates how many of the elements of the specifed intesections array were populated during the execution of this method. The contents of elements beyond that number are undefined.</p>
<p>Each of the populated elements of the intersections array contains information about the face on which the intersection occurred, the location of the intersection, and the distance from the ray startLocation where the intersection occurred. The location and distance components are specified in the local coordinates system of this mesh.</p>
<p>The intersections array is not sorted in any way. In particular, when the array contains multiple entries, the first element in the array does not necessily contain the closest intersection. If you need to determine the closest intersection, you can iterate the intersections array and compare the values of the location element of each intersection.</p>
<p>To use this method, allocate an array of <a class="el" href="struct_c_c3_mesh_intersection.html" title="Represents a point of intersection on the mesh. ">CC3MeshIntersection</a> structures, pass a reference to it in the intersections parameter, and indicate the size of that array in the maxHitCount parameter.</p>
<p>The method iterates through the faces in the mesh until the indicated number of intersections are found, or until all the faces in the mesh have been inspected. Therefore, to keep performance high, you should set the maxHitCount parameter no higher than the number of intersections that are useful to you. For example, specifiying a value of one for the maxHitCount parameter will cause this method to return as soon as the first intersection is found. In most cases, this is all that is needed.</p>
<p>The allowBackFaces parameter is used to indicate whether to include intersections where the ray pierces a face from its back face. Typically, this means that the ray has intersected the face as the ray exits on the far side of the mesh. In most cases you will interested only where the ray intersects the near side of the mesh, in which case you can set this parameter to NO.</p>
<p>The allowBehind parameter is used to indicate whether to include intersections that occur behind the startLocation of the ray, in the direction opposite to the direction of the ray. Typically, this might mean the mesh is located behind the ray startLocation, or it might mean the ray starts inside the mesh. Again,in most cases, you will be interested only in intersections that occur in the direction the ray is pointing, and can ususally set this parameter to NO. </p>

</div>
</div>
<a class="anchor" id="abfb6b53816984679eba96a80abac7e55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) flipHorizontallyTextureUnit: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that flips the texture coordinate mapping horizontally for the specified texture channels. </p>
<p>This has the effect of flipping the texture for that texture channel horizontally on the model. and can be useful for creating interesting effects, or mirror images.</p>
<p>This implementation flips correctly if the mesh is mapped to only a section of the texture (a texture atlas). </p>

</div>
</div>
<a class="anchor" id="a5f8d6c1777c085f61249e28083c8a5c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) flipNormals </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the direction of all of the normals in this mesh. </p>

</div>
</div>
<a class="anchor" id="a2a19bb219d6559b58d1b31a179d44c98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) flipTexturesHorizontally </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that flips the texture coordinate mapping horizontally for all texture units. </p>
<p>This has the effect of flipping the textures horizontally on the model. and can be useful for creating interesting effects, or mirror images.</p>
<p>This implementation flips correctly if the mesh is mapped to only a section of the texture (a texture atlas).</p>
<p>This has the same effect as invoking the flipHorizontallyTextureUnit: method for all texture units. </p>

</div>
</div>
<a class="anchor" id="a7f38fa308e856531720632778d9528f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) flipTexturesVertically </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that flips the texture coordinate mapping vertically for all texture units. </p>
<p>This has the effect of flipping the textures vertically on the model. and can be useful for creating interesting effects, or mirror images.</p>
<p>This implementation flips correctly if the mesh is mapped to only a section of the texture (a texture atlas).</p>
<p>This has the same effect as invoking the flipVerticallyTextureUnit: method for all texture units. </p>

</div>
</div>
<a class="anchor" id="a3fd29948a5051b553ff3dbea90907b80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) flipVerticallyTextureUnit: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that flips the texture coordinate mapping vertically for the specified texture channels. </p>
<p>This has the effect of flipping the texture for that texture channel vertically on the model. and can be useful for creating interesting effects, or mirror images.</p>
<p>This implementation flips correctly if the mesh is mapped to only a section of the texture (a texture atlas). </p>

</div>
</div>
<a class="anchor" id="a062074189efa26646f47a67e458acdfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_texture_coordinates.html">CC3VertexTextureCoordinates</a>*) getTextureCoordinatesNamed: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aName</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the overlay texture coordinate array with the specified name, or nil if it cannot be found. </p>
<p>This checks both the vertexTextureCoordinates property and the overlayTextureCoordinates collection. </p>

</div>
</div>
<a class="anchor" id="aba5a511998a9ba82ac2d0e886d01b6b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) mesh </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased unnamed instance with an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="ac1ea242a3cef763c53dc9d2e4e9f67e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) meshAtIndex: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"><em>aPODIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromPODResource:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_p_o_d_resource.html">CC3PODResource</a> *)&#160;</td>
          <td class="paramname"><em>aPODRez</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased instance from the data of this type at the specified index within the specified POD resource. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_p_v_r_p_o_d_08.html#ac1ea242a3cef763c53dc9d2e4e9f67e6">CC3Mesh(PVRPOD)</a>.</p>

</div>
</div>
<a class="anchor" id="a8bdc6046a3a3702348138f0ed58565f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) meshWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aName</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified name and an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="a2f7917909ad2887d109ef4ba508a87d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) meshWithTag: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>aTag</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an unnamed autoreleased instance with the specified tag. </p>

</div>
</div>
<a class="anchor" id="ab5202c876913aa8043e226ea32df8ec2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) <a class="el" href="interface_c_c3_mesh.html#a2f7917909ad2887d109ef4ba508a87d9">meshWithTag:</a> </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>aTag</em></td>
        </tr>
        <tr>
          <td class="paramkey">withName:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified tag and name. </p>

</div>
</div>
<a class="anchor" id="a195cd5c55b0beb7aa5ed74be08c27d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) moveMeshOriginTo: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>aLocation</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the mesh vertices so that the origin of the mesh is at the specified location. </p>
<p>The origin of the mesh is the location (0,0,0) in the local coordinate system, and is the location around which all transforms are performed.</p>
<p>This method can be used to adjust the mesh structure to make it easier to apply transformations, by moving the origin of the transformations to a more convenient location in the mesh.</p>
<p>This method changes the location component of every vertex in the mesh. This can be quite costly, and should only be performed once, to adjust a mesh so that it is easier to manipulate. As an alternate, you should consider changing the origin of the mesh at development time using a 3D editor.</p>
<p>Do not use this method to move your model around. Instead, use the transform properties (location, rotation and scale) of the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> that contains this mesh, and let the GL engine do the heavy lifting of transforming the mesh vertices.</p>
<p>If this mesh is being used by any mesh nodes, be sure to invoke the markBoundingVolumeDirty method on all nodes that use this mesh, to ensure that the boundingVolume is recalculated using the new location values. Invoking this method on the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> instead will automatically invoke the markBoundingVolumeDirty method.</p>
<p>This method ensures that the GL VBO that holds the vertex content is updated. </p>

</div>
</div>
<a class="anchor" id="a3fae78d622549776f43e7d228382962d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) moveMeshOriginToCenterOfGeometry </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the mesh vertices so that the origin of the mesh is at the center of geometry of the mesh. </p>
<p>The origin of the mesh is the location (0,0,0) in the local coordinate system, and is the location around which all transforms are performed.</p>
<p>This method can be used to adjust the mesh structure to make it easier to apply transformations, by moving the origin of the transformations to the center of the mesh.</p>
<p>This method changes the location component of every vertex in the mesh. This can be quite costly, and should only be performed once, to adjust a mesh so that it is easier to manipulate. As an alternate, you should consider changing the origin of the mesh at development time using a 3D editor.</p>
<p>Do not use this method to move your model around. Instead, use the transform properties (location, rotation and scale) of the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> that contains this mesh, and let the GL engine do the heavy lifting of transforming the mesh vertices.</p>
<p>If this mesh is being used by any mesh nodes, be sure to invoke the markBoundingVolumeDirty method on all nodes that use this mesh, to ensure that the boundingVolume is recalculated using the new location values. Invoking this method on the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> instead will automatically invoke the markBoundingVolumeDirty method.</p>
<p>This method ensures that the GL VBO that holds the vertex content is updated. </p>

</div>
</div>
<a class="anchor" id="a3dde07fc6ec999f61c20f1cbf71e6f2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) movePivotTo: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000047">Deprecated:</a></b></dt><dd>Renamed to moveMeshOriginTo:. </dd></dl>

</div>
</div>
<a class="anchor" id="a95332ae63912bd91b2731d10dd1c693f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsBitmapFontLabelFromString: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>lblString</em></td>
        </tr>
        <tr>
          <td class="paramkey">andFont:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_bitmap_font_configuration.html">CC3BitmapFontConfiguration</a> *)&#160;</td>
          <td class="paramname"><em>fontConfig</em></td>
        </tr>
        <tr>
          <td class="paramkey">andLineHeight:</td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>lineHeight</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTextAlignment:</td>
          <td></td>
          <td class="paramtype">(NSTextAlignment)&#160;</td>
          <td class="paramname"><em>textAlignment</em></td>
        </tr>
        <tr>
          <td class="paramkey">andRelativeOrigin:</td>
          <td></td>
          <td class="paramtype">(CGPoint)&#160;</td>
          <td class="paramname"><em>origin</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_foundation_8h.html#a1755badfebb13f118a6acef2c3e2543b">CC3Tessellation</a>)&#160;</td>
          <td class="paramname"><em>divsPerChar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a rectangular mesh displaying the text of the specified string, built from bitmap character images taken from a texture atlas as defined by the specified bitmapped font configuration. </p>
<p>The texture that matches the specified font configuration (and identified in the font configuration), should be loaded and assigned to the texture property of the mesh node that uses this mesh.</p>
<p>The text may be multi-line, and can be left-, center- or right-aligned, as specified.</p>
<p>The specified lineHeight define the height of a line of text in the coordinate system of this mesh. This parameter can be set to zero to use the natural line height of the font.</p>
<p>For example, a font with font size of 16 might have a natural line height of 19. Setting the lineHeight parameter to zero would result in a mesh where a line of text would be 19 units high. On the other hand, setting this property to 0.2 will result in a mesh where the same line of text has a height of 0.2 units. Depending on the size of other models in your scene, you may want to set this lineHeight to something compatible. In addition, the visual size of the text will also be affected by the value of the scale or uniformScale properties of any mesh node using this mesh. Both the lineHeight and the node scale work to establish the visual size of the label text.</p>
<p>For a more granular mesh, each character rectangle can be divided into many smaller divisions. Building a rectanglular surface from more than one division can dramatically improve realism when the surface is illuminated with specular lighting or a tightly focused spotlight, or if the mesh is to be deformed in some way by a later process (such as wrapping the text texture around some other shape).</p>
<p>The divsPerChar argument indicates how to break each character rectangle into multiple faces. The X &amp; Y elements of the divsPerChar argument indicate how each axis if the rectangle for each character should be divided into faces. The number of faces in the rectangle for each character will therefore be the multiplicative product of the X &amp; Y elements of the divsPerChar argument.</p>
<p>For example, a value of {3,2} for the divsPerChar argument will result in each character being divided into 6 smaller rectangular faces, arranged into a 3x2 grid.</p>
<p>The relative origin defines the location of the origin for texture alignment, and is specified as a fraction of the size of the overall label layout, starting from the bottom-left corner.</p>
<p>For example, origin values of (0, 0), (0.5, 0.5), and (1, 1) indicate that the label mesh should be aligned so that the bottom-left corner, center, or top-right corner, respectively, should be located at the local origin of the corresponding mesh.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>This method may be invoked repeatedly to change the label string. The mesh will automomatically be rebuilt to the correct number of vertices required to display the currently specified string. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_bitmap_label_08.html#a95332ae63912bd91b2731d10dd1c693f">CC3Mesh(BitmapLabel)</a>.</p>

</div>
</div>
<a class="anchor" id="a98bd5a646995672c1fe27a5b0c54df1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsCenteredRectangleWithSize: </td>
          <td></td>
          <td class="paramtype">(CGSize)&#160;</td>
          <td class="paramname"><em>rectSize</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, centered at the origin, and laid out on the X-Y plane. </p>
<p>The rectangular mesh contains only one face with two triangles. The result is the same as invoking populateAsCenteredRectangleWithSize:andTessellation: with the divsPerAxis argument set to {1,1}.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a98bd5a646995672c1fe27a5b0c54df1d">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="ac516a0e20127107db00247a6eb37b06e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a98bd5a646995672c1fe27a5b0c54df1d">populateAsCenteredRectangleWithSize:</a> </td>
          <td></td>
          <td class="paramtype">(CGSize)&#160;</td>
          <td class="paramname"><em>rectSize</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_foundation_8h.html#a1755badfebb13f118a6acef2c3e2543b">CC3Tessellation</a>)&#160;</td>
          <td class="paramname"><em>divsPerAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, centered at the origin, and laid out on the X-Y plane. </p>
<p>The large rectangle can be divided into many smaller divisions. Building a rectanglular surface from more than one division can dramatically improve realism when the surface is illuminated with specular lighting or a tightly focused spotlight, because increasing the face count increases the number of vertices that interact with the specular or spot lighting.</p>
<p>The divsPerAxis argument indicates how to break this large rectangle into multiple faces. The X &amp; Y elements of the divsPerAxis argument indicate how each axis if the rectangle should be divided into faces. The total number of faces in the rectangle will therefore be the multiplicative product of the X &amp; Y elements of the divsPerAxis argument.</p>
<p>For example, a value of {5,5} for the divsPerAxis argument will result in the rectangle being divided into 25 faces, arranged into a 5x5 grid.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#ac516a0e20127107db00247a6eb37b06e">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="a87a12aee31ef691ea699cb7565c8dcb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsCubeMappedSolidBox: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_box.html">CC3Box</a>)&#160;</td>
          <td class="paramname"><em>box</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular box mesh from the specified bounding box, which contains two of the diagonal corners of the box. </p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If a texture is to be wrapped around this mesh, since the single texture is wrapped around all six sides of the box, the texture will be mapped according to the layout illustrated in the texture file BoxTexture.png, included in the distribution.</p>
<p>The "front" of the box is the side that faces towards the positive-Z axis, the "top" of the box is the side that faces towards the positive-Y axis, and the "right" side of the box is the side that faces towards the positive-X axis.</p>
<p>For the purposes of wrapping the texture around the box, this method assumes that the texture is an unfolded cube. The box can be created with any relative dimensions, but if it is not a cube, the texture may appear stretched or shrunk on two or more sides. The texture will still fully wrap all six sides of the box, but the texture is stretched or shrunk to fit each side according to its dimension relative to the other sides. The appearance will be as if you had started with a textured cube and then pulled one or two of the dimensions out further.</p>
<p>For higher fidelity in applying textures to non-cube boxes, so that the texture will not be stretched to fit, use either of the populateAsSolidBox: or populateAsSolidBox:withCorner: methods, with a texture whose layout is compatible with the aspect ratio of the box.</p>
<p>Thanks to Cocos3D user andyman for contributing the prototype code and texture template file for this method. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a87a12aee31ef691ea699cb7565c8dcb9">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="a276591a31024060be5166bb48dd98307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsDiskWithRadius: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>radius</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_foundation_8h.html#a1755badfebb13f118a6acef2c3e2543b">CC3Tessellation</a>)&#160;</td>
          <td class="paramname"><em>radialAndAngleDivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a flat, single-sided circular disk mesh of the specified radius, centered at the origin, and laid out on the X-Y plane. </p>
<p>The surface of the disk is divided into many smaller divisions, both in the radial and angular dimensions.</p>
<p>The radialAndAngleDivs argument indicates how to divide the surface of the disks into divisions. The X element of the radialAndAngleDivs argument indicates how many radial divisions will occur from the center and the circuferential edge. A value of one means that the mesh will consist of a series of radial triangles from the center of the circle to the edge. A larger value for the X element of the radialAndAngleDivs argument will structure the mesh as a series of concentric rings. This value must be at least one.</p>
<p>The Y element of the radialAndAngleDivs argument indicates how many angular divisions will occur around the circumference. This value must be at least three, which will essentially render the circle as a triangle. But, typically, this value will be larger.</p>
<p>For example, a value of {4,24} for the radialAndAngleDivs argument will result in the disk being divided into four concentric rings, each divided into 24 segments around the circumference of the circle.</p>
<p>Each segement, except those in the innermost disk is trapezoidal, and will be constructed from two triangular mesh faces. Therefore, the number of triangles in the mesh will be (2X - 1) * Y, where X = radialAndAngleDivs.x and Y = radialAndAngleDivs.y.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The texture is mapped to the tessellated disk as if a tagential square was overlaid over the circle, starting from the lower left corner, where both X and Y are at a minimum. The center of the disk maps to the center of the texture.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a276591a31024060be5166bb48dd98307">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="aaa647f1105acb757f3c30de865559f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsHollowConeWithRadius: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>radius</em></td>
        </tr>
        <tr>
          <td class="paramkey">height:</td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>height</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_foundation_8h.html#a1755badfebb13f118a6acef2c3e2543b">CC3Tessellation</a>)&#160;</td>
          <td class="paramname"><em>angleAndHeightDivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a conical mesh of the specified radius and height. </p>
<p>The mesh is constructed so that the base of the cone is centered on the origin of the X-Z plane, and the apex is on the positive Y-axis at the specified height. The cone is open and does not have a bottom.</p>
<p>The surface of the cone is divided into many smaller divisions, as specified by the angleAndHeightsDivs parameter. The X-coordinate of this parameter indicates how many angular divisions are created around the circumference of the base, and the Y-coordinate of this parameter indicates how many vertical divisions are created between the base and the apex.</p>
<p>For example, a value of {12,8} for the angleAndHeightsDivs parameter will result in a cone with 12 divisions around the circumference of the base, and 8 divisions along the Y-axis to the apex.</p>
<p>By reducing the number of angular divisions to 3 or 4, you can use this method to create a tetrahedron or square pyramid, respectively.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate). and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If a texture is applied to this mesh, it is mapped to the cone with a simple horizontal projection. Horizontal lines in the texture will remain parallel, but vertical lines will converge at the apex. Texture wrapping begins at the negative Z-axis, so the center of the texture will be positioned at the point where the cone intersects the positive Z-axis, and the conceptual seam (where the left and right edges of the texture are stitched together) will occur where the cone intersects the negative-Z axis. This texture orientation means that the center of the texture will face the forwardDirection of the cone node. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#aaa647f1105acb757f3c30de865559f67">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="acc5aab8b6ab6777b50c564816d14d86a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsLineStripWith: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">vertices:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> *)&#160;</td>
          <td class="paramname"><em>vertices</em></td>
        </tr>
        <tr>
          <td class="paramkey">andRetain:</td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>shouldRetainVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a line strip with the specified number of vertex points. </p>
<p>The data for the points that define the end-points of the lines are contained within the specified vertices array. The vertices array must contain at least vertexCount elements.</p>
<p>The lines are specified and rendered as a strip, where each line is connected to the previous and following lines. Each line starts at the point where the previous line ended, and that point is defined only once in the vertices array. Therefore, the number of lines drawn is equal to one less than the specified vertexCount.</p>
<p>The shouldRetainVertices flag indicates whether the data in the vertices array should be retained by this instance. If this flag is set to YES, the data in the vertices array will be copied to an internal array that is managed by this instance. If this flag is set to NO, the data is not copied internally and, instead, a reference to the vertices data is established. In this case, it is up to you to manage the lifespan of the data contained in the vertices array.</p>
<p>If you are defining the vertices data dynamically in another method, you may want to set this flag to YES to have this instance copy and manage the data. If the vertices array is a static array, you can set this flag to NO.</p>
<p>This is a convenience method for creating a simple, but useful, shape. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#acc5aab8b6ab6777b50c564816d14d86a">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="a8cb889980907f2a86b8e6557807c73cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsRectangleWithSize: </td>
          <td></td>
          <td class="paramtype">(CGSize)&#160;</td>
          <td class="paramname"><em>rectSize</em></td>
        </tr>
        <tr>
          <td class="paramkey">andRelativeOrigin:</td>
          <td></td>
          <td class="paramtype">(CGPoint)&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, with the specified relative origin, and laid out on the X-Y plane. </p>
<p>The rectangular mesh contains only one face with two triangles. The result is the same as invoking the populateAsRectangleWithSize:andRelativeOrigin:andTessellation: with the divsPerAxis argument set to {1,1}.</p>
<p>The relative origin is a fractional point that is relative to the rectangle's extent, and indicates where the origin of the rectangular mesh is to be located. The mesh origin is the origin of the local coordinate system of the mesh, and is the basis for all transforms applied to the mesh (including the location and rotation properties).</p>
<p>The specified relative origin should be a fractional value. If it is {0, 0}, the rectangle will be laid out so that the bottom-left corner is at the origin. If it is {1, 1}, the rectangle will be laid out so that the top-right corner of the rectangle is at the origin. If it is {0.5, 0.5}, the rectangle will be laid out with the origin at the center, as in the populateAsCenteredRectangleWithSize: method.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a8cb889980907f2a86b8e6557807c73cd">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="a8619cf9746d7b4b8f39d11952720773f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsRectangleWithSize: </td>
          <td></td>
          <td class="paramtype">(CGSize)&#160;</td>
          <td class="paramname"><em>rectSize</em></td>
        </tr>
        <tr>
          <td class="paramkey">andRelativeOrigin:</td>
          <td></td>
          <td class="paramtype">(CGPoint)&#160;</td>
          <td class="paramname"><em>origin</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_foundation_8h.html#a1755badfebb13f118a6acef2c3e2543b">CC3Tessellation</a>)&#160;</td>
          <td class="paramname"><em>divsPerAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, with the specified relative origin, and laid out on the X-Y plane. </p>
<p>The large rectangle can be divided into many smaller divisions. Building a rectanglular surface from more than one division can dramatically improve realism when the surface is illuminated with specular lighting or a tightly focused spotlight, because increasing the face count increases the number of vertices that interact with the specular or spot lighting.</p>
<p>The divsPerAxis argument indicates how to break this large rectangle into multiple faces. The X &amp; Y elements of the divsPerAxis argument indicate how each axis if the rectangle should be divided into faces. The total number of faces in the rectangle will therefore be the multiplicative product of the X &amp; Y elements of the divsPerAxis argument.</p>
<p>For example, a value of {5,5} for the divsPerAxis argument will result in the rectangle being divided into 25 faces, arranged into a 5x5 grid.</p>
<p>The relative origin is a fractional point that is relative to the rectangle's extent, and indicates where the origin of the rectangular mesh is to be located. The mesh origin is the origin of the local coordinate system of the mesh, and is the basis for all transforms applied to the mesh (including the location and rotation properties).</p>
<p>The specified relative origin should be a fractional value. If it is {0, 0}, the rectangle will be laid out so that the bottom-left corner is at the origin. If it is {1, 1}, the rectangle will be laid out so that the top-right corner of the rectangle is at the origin. If it is {0.5, 0.5}, the rectangle will be laid out with the origin at the center, as in the populateAsCenteredRectangleWithSize: method.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a8619cf9746d7b4b8f39d11952720773f">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="ae3839f11d94d436961ae959bbaed4e89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsSolidBox: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_box.html">CC3Box</a>)&#160;</td>
          <td class="paramname"><em>box</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular box mesh from the specified bounding box, which contains two of the diagonal corners of the box. </p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If a texture is to be wrapped around this mesh, since the single texture is wrapped around all six sides of the box, the texture will be mapped according to the layout illustrated in the texture file BoxTexture.png, included in the distribution.</p>
<p>The "front" of the box is the side that faces towards the positive-Z axis, the "top" of the box is the side that faces towards the positive-Y axis, and the "right" side of the box is the side that faces towards the positive-X axis.</p>
<p>For the purposes of wrapping a texture around the box, the texture will wrap uniformly around all sides, and the texture will not appear stretched between any two adjacent sides. This is useful when you are texturing the box with a simple rectangular repeating pattern and want the texture to appear consistent across the sides, for example, a brick pattern wrapping around all four sides of a house.</p>
<p>Depending on the relative aspect of the height and width of the box, the texture may appear distorted horizontal or vertically. If you need to correct that, you can use the repeatTexture: method, and adjust one of the dimensions.</p>
<p>For higher fidelity in applying textures to non-cube boxes, so that the texture will not be stretched to fit, use the populateAsSolidBox:withCorner: method.</p>
<p>Thanks to Cocos3D user andyman for contributing the prototype code and texture template file for this method. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#ae3839f11d94d436961ae959bbaed4e89">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="abcb56e8d12756fa43e6e59b8d12092d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#ae3839f11d94d436961ae959bbaed4e89">populateAsSolidBox:</a> </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_box.html">CC3Box</a>)&#160;</td>
          <td class="paramname"><em>box</em></td>
        </tr>
        <tr>
          <td class="paramkey">withCorner:</td>
          <td></td>
          <td class="paramtype">(CGPoint)&#160;</td>
          <td class="paramname"><em>corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular box mesh from the specified bounding box, which contains two of the diagonal corners of the box, and configures the mesh texture coordinates so that the entire box can be wrapped in a single texture. </p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If a texture is to be wrapped around this mesh, since the single texture is wrapped around all six sides of the box, the texture will be mapped according to the layout illustrated in the texture file BoxTexture.png, included in the distribution.</p>
<p>The "front" of the box is the side that faces towards the positive-Z axis, the "top" of the box is the side that faces towards the positive-Y axis, and the "right" side of the box is the side that faces towards the positive-X axis.</p>
<p>For the purposes of wrapping the texture around the box, the corner argument specifies the relative point in the texture that will map to the corner of the box that is at the juncture of the "left", "front" and "bottom" sides (see the BoxTexture.png image for a better understanding of this point). The corner argument is specified as a fraction in each of the S &amp; T dimensions of the texture. In the CGPoint that specifies the corner, the x &amp; y elements of the CGPoint correspond to the S &amp; T dimensions of this left-front-bottom corner mapping, with each value being between zero and one.</p>
<p>Since, by definition, opposite sides of the box have the same dimensions, this single corner point identifies the S &amp; T dimensions of all six of the sides of the box. A value of (1/4, 1/3) for the corner is used when the box is a cube. A smaller value for the x-element would move the corner to the left in the texture layout, indicating that the left and right sides are shallower than they are in a cube, and that the front and back are wider than in a cube, and vice-versa for a larger value in the x-element of the corner. Similarly for the y-element. A y-element that is smaller than 1/3, moves the corner point downwards on the texture, indicating that the bottom and top are shallower than they are in a cube, or that the front and back are higher than they are in a cube.</p>
<p>The two axes defined by the corner are interrelated, because the sides need to be the same depth as the top and bottom. The best way to determine the values to use in the corner is to use the measure of this point (where the "left", "front", and "bottom" sides meet) from the layout of the texture. If the aspect of the corner on the texture does not align with the aspect of the width, height and depth of the box, the texture will appear stretched on one or two sides relative to the others.</p>
<p>Thanks to Cocos3D user andyman for contributing the prototype code and texture template file for this method. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#abcb56e8d12756fa43e6e59b8d12092d6">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="af7733df5e671cae7d60369862c79b86d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsSphereWithRadius: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>radius</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_foundation_8h.html#a1755badfebb13f118a6acef2c3e2543b">CC3Tessellation</a>)&#160;</td>
          <td class="paramname"><em>divsPerAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a spherical mesh of the specified radius, centered at the origin. </p>
<p>The surface of the sphere is divided into many smaller divisions, similar to latitude and longtitude divisions. The sphere mesh contains two poles, where the surface intersects the positive and negative Y-axis.</p>
<p>The divsPerAxis argument indicates how to divide the surface of the sphere into divisions. The X element of the divsPerAxis argument indicates how many longtitude divisions will occur around one circumnavigation of the equator. The Y element of the divsPerAxis argument indicates how many latitude divisions will occur between the north pole and the south pole.</p>
<p>For example, a value of {12,8} for the divsPerAxis argument will result in the sphere being divided into twelve divisions of longtitude around the equator, and eight divisions of latitude between the north and south poles.</p>
<p>Except at the poles, each division is roughly trapezoidal and is drawn as two triangles. At the poles, each division is a single triangle.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate). and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If a texture is applied to this mesh, it is mapped to the sphere with a simple cylindrical projection around the equator (similar to Mercator projection without the north-south stretching). This type of projection is typical of maps of the earth taken from space, and results in the smooth curving of any texture around the sphere from the equator to the poles. Texture wrapping begins at the negative Z-axis, so the center of the texture will be positioned at the point where the sphere intersects the positive Z-axis, and the conceptual seam (where the left and right edges of the texture are stitched together) will occur where the sphere intersects the plane (X = 0) along the negative-Z axis. This texture orientation means that the center of the texture will face the forwardDirection of the sphere node. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#af7733df5e671cae7d60369862c79b86d">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="aadca0656abb5e235ba0eb2e2727e12de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsTriangle: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_face.html">CC3Face</a>)&#160;</td>
          <td class="paramname"><em>face</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTexCoords:</td>
          <td></td>
          <td class="paramtype">(ccTex2F *)&#160;</td>
          <td class="paramname"><em>texCoords</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>divsPerSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple triangular mesh. </p>
<p>The specified face defines the three vertices at the corners of the triangular mesh in 3D space. The vertices within the <a class="el" href="struct_c_c3_face.html" title="Defines a triangular face of the mesh, comprised of three vertices, stored in winding order...">CC3Face</a> structure are specified in the winding order of the triangular face. The winding order of the specified face determines the winding order of the vertices in the mesh, and the direction of the normal vector applied to each of the vertices. Since the resulting triangular mesh is flat, all vertices will have the same normal vector.</p>
<p>Although the triangle can be created with the corners can be anywhere in 3D space, for simplicity of construction, it is common practice, when using this method, to specify the mesh in the X-Y plane (where all three corners have a zero Z-component), and then rotate the node containing this mesh to an orientation in 3D space.</p>
<p>The texCoords parameter is an array of ccTex2F structures, providing the texture coordinates for the cooresponding vertices of the face. This array must have three elements, one for each vertex in the specified face. If the mesh will not be covered with a texture, you can pass in any values in the elements of this array.</p>
<p>The tessellation property determines how the mesh will be tessellated into smaller faces. The specified tessellation value indicates how many divisions each side of the main triangle should be divided into. Each side of the triangular mesh is tessellated into the same number of divisions.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#aadca0656abb5e235ba0eb2e2727e12de">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="a8f12125bc3e8bddf96dd852e46588abe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsWireBox: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_box.html">CC3Box</a>)&#160;</td>
          <td class="paramname"><em>box</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a wire-frame box with the specified dimensions. </p>
<p>This is a convenience method for creating a simple, but useful, shape. </p>

<p>Provided by category <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a8f12125bc3e8bddf96dd852e46588abe">CC3Mesh(ParametricShapes)</a>.</p>

</div>
</div>
<a class="anchor" id="a953388a5a8fa3acb287690e968fcf79f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) releaseRedundantContent </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Once the vertex content has been buffered into a GL vertex buffer object (VBO) within the GL engine, via the createGLBuffer method, this method can be used to release the data in main memory that is now redundant. </p>
<p>Typically, this method is not invoked directly by the application. Instead, consider using the same method on a node assembly in order to release as much memory as possible in one simply method invocation. </p>

</div>
</div>
<a class="anchor" id="a785f176851843f39be841484ec169846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeAllTextureCoordinates </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all texture coordinates arrays from the the vertexTextureCoordinates property and from the overlayTextureCoordinates collection. </p>

</div>
</div>
<a class="anchor" id="a16c180e5e4c35a2eae2ee0bffe1a496e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeTextureCoordinates: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_vertex_texture_coordinates.html">CC3VertexTextureCoordinates</a> *)&#160;</td>
          <td class="paramname"><em>aTexCoord</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified texture coordinate array from either the vertexTextureCoordinates property or from the overlayTextureCoordinates collection. </p>

</div>
</div>
<a class="anchor" id="aa256b77a007dc390ca8b4af81bf329ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) repeatTexture: </td>
          <td></td>
          <td class="paramtype">(ccTex2F)&#160;</td>
          <td class="paramname"><em>repeatFactor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the mesh so that the textures in all texture units will be repeated the specified number of times across the mesh, in each dimension. </p>
<p>The repeatFactor argument contains two numbers, corresponding to how many times in each dimension the texture should be repeated.</p>
<p>This has the same effect as invoking the repeatTexture:forTextureUnit: method for each texture unit. </p>

</div>
</div>
<a class="anchor" id="afcb0407a4f49543196cdd61c851830ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="interface_c_c3_mesh.html#aa256b77a007dc390ca8b4af81bf329ab">repeatTexture:</a> </td>
          <td></td>
          <td class="paramtype">(ccTex2F)&#160;</td>
          <td class="paramname"><em>repeatFactor</em></td>
        </tr>
        <tr>
          <td class="paramkey">forTextureUnit:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the mesh so that a texture applied to the specified texture unit will be repeated the specified number of times across the mesh, in each dimension. </p>
<p>The repeatFactor argument contains two numbers, corresponding to how many times in each dimension the texture should be repeated.</p>
<p>As an example, a value of (1, 2) for the repeatValue indicates that the texture should repeat twice vertically, but not repeat horizontally.</p>
<p>When a texture is repeated, the corresponding side of the texture covering this mesh must have a length that is a power-of-two, otherwise the padding added by iOS to convert it to a power-of-two length internally will be visible in the repeating pattern across the mesh.</p>
<p>For a side that is not repeating, the corresponding side of the texture covering this mesh does not require a length that is a power-of-two.</p>
<p>The textureParameters property of any texture covering this mesh should include the GL_REPEAT setting in each of its texture wrap components that correspond to a repeatFactor greater than one. The GL_REPEAT setting is the default setting for <a class="el" href="interface_c_c3_texture.html" title="The root class of a class cluster representing textures. ">CC3Texture</a>.</p>
<p>For example, if you want to repeat your texture twice in one dimension, but only once in the other, then you would use a repeatFactor of (1, 2) or (2, 1). For the side that is repeating twice, the length of that side of the texture must be a power-of-two. But the other side may have any dimension. The textureParameters property of the <a class="el" href="interface_c_c3_texture.html" title="The root class of a class cluster representing textures. ">CC3Texture</a> should include the GL_REPEAT setting for the corresponding texture dimension.</p>
<p>You can specify a fractional value for either of the components of the repeatFactor to expand the texture in that dimension so that only part of the texture appears in that dimension, while potentially repeating multiple times in the other dimension. </p>

</div>
</div>
<a class="anchor" id="a63fd302dcc2569352cbf14f711b03729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexBitangents </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bitangent content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex tangents will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="ab092d3925c9c04de3094633825ea7449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexBoneIndices </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bone index content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex bone indices will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a5690999af1e8a0dd7503d3e1283081b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexBoneWeights </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bone weight content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex bone weights will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a4d4e4f796b40b81f5041c7db69692de5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexColors </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex color content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex colors will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="ad88e7d3a41bd79af9d1dad898f417809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexContent </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause all vertex content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>All vertex content, such as location, normal, color, texture coordinates, point size, bone weights, and bone indices will be retained.</p>
<p>Invoking this method does NOT cause vertex index data to be retained. To retain vertex index data, use the retainVertexIndices method. </p>

</div>
</div>
<a class="anchor" id="af9418b19b821c6127392eddeed7730d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexIndices </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex index content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex indices will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a4aa5bd30d6c22ab7fb3d9b43627e9a95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexLocations </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex location content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex locations will be retained. Any other vertex content, such as normals, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a087f4bde149868930686af3bdac971f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexNormals </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex normal content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex normals will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a1bc57b27d389a09353bc22d1e2382b3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexPointSizes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex point size content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex point sizes will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a303e65417e99c6bc597d6650138e2cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexTangents </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex tangent content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex tangents will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="ab8e83fd5ac13c16e87948ef08bb09b8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexTextureCoordinates </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex texture coordinate content for all texture units used by this mesh to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex texture coordinates will be retained. Any other vertex content, such as locations, or normals, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a1d44e89f08f928d4202f53c47407a600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setTextureCoordinates: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_vertex_texture_coordinates.html">CC3VertexTextureCoordinates</a> *)&#160;</td>
          <td class="paramname"><em>aTexture</em></td>
        </tr>
        <tr>
          <td class="paramkey">forTextureUnit:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the texture coordinates array that will be processed by the texture unit with the specified index, which should be a number between zero, and the value of the textureCoordinatesArrayCount property. </p>
<p>If the specified index is less than the number of texture units added already, the specified texture coordinates array will replace the one assigned to that texture unit. Otherwise, this implementation will invoke the addTextureCoordinates: method to add the texture to this material.</p>
<p>If the specified texture unit index is zero, the value of the vertexTextureCoordinates property will be changed to the specified texture. </p>

</div>
</div>
<a class="anchor" id="a6d4b01c5368d3425072124f59b2ad7a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setTextureRectangle: </td>
          <td></td>
          <td class="paramtype">(CGRect)&#160;</td>
          <td class="paramname"><em>aRect</em></td>
        </tr>
        <tr>
          <td class="paramkey">forTextureUnit:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the textureRectangle property from the texture coordinates that are mapping the specified texture unit index. </p>
<p>See the notes for the textureRectangle property of this class for an explanation of the use of this property. </p>

</div>
</div>
<a class="anchor" id="ab284e9f42e9ad699c52b26e898b08c8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexBitangent: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>aTangent</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bitangent element at the specified index in the vertex content to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexBitangentsGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a6112ae83444c9b6301bb85540b691221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexBoneIndex: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>boneIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">forBoneInfluence:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>influenceIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the index of the bone, that provides the influence at the specified influence index within a vertex, for the vertex at the specified index within the underlying vertex content. </p>
<p>The bone index indicates which bone provides the particular influence for the movement of the particular vertex. Several bone indices are stored for each vertex, one for each bone that influences the movement of that vertex. The specified influenceIndex parameter must be between zero, and the vertexBoneCount property (inclusive/exclusive respectively).</p>
<p>The vertex index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexBoneIndicesGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="ad997be4b80139f831fc3a83fd76fcfcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexBoneIndices: </td>
          <td></td>
          <td class="paramtype">(GLvoid *)&#160;</td>
          <td class="paramname"><em>boneIndices</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the indices of all of the bones that influence the movement of the vertex at the specified index within the underlying vertex content. </p>
<p>Several indices are stored for each vertex, one for each bone that influences the movement of the vertex. The number of elements in the specified input array must therefore be at least as large as the value of the vertexBoneCount property.</p>
<p>The bone indices can be stored in each vertx as either type GLushort or type GLubyte. The specified array must be of the type of index stored by the verties in this mesh, and it is up to the application to know which type is required, and provide that type of array accordingly. The type can be determined by the vertexBoneIndexType property of this mesh, which will return one of GL_UNSIGNED_SHORT or GL_UNSIGNED_BYTE, respectively.</p>
<p>To avoid checking the elementType altogether, you can use the setVertxBoneIndex:forBoneInfluence:at: method, which sets the bone index values one at a time, and automatically converts the input type to the correct stored type.</p>
<p>The vertex index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexBoneIndicesGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="ae4309734405f485320428c5fff5bd9fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexBoneWeights: </td>
          <td></td>
          <td class="paramtype">(GLfloat *)&#160;</td>
          <td class="paramname"><em>weights</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the weights of all of the bones that influence the movement of the vertex at the specified index within the underlying vertex content. </p>
<p>Several weights are stored for each vertex, one for each bone that influences the movement of the vertex. The number of elements in the specified input array must therefore be at least as large as the value of the vertexBoneCount property.</p>
<p>The vertex index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexBoneWeightsGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="aa5656a6edc8be3aadd1bfa4d8fe3e727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexColor4B: </td>
          <td></td>
          <td class="paramtype">(ccColor4B)&#160;</td>
          <td class="paramname"><em>aColor</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color element at the specified index in the vertex content to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexColorsGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="af0a05712439b021b212e51e402ccc0d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexColor4F: </td>
          <td></td>
          <td class="paramtype">(ccColor4F)&#160;</td>
          <td class="paramname"><em>aColor</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color element at the specified index in the vertex content to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexColorsGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="ada5bd3c99a10063d1d9e755507d1edf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexHomogeneousLocation: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>)&#160;</td>
          <td class="paramname"><em>aLocation</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the location element at the specified index in the underlying vertex content to the specified four-dimensional location in the 4D homogeneous coordinate space. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>This implementation takes into consideration the dimensionality of the underlying data. If the dimensionality is 3, the W component of the specified vector will be ignored. If the dimensionality is 2, both the W and Z components of the specified vector will be ignored.</p>
<p>If this mesh is being used by any mesh nodes, be sure to invoke the markBoundingVolumeDirty method on all nodes that use this mesh, to ensure that the boundingVolume is recalculated using the new location values.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexLocationsGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a3166d599922702a93b5e5bbd49510b48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexIndex: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the index element at the specified index in the vertex content to the specified value. </p>
<p>The index refers to vertices, not bytes.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexIndicesGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a5c8895f4c5763420cc32efa3c771c407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexLocation: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>aLocation</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the location element at the specified index in the vertex content to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>This implementation takes into consideration the dimensionality of the underlying vertex content. If the dimensionality is 2, the Z component of the specified vector will be ignored. If the dimensionality is 4, the specified vector will be converted to a 4D vector, with the W component set to one, before storing.</p>
<p>If this mesh is being used by any mesh nodes, be sure to invoke the markBoundingVolumeDirty method on all nodes that use this mesh, to ensure that the boundingVolume is recalculated using the new location values.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexLocationsGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="aae4868f458c4402749922ac7a6df0011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexMatrixIndex: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>aMatrixIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">forVertexUnit:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexUnit</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated:</a></b></dt><dd>Renamed to setVertexBoneIndex:forBoneInfluence:at:. </dd></dl>

</div>
</div>
<a class="anchor" id="ac004fc56847fc7e060dde21ffdfa7628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexMatrixIndices: </td>
          <td></td>
          <td class="paramtype">(GLvoid *)&#160;</td>
          <td class="paramname"><em>mtxIndices</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000064">Deprecated:</a></b></dt><dd>Renamed to setVertexBoneIndices:at:. </dd></dl>

</div>
</div>
<a class="anchor" id="aa682abd0d8464017b983d5ff362c317d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexNormal: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>aNormal</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the normal element at the specified index in the vertex content to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexNormalsGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="aca6c2ce6c498d7029b546e233f4448d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexPointSize: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>aSize</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the point size element at the specified index in the vertex content to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the vertexStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updatePointSizesGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a3cadb4ecb56f1b13aa9e2e0e43b0c968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexTangent: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>aTangent</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the tangent element at the specified index in the vertex content to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexTangentsGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="ad9bc4d8f5320d37fce02f4bf0c086bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexTexCoord2F: </td>
          <td></td>
          <td class="paramtype">(ccTex2F)&#160;</td>
          <td class="paramname"><em>aTex2F</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the texture coordinate element at the specified index in the vertex content, at the commonly used texture unit zero, to the specified texture coordinate value. </p>
<p>This is a convenience method that delegates to the setVertexTexCoord2F:forTextureUnit:at: method, passing in zero for the texture unit index.</p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexTextureCoordinatesGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="ae7117e2f396a5c60ee7d984dd28fc761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexTexCoord2F: </td>
          <td></td>
          <td class="paramtype">(ccTex2F)&#160;</td>
          <td class="paramname"><em>aTex2F</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
        </tr>
        <tr>
          <td class="paramkey">forTextureUnit:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>Use the setVertexTexCoord2F:forTextureUnit:at: method instead, </dd></dl>

</div>
</div>
<a class="anchor" id="ad0947df4d24d3b6608fcc77a4eb41309"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexTexCoord2F: </td>
          <td></td>
          <td class="paramtype">(ccTex2F)&#160;</td>
          <td class="paramname"><em>aTex2F</em></td>
        </tr>
        <tr>
          <td class="paramkey">forTextureUnit:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the texture coordinate element at the specified index in the vertex content, at the specified texture unit index, to the specified texture coordinate value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexTextureCoordinatesGLBufferForTextureUnit: method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a48cc67be65c67a47cd64b103da50c143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexWeight: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>weight</em></td>
        </tr>
        <tr>
          <td class="paramkey">forBoneInfluence:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>influenceIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the weight value, for the specified influence index within the vertex, for the vertex at the specified index within the underlying vertex content. </p>
<p>The weight indicates how much a particular bone influences the movement of the particular vertex. Several weights are stored for each vertex, one for each bone that influences the movement of that vertex. The specified influenceIndex parameter must be between zero, and the vertexBoneCount property (inclusive/exclusive respectively).</p>
<p>The vertex index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexBoneWeightsGLBuffer method to ensure that the GL VBO that holds the vertex content is updated.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a0901f3364f28f602d9545bf735e9a6b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexWeight: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>aWeight</em></td>
        </tr>
        <tr>
          <td class="paramkey">forVertexUnit:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexUnit</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000058">Deprecated:</a></b></dt><dd>Renamed to setVertexWeight:forBoneInfluence:at:. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dc31e3c4cb02dc997862294f5553713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setVertexWeights: </td>
          <td></td>
          <td class="paramtype">(GLfloat *)&#160;</td>
          <td class="paramname"><em>weights</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000060">Deprecated:</a></b></dt><dd>Renamed to setVertexBoneWeights:at:. </dd></dl>

</div>
</div>
<a class="anchor" id="aea3fb0cb7631dd21c1a63646e5ffea49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_texture_coordinates.html">CC3VertexTextureCoordinates</a>*) textureCoordinatesForTextureUnit: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture coordinate array that will be processed by the texture unit with the specified index. </p>
<p>If the specified texture unit index is equal to or larger than the number of texture coordinates arrays, as indicated by the value of the textureCoordinatesArrayCount property, the texture coordinate array with the highest index is returned.</p>
<p>This design reuses the texture coordinate array with the highest index for all texture units higher than that index.</p>
<p>The value returned will be nil if there are no texture coordinates. </p>

</div>
</div>
<a class="anchor" id="a50bcbd2a4349f0cac6c4f43b6368ccce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (CGRect) textureRectangleForTextureUnit: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the textureRectangle property from the texture coordinates that are mapping the specified texture unit index. </p>
<p>See the notes for the textureRectangle property of this class for an explanation of the use of this property. </p>

</div>
</div>
<a class="anchor" id="a9c045f4997ea4f9b95c722c54b907892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateGLBuffers </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to update the GL engine buffers with the vertex content in this mesh. </p>
<p>This updates the content of each vertex. It does not update the vertex indices. To update the vertex index data to the GL engine, use the updateVertexIndicesGLBuffer method. </p>

</div>
</div>
<a class="anchor" id="a2c55790238cb61204de6d0e47b8b616b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateGLBuffersStartingAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>offsetIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">forLength:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to update GL buffers for all vertex arrays used by this mesh, except vertexIndices, starting at the vertex at the specified offsetIndex, and extending for the specified number of vertices. </p>

</div>
</div>
<a class="anchor" id="aea2deb8975b90dbcfbcdd712d248b2aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updatePointSizesGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the point size content in this mesh. </p>

</div>
</div>
<a class="anchor" id="af8ffd0cf2afa3b1c653e923fac351a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateVertexBitangentsGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the vertex bitangent content in this mesh. </p>

</div>
</div>
<a class="anchor" id="adfb8aebc296b6538176565d76b4aff96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateVertexBoneIndicesGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the vertex bone indices content in this mesh. </p>

</div>
</div>
<a class="anchor" id="a9a0a80c53f8de77a51307a26652603c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateVertexBoneWeightsGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the vertex bone weight content in this mesh. </p>

</div>
</div>
<a class="anchor" id="af94e31962b7d39013aeb746d6d2c4160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateVertexColorsGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the vertex color content in this mesh. </p>

</div>
</div>
<a class="anchor" id="ab925a11366aa934f5cf797b666258998"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateVertexIndicesGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the vertex index data in this mesh. </p>

</div>
</div>
<a class="anchor" id="a2ff690a5a325fef4f05e50c3f0958e82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateVertexLocationsGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the vertex location content in this mesh. </p>

</div>
</div>
<a class="anchor" id="a03c94d644d9c71eea23e24b559f9982c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateVertexNormalsGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the vertex normal content in this mesh. </p>

</div>
</div>
<a class="anchor" id="aa17ffbec86d316d89da937ba83355fb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) updateVertexStride </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the shouldInterleaveVertices property is set to YES, updates the elementOffset and vertexStride properties of each enclosed vertex array to correctly align them for interleaved data. </p>
<p>After constructing the vertex arrays in this mesh, and setting the shouldInterleaveVertices property is set to YES, you can invoke this method to align the vertex arrays for interleaved vertex content.</p>
<p>If the shouldInterleaveVertices property is set to NO, this method has no effect.</p>
<p>If you used the vertexContentTypes property to construct the vertex arrays, you do not need to invoke this method. However, if you subsequently adjusted the elementType or elementSize of any of the vertex arrays, or if you added additional texture coordinate overlay vertex arrays, you can invoke this method to align the vertex arrays correctly again.</p>
<p>The element offsets of the vertex arrays are aligned in the order documented in the notes of the vertexContentTypes property, even if the vertex arrays were created directly, instead of by setting the vertexContentTypes property.</p>
<p>Returns the number of bytes used by the all of the content of one vertex. This value is calculated and returned regardless of the value of the shouldInterleaveVertices property </p>

</div>
</div>
<a class="anchor" id="a6e3695ea875ad95c6d7cc6f59f439bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateVertexTangentsGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the vertex tangent content in this mesh. </p>

</div>
</div>
<a class="anchor" id="aedc3dee48200842097c95a0dbcb6812d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateVertexTextureCoordinatesGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the vertex texture coord content from texture unit zero in this mesh. </p>

</div>
</div>
<a class="anchor" id="a4f2b7a99b8db027d40207a7ce3f0532a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateVertexTextureCoordinatesGLBufferForTextureUnit: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the vertex texture coord content from the specified texture unit in this mesh. </p>

</div>
</div>
<a class="anchor" id="a5fc9d5e7f1297c8afd0345086139f318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_array.html">CC3VertexArray</a>*) vertexArrayForSemantic: </td>
          <td></td>
          <td class="paramtype">(GLenum)&#160;</td>
          <td class="paramname"><em>semantic</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>semanticIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contained vertex array that contains the vertex content for the specified semantic and semantic meaning. </p>
<p>Based on the value of the specified semantic, this method returns the following:</p>
<ul>
<li></li>
<li>kCC3SemanticVertexLocation: self.vertexLocations</li>
<li>kCC3SemanticVertexNormal: self.vertexNormals</li>
<li>kCC3SemanticVertexTangent: self.vertexTangents</li>
<li>kCC3SemanticVertexBitangent: self.vertexBitangents</li>
<li>kCC3SemanticVertexColor: self.vertexColors</li>
<li>kCC3SemanticVertexBoneWeights: self.vertexBoneWeights</li>
<li>kCC3SemanticVertexBoneIndices: self.vertexBoneIndices</li>
<li>kCC3SemanticVertexPointSize: self.vertexPointSizes</li>
<li>kCC3SemanticVertexTexture: [self textureCoordinatesForTextureUnit: semanticIndex] </li>
</ul>

</div>
</div>
<a class="anchor" id="a0682eff71603afc5569c722aed479de6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) vertexBitangentAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bitangent element at the specified index from the vertex content. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a6c58270b39d7074ec9867f55980b379d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexBoneIndexForBoneInfluence: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>influenceIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the bone, that provides the influence at the specified influence index within a vertex, for the vertex at the specified index within the underlying vertex content. </p>
<p>The bone index indicates which bone provides the particular influence for the movement of the particular vertex. Several bone indices are stored for each vertex, one for each bone that influences the movement of that vertex. The specified influenceIndex parameter must be between zero, and the vertexBoneCount property (inclusive/exclusive respectively).</p>
<p>The vertex index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="abdf4ff7f839a2ef598101b1972c9bb0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLvoid*) vertexBoneIndicesAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxIndex</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the indices of all of the bones that influence the movement of the vertex at the specified index within the underlying vertex content. </p>
<p>Several indices are stored for each vertex, one for each bone that influences the movement of the vertex. The number of elements in the returned array is the same for each vertex in this vertex array, as defined by the vertexBoneCount property.</p>
<p>The bone indices can be stored in each vertex as either type GLushort or type GLubyte. The returned array will be of the type of index stored by the verties in this mesh, and it is up to the application to know which type will be returned, and cast the returned array accordingly. The type can be determined by the vertexBoneIndexType property of this mesh, which will return one of GL_UNSIGNED_SHORT or GL_UNSIGNED_BYTE, respectively.</p>
<p>The vertex index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="ae007aed1ce47c2fca384cbec1112d8cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat*) vertexBoneWeightsAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxIndex</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weights of all of the bones that influence the movement of the vertex at the specified index within the underlying vertex content. </p>
<p>Several weights are stored for each vertex, one for each bone that influences the movement of the vertex. The number of elements in the returned array is the same for each vertex in this vertex array, as defined by the vertexBoneCount property.</p>
<p>The vertex index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="aaaa23e90220c69559e274a0d6b2b091b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (ccColor4B) vertexColor4BAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the color element at the specified index from the vertex content. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a282a07b33f02899284c49b444acf247f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (ccColor4F) vertexColor4FAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the color element at the specified index from the vertex content. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="ab09464c08e267e648f18ae6a06b65666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexCountFromFaceCount: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>Renamed to vertexIndexCountFromFaceCount:. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f5813f5c1f1be1f4bd67d5b3d0a2c8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>) vertexHomogeneousLocationAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the location element at the specified index in the underlying vertex content, as a four-dimensional location in the 4D homogeneous coordinate space. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>This implementation takes into consideration the elementSize property. If the value of the elementSize property is 3, the returned vector will contain one in the W component. If the value of the elementSize property is 2, the returned vector will contain zero in the Z component and one in the W component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a1158fcc73de87584dc20a1b8ca36078a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexIndexAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index element at the specified index from the vertex content. </p>
<p>The index refers to vertices, not bytes.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a22ce026f9f9c620b3c3767d393f7353e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexIndexCountFromFaceCount: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>fc</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of vertex indices required to draw the specified number of faces, based on the type of primitives that this mesh is drawing. </p>

</div>
</div>
<a class="anchor" id="a55929ef758b8d2352df12052276c48a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) vertexLocationAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the location element at the specified index from the vertex content. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>This implementation takes into consideration the dimensionality of the underlying vertex content. If the dimensionality is 2, the returned vector will contain zero in the Z component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="ac168dd774ac7f613a37320d095de3be5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexMatrixIndexForVertexUnit: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexUnit</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000061">Deprecated:</a></b></dt><dd>Renamed to vertexBoneIndexForBoneInfluence:at:. </dd></dl>

</div>
</div>
<a class="anchor" id="a980e214841939ce900c7824f57d9f60e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLvoid*) vertexMatrixIndicesAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000063">Deprecated:</a></b></dt><dd>Renamed to vertexBoneIndicesAt:. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c3f552bdf2bca51201b78045bfb826e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) vertexNormalAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the normal element at the specified index from the vertex content. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a92a972f4df733f53d3698deaa96b17b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) vertexPointSizeAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxIndex</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the point size element at the specified index from the vertex content. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the vertexStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="af36c8b1cc658d33cb15bcf1e5e2c4c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) vertexTangentAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tangent element at the specified index from the vertex content. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a4188e0c98e379b8f6082edd896707946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (ccTex2F) vertexTexCoord2FAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture coordinate element at the specified index from the vertex content at the commonly used texture unit zero. </p>
<p>This is a convenience method that is equivalent to invoking the vertexTexCoord2FForTextureUnit:at: method, with zero as the texture unit index.</p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a63cb57766654b3c9f03dcb3adcb88151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (ccTex2F) <a class="el" href="interface_c_c3_mesh.html#a4188e0c98e379b8f6082edd896707946">vertexTexCoord2FAt:</a> </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
        </tr>
        <tr>
          <td class="paramkey">forTextureUnit:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>Use the vertexTexCoord2FForTextureUnit:at: method instead, </dd></dl>

</div>
</div>
<a class="anchor" id="a9f389ae33ed3ef4b42f8a7d64a092292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (ccTex2F) vertexTexCoord2FForTextureUnit: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>texUnit</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture coordinate element at the specified index from the vertex content at the specified texture unit index. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="ae0cddf30c65fc1af604a780c56362c8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) vertexWeightForBoneInfluence: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>influenceIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weight value, for the specified influence index within the vertex, for the vertex at the specified index within the underlying vertex content. </p>
<p>The weight indicates how much a particular bone influences the movement of the particular vertex. Several weights are stored for each vertex, one for each bone that influences the movement of that vertex. The specified influenceIndex parameter must be between zero, and the vertexBoneCount property (inclusive/exclusive respectively).</p>
<p>The vertex index refers to vertices, not bytes. The implementation takes into consideration whether the vertex content is interleaved to access the correct vertex content component.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a4c72a3d0e5c15148a48e952e7723dfc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) vertexWeightForVertexUnit: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexUnit</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000057">Deprecated:</a></b></dt><dd>Renamed to vertexWeightForBoneInfluence:at:. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b434e313ccbbffb9d6b88001e5f6070"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat*) vertexWeightsAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000059">Deprecated:</a></b></dt><dd>Renamed to vertexBoneWeightsAt:. </dd></dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ab5fba4899d83894ac06bfbb6710510fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_bone_indices.html">CC3VertexBoneIndices</a>* vertexMatrixIndices) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated:</a></b></dt><dd>Renamed to vertexBoneIndices. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b7cef079e8c13e6d77110a95ce3e161"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL hasVertexMatrixIndices) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000053">Deprecated:</a></b></dt><dd>Renamed to hasVertexBoneIndices. </dd></dl>

</div>
</div>
<a class="anchor" id="aabf40765d2c2ab6fd15b5afaeb59cee8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_bone_weights.html">CC3VertexBoneWeights</a>* vertexWeights) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000054">Deprecated:</a></b></dt><dd>Renamed to vertexBoneWeights. </dd></dl>

</div>
</div>
<a class="anchor" id="a78667b35b79bb7e8211ab5607d1032f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL hasVertexWeights) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000055">Deprecated:</a></b></dt><dd>Renamed to hasVertexBoneWeights. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4a144155cabacb51b85c0f689a26565"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint vertexUnitCount) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000056">Deprecated:</a></b></dt><dd>Renamed to vertexBoneCount. </dd></dl>

</div>
</div>
<a class="anchor" id="a35563e05790ebcbad8c0a85f554efccb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLenum matrixIndexType) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000065">Deprecated:</a></b></dt><dd>Renamed to vertexBoneIndexType. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cd8143fd04160ebd01f7f145381106c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) allocatedVertexCapacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates, reallocates, or deallocates underlying memory for the specified number of vertices, taking into consideration the amount of memory required by each vertex. </p>
<p>Setting this property affects the value of the vertexCount property. After setting this property, the vertexCount property will be set to the same value as this property. After setting this property, if you will not be using all of the allocated vertices immediately, you should set the value of the vertexCount property to the actual number of vertices in use.</p>
<p>Use of this property is not required if the vertex content has already been loaded into memory by a file loader, or defined by a static array. In that situation, you should set the vertexCount property directly, and avoid using this property.</p>
<p>If the vertex content consists only of vertex locations, you can set this property without having to define any content, and the <a class="el" href="interface_c_c3_vertex_locations.html" title="A CC3VertexArray that manages the location aspect of an array of vertices. ">CC3VertexLocations</a> instance in the vertexLocations property will automatically be created.</p>
<p>However, if the vertex content contains more than just location data, since memory allocation is dependent on the content required by each vertex, you should set this property only after the contained vertex arrays have been constructed and configured, either directly, or via the the vertexContentTypes property, the shouldInterleaveVertices property has been set, and the udpateVertexStride method has been invoked, if needed.</p>
<p>If adding vertex arrays directly, in general, the order of operations is:</p>
<ol type="1">
<li>set the shouldInterleaveVertices property appropriately</li>
<li>add vertex arrays directly</li>
<li>invoke the updateVertexStride method (if shouldInterleaveVertices set to YES)</li>
<li>set the allocatedVertexCapacity property to allocate memory</li>
<li>populate the vertex content with your data</li>
</ol>
<p>If using the vertexContentTypes property to automatically construct the vertex arrays, the order of operations is:</p>
<ol type="1">
<li>set the shouldInterleaveVertices property appropriately</li>
<li>set the vertexContentTypes property</li>
<li>set the allocatedVertexCapacity property to allocate memory</li>
<li>populate the vertex content with your data</li>
</ol>
<p>This property may be set repeatedly to manage the underlying mesh vertex content as a dynamically-sized array, growing and shrinking the allocated memory as needed.</p>
<p>In addition, you can set this property to zero to safely deallocate all memory used by the vertex content of this mesh. After setting this property to zero, the value of the vertexCount property will be zero.</p>
<p>When setting the value of this property to a new non-zero value, all current vertex content, up to the lesser of the new and old values of this property, will be preserved.</p>
<p>If the value of this property is increased (including from zero on the first assignement), vertex content for those vertices beyond the old value of this property will be undefined, and must be populated by the application before attempting to draw that vertex content.</p>
<p>If you are not ready to populate the newly allocated vertex content yet, after setting the value of this property, you can set the value of the vertexCount property to a value less than the value of this property (including to zero) to stop such undefined vertex content from being drawn. </p>

</div>
</div>
<a class="anchor" id="ab4a0fddccf63b95a9757de8a0f2625f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) allocatedVertexIndexCapacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates, reallocates, or deallocates underlying memory for the specified number of vertex indices, taking into consideration the amount of memory required by each index. </p>
<p>Setting this property affects the value of the vertexIndexCount property. After setting this property, the vertexIndexCount property will be set to the same value as this property. After setting this property, if you will not be using all of the allocated vertex indices immediately, you should set the value of the vertexIndexCount property to the actual number of vertices in use.</p>
<p>Use of this property is not required if the vertex content has already been loaded into memory by a file loader, or defined by a static array. In that situation, you should set the vertexIndexCount property directly, and avoid using this property.</p>
<p>This property may be set repeatedly to manage the underlying mesh vertex index data as a dynamically-sized array, growing and shrinking the allocated memory as needed.</p>
<p>In addition, you can set this property to zero to safely deallocate all memory used by the vertex indices of this mesh. After setting this property to zero, the value of the vertexIndexCount property will be zero.</p>
<p>When setting the value of this property to a new non-zero value, all current vertex indices, up to the lesser of the new and old values of this property, will be preserved.</p>
<p>If the value of this property is increased (including from zero on the first assignement), those vertex indices beyond the old value of this property will be undefined, and must be populated by the application before attempting to draw that vertex content.</p>
<p>If you are not ready to populate the newly allocated vertex indices yet, after setting the value of this property, you can set the value of the vertexIndexCount property to a value less than the value of this property (including to zero) to stop such undefined vertices from being drawn. </p>

</div>
</div>
<a class="anchor" id="adc37f1c5ac4d3317f6157af5695c9109"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_box.html">CC3Box</a>) boundingBox</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the the smallest axis-aligned-bounding-box (AABB) that surrounds the mesh. </p>

</div>
</div>
<a class="anchor" id="a7e56739af65416894c3fe1a0775e4f07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) capacityExpansionFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A factor that is used to provide additional vertex capacity when increasing the allocated vertex capacity via the ensureVertexCapacity: method. </p>
<p>The initial value of this property is 1.25, providing a buffer of 25% whenever vertex capacity is expanded. </p>

</div>
</div>
<a class="anchor" id="a70fd7f1ae2d25f3cd9efe260b554cde5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) centerOfGeometry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The center of geometry of this mesh. </p>

</div>
</div>
<a class="anchor" id="a67829ffbe68afe9f971e468f7b9bd935"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="_c_c3_c_c2_extensions_8h.html#a9ee2c61886665ba64b5de7be1a1bf83d">CCColorRef</a>) color</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The color of the vertices of this mesh. </p>
<p>Querying this property returns the RGB components of the first vertex in this mesh, or ccBLACK if this mesh contains no per-vertex color content.</p>
<p>When setting this property, if this mesh contains per-vertex color content, the RGB values of each vertex in this mesh are set to the specified color, without affecting the opacity value of each individual vertex. If the vertex color content of this mesh has been copied to a GL buffer, that GL buffer is automatically updated. </p>

</div>
</div>
<a class="anchor" id="a6fea1edb0a5bc45a98e02fe2add1e29e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLenum) drawingMode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The drawing mode indicating how the vertices are connected (points, lines, triangles...). </p>
<p>This must be set with a valid GL drawing mode enumeration. The default value is GL_TRIANGLES. </p>

</div>
</div>
<a class="anchor" id="a8c813b311bf7450f5273303fb65ea54b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) expectsVerticallyFlippedTextures</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the texture coordinates of this mesh expects that the texture was flipped upside-down during texture loading. </p>
<p>The vertical axis of the coordinate system of OpenGL is inverted relative to the CoreGraphics view coordinate system. As a result, some texture file formats may be loaded upside down. Most common file formats, including JPG, PNG &amp; PVR are loaded right-way up, but using proprietary texture formats developed for other platforms may result in textures being loaded upside-down.</p>
<p>The value of this property is used in combination with the value of the isUpsideDown property of a texture to determine whether the texture will be oriented correctly when displayed using these texture coordinates.</p>
<p>The alignTextureUnit:withTexture: method compares the value of this property with the isUpsideDown property of the texture to automatically determine whether these texture coordinates need to be flipped vertically in order to display the texture correctly, and will do so if needed. As part of that inversion, the value of this property will also be flipped, to indicate that the texture coordinates are now aligned differently.</p>
<p>The alignTextureUnit:withTexture: method is invoked automatically when a texture is assigned to cover this mesh in the mesh node. If you need to adjust the value of this property, you sould do so before setting a texture or material into the mesh node.</p>
<p>When multi-texturing is being used on this mesh, you can use the expectsVerticallyFlippedTexture:inTextureUnit: method for finer control of orienting textures for each texture unit. When multi-texturing is being used, setting this value of this property will invoke the expectsVerticallyFlippedTexture:inTextureUnit: method to set the same value for each texture unit.</p>
<p>Reading the value of this property will return YES if the property-reading method expectsVerticallyFlippedTextureInTextureUnit: returns YES for any texture unit, otherwise this property will return NO.</p>
<p>The initial value of this property is set when the underlying mesh texture coordinates are built or loaded. See the expectsVerticallyFlippedTextures property on the <a class="el" href="interface_c_c3_nodes_resource.html" title="CC3NodesResource is a wrapper class around a resource structure loaded from a data file containing 3D...">CC3NodesResource</a> class to understand how this property is set during mesh resource loading.</p>
<p>When building meshes programmatically, you should endeavour to design the mesh so that this property will be YES if you will be using vertically-flipped textures (all texture file formats except PVR). </p>

</div>
</div>
<a class="anchor" id="a7c46b735abbec7668ae46630700f88f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) faceCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of faces in this mesh. </p>
<p>This is calculated from the number of vertices, taking into consideration the type of primitives that this mesh is drawing. </p>

</div>
</div>
<a class="anchor" id="a944152dc02eda998579be52bf564591b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_face_array.html">CC3FaceArray</a>*) faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional information about the faces in the mesh. </p>
<p>This property does not contain vertex information for the faces. That is contained within the mesh itself. As such, most meshes do not require this additional information about the faces of the mesh. This property provides additional information about the faces that can be used in certain customized lighting and shadowing effects.</p>
<p>If this property is not set directly, it will be lazily initialized on first access.</p>
<p>Since the face array contains static information about a mesh, when copying a mesh, the face array is not itself copied by default. This avoids duplication of data that does not change between two copies of the same mesh object. Instead, both mesh copies will share a reference to the same face array instance. If you need to create separate copies of the faces array when copying a mesh, you must explicitly create a copy. </p>

</div>
</div>
<a class="anchor" id="a739c89fbfaafd15e8826ce88d034b926"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasVertexBitangents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this mesh contains content for vertex bitangents. </p>

</div>
</div>
<a class="anchor" id="a185eb874a2d5807e5f673718a72692d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasVertexBoneIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this mesh contains content for vertex bone indices. </p>

</div>
</div>
<a class="anchor" id="a1e66ad3a0e5c6cbab997fac0b99e9dea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasVertexBoneWeights</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this mesh contains content for vertex bone weights. </p>

</div>
</div>
<a class="anchor" id="ac347e27de3bbb1cf2593be372547f782"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasVertexColors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this mesh contains content for vertex colors. </p>

</div>
</div>
<a class="anchor" id="a94a4effcf34a2331366bab51e72d6833"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasVertexIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this mesh uses index vertices. </p>

</div>
</div>
<a class="anchor" id="aeced0ec2348c6d6a8981986f0ce5e64a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasVertexLocations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this mesh contains content for vertex locations. </p>

</div>
</div>
<a class="anchor" id="a68c9b64417c963f2707167b8ad4516c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasVertexNormals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this mesh contains content for vertex normals. </p>

</div>
</div>
<a class="anchor" id="ae5b847a5ffc6266337f7206feb0ac00f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasVertexPointSizes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this mesh contains content for vertex point sizes. </p>

</div>
</div>
<a class="anchor" id="a3004967ec1484d8707b133483a070fd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasVertexTangents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this mesh contains content for vertex tangents. </p>

</div>
</div>
<a class="anchor" id="af2d43189a7abdf66c0908dbf7a6c056b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasVertexTextureCoordinates</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this mesh contains data for vertex texture coordinates. </p>

</div>
</div>
<a class="anchor" id="a07e733f11bf78bb7f5f519c6ea3a8638"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLvoid*) interleavedVertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the shouldInterleaveVertices is set to YES, returns a pointer to the interleaved vertex content of this mesh. </p>
<p>If the shouldInterleaveVertices is set to NO, returns a NULL pointer.</p>
<p>You must set the allocatedVertexCapacity property, or directly attach vertex storage to the vertex arrays, prior to accessing this property.</p>
<p>When populating the interleaved vertex content for this mesh, you can use this pointer as a starting point to iterate through the vertex content. You can cast the returned pointer to a custom structure that you declare that matches the content structure of a single interleaved vertex. The form of that structure depends on the content components defined for the vertices, is described in the documentation for the vertexContentTypes property. An enumeration of the vertex content components is available through the vertexContentTypes property. </p>

</div>
</div>
<a class="anchor" id="ab74753e0641e099a30237713591fc257"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isUsingGLBuffers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the underlying vertex content has been loaded into GL engine vertex buffer objects. </p>
<p>Vertex buffer objects are engaged via the createGLBuffers method. </p>

</div>
</div>
<a class="anchor" id="a9b3ab53dc69fe91c1b8b41b20186466d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="_c_c3_c_c2_extensions_8h.html#aa13d5a16c4c3791576122915480e1772">CCOpacity</a>) opacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The opacity of the vertices in this mesh. </p>
<p>Querying this property returns the alpha component of the first vertex in this mesh, or full opacity if this mesh contains no per-vertex color content.</p>
<p>When setting this property, if this mesh contains per-vertex color content, the alpha values of each vertex in this mesh is set to the specified opacity, without affecting the RGB color value of each individual vertex. If the vertex color content of this mesh has been copied to a GL buffer, that GL buffer is automatically updated. </p>

</div>
</div>
<a class="anchor" id="a6111e778ad97e6f9bc2ad8724534f921"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) radius</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the radius of a spherical boundary, centered on the centerOfGeometry, that encompasses all the vertices of this mesh. </p>

</div>
</div>
<a class="anchor" id="a13ab0b1cec2c1378e1418afa511f6f9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldCacheFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether information about the faces of this mesh should be cached. </p>
<p>If this property is set to NO, accessing information about the faces through the methods faceAt:, faceIndicesAt:, faceCenterAt:, faceNormalAt:, or facePlaneAt:, will be calculated dynamically from the mesh data.</p>
<p>If such data will be accessed frequently, this repeated dynamic calculation may cause a noticable impact to performance. In such a case, this property can be set to YES to cause the data to be calculated once and cached, improving the performance of subsequent accesses to information about the faces.</p>
<p>However, caching information about the faces will increase the amount of memory required by the mesh, sometimes significantly. To avoid this additional memory overhead, in general, you should leave this property set to NO, unless intensive access to face information is causing a performance impact.</p>
<p>An example of a situation where the use of this property may be noticable, is when adding shadow volumes to nodes. Shadow volumes make intense use of accessing face information about the mesh that is casting the shadow.</p>
<p>When the value of this property is set to NO, any data cached during previous access through the indicesAt:, centerAt:, normalAt:, or planeAt:, methods will be cleared.</p>
<p>The initial value of this property is NO. </p>

</div>
</div>
<a class="anchor" id="aed1c30e89cdb14e86c1ed7c9f81041ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldInterleaveVertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the vertex content should be interleaved, or separated by type. </p>
<p>If the vertex content is interleaved, each of the contained <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> instances will reference the same underlying memory buffer through their individual vertices property.</p>
<p>Interleaving vertex content is recommended, as it improves the GPU's ability to optimize throughput.</p>
<p>The value of this property should be set before the values of the vertexContentTypes and allocatedVertexCapacity are set.</p>
<p>The initial value is YES, indicating that the vertex content will be interleaved. </p>

</div>
</div>
<a class="anchor" id="ad4cd3b5195c0a61e2619e7fb486d5ae6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) textureCoordinatesArrayCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of texture coordinate arrays used by this mesh, regardless of whether the texture coordinates were attached using the vertexTextureCoordinates property or the addTextureCoordinates: method. </p>

</div>
</div>
<a class="anchor" id="aec0451580686743d8bbf5baf0745cf7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (CGRect) textureRectangle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the rectangular area of the textures, for all texture units, that should be mapped to this mesh. </p>
<p>This property facilitates the use of sprite-sheets, where the mesh is covered by a small fraction of a larger texture. This technique has many uses, including animating a texture onto a mesh, where each section of the full texture is really a different frame of a texture animation, or simply loading one larger texture and using parts of it to texture many different meshes.</p>
<p>The dimensions of this rectangle are taken as fractional portions of the full area of the texture. Therefore, a rectangle with zero origin, and unit size ((0.0, 0.0), (1.0, 1.0)) indicates that the mesh should be covered with the complete texture.</p>
<p>A rectangle of smaller size, and/or a non-zero origin, indicates that the mesh should be covered by a fractional area of the texture. For example, a rectangular value for this property with origin at (0.5, 0.5), and size of (0.5, 0.5) indicates that only the top-right quarter of the texture will be used to cover this mesh.</p>
<p>The bounds of the texture rectangle must fit within a unit rectangle. Both the bottom-left and top-right corners must lie between zero and one in both the X and Y directions.</p>
<p>The dimensions of the rectangle in this property are independent of adjustments made by the alignWithTexturesIn: and alignWithInvertedTexturesIn: methods. A unit rectangle value for this property will automatically take into consideration the adjustment made to the mesh by those methods, and will display only the part of the texture defined by them. Rectangular values for this property that are smaller than the unit rectangle will be relative to the displayable area defined by alignWithTexturesIn: and alignWithInvertedTexturesIn:.</p>
<p>As an example, if the alignWithTexturesIn: method was used to limit the mesh to using only 80% of the texture (perhaps when using a non-POT texture), and this property was set to a rectangle with origin at (0.5, 0.0) and size (0.5, 0.5), the mesh will be covered by the bottom-right quarter of the usable 80% of the overall texture.</p>
<p>This property affects all texture units used by this mesh, to query or change this property for a single texture unit only, use the textureRectangleForTextureUnit: and setTextureRectangle:forTextureUnit: methods.</p>
<p>The initial value of this property is a rectangle with origin at zero, and unit size, indicating that the mesh will be covered with the complete usable area of the texture. </p>

</div>
</div>
<a class="anchor" id="a8283b1283317e1b0f1f684f77d163e93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_tangents.html">CC3VertexTangents</a>*) vertexBitangents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertex array instance managing the bitangent content for the vertices. </p>
<p>Setting this property is optional. Not all meshes require bitangents. </p>

</div>
</div>
<a class="anchor" id="a79a9845c404d8f2b54abcce45e95358b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexBoneCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bones that influence each vertex in this mesh. </p>
<p>This value defines the number of bone weights and bone indices that are attached to each vertex. </p>

</div>
</div>
<a class="anchor" id="a28acfb1b63f33712cef047b313c4baba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLenum) vertexBoneIndexType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of data element used to store each bone index. </p>
<p>The value returned by this property will be either GL_UNSIGNED_SHORT or GL_UNSIGNED_BYTE, corresponding to each bone index being stored in either a type GLushort or type GLubyte, respectively.</p>
<p>You can use the value of this property to determine how to cast the data arrays used by the vertexBoneIndicesAt: and setVertexBoneIndices:at: methods. </p>

</div>
</div>
<a class="anchor" id="a9f4351497373ffcff0a5b2857152ce0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_bone_indices.html">CC3VertexBoneIndices</a>*) vertexBoneIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertex array that manages the indices of the bones that influence each vertex. </p>
<p>Each element of the vertex array in this property is a small set of index values that reference a set of bones that influence the location of that vertex.</p>
<p>The elementSize property of the vertex arrays in the vertexBoneWeights and vertexBoneIndices properties must be the same, and under OpenGL ES 1.1, the elementSize value must also not be larger than the maximum number of available bone influences allowed by the platform, which can be retreived from CC3OpenGL.sharedGL.maxNumberOfBoneInfluencesPerVertex. </p>

</div>
</div>
<a class="anchor" id="ae1765a528be5c930c6ec0973b8948b1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_bone_weights.html">CC3VertexBoneWeights</a>*) vertexBoneWeights</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertex array that manages the weighting that each bone has in influencing each vertex. </p>
<p>Each element of the vertex array in this property contains a small set of weighting values that determine the relative influence that each of the bones identified for that vertex in the vertexBoneIndices property has on transforming the location of the vertex.</p>
<p>The elementSize property of the vertex arrays in the vertexBoneWeights and vertexBoneIndices properties must be the same, and under OpenGL ES 1.1, the elementSize value must also not be larger than the maximum number of available bone influences allowed by the platform, which can be retreived from CC3OpenGL.sharedGL.maxNumberOfBoneInfluencesPerVertex. </p>

</div>
</div>
<a class="anchor" id="ae239b202fba4cbbd2c87ddc35731bfae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_colors.html">CC3VertexColors</a>*) vertexColors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertex array instance managing the per-vertex color content for the vertices. </p>
<p>Setting this property is optional. Many meshes do not require per-vertex coloring. </p>

</div>
</div>
<a class="anchor" id="a7fcbc934c27858d65d5185bc9708675a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLenum) vertexColorType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the symbolic content type of the vertex color, which indicates the range of values stored for each vertex color. </p>
<p>This property will return one of the values: GL_FLOAT, GL_UNSIGNED_BYTE, or GL_FIXED, or will return GL_FALSE if this mesh does not support individual vertex colors.</p>
<p>You can use the value returned by this property to select whether to access individual vertex color content as bytes or floats, in order to retain accuracy and avoid unnecessary type conversions. </p>

</div>
</div>
<a class="anchor" id="aab4db5ea6ffeefce87e27f9bac0ef6d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="_c_c3_mesh_8h.html#a026556c0ec4fa50f2dab794fdf218d01">CC3VertexContent</a>) vertexContentTypes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the types of content contained in each vertex of this mesh. </p>
<p>Each vertex can contain several types of content, optionally including location, normal, color, texture coordinates, along with other specialized content for certain specialized meshes. To identify this various content, this property is a bitwise-OR of flags that enumerate the types of content contained in each vertex of this mesh.</p>
<p>Valid component flags of this property include:</p>
<ul>
<li>kCC3VertexContentLocation</li>
<li>kCC3VertexContentNormal</li>
<li>kCC3VertexContentTangent</li>
<li>kCC3VertexContentBitangent</li>
<li>kCC3VertexContentColor</li>
<li>kCC3VertexContentTextureCoordinates</li>
<li>kCC3VertexContentBoneWeights</li>
<li>kCC3VertexContentBoneIndices</li>
<li>kCC3VertexContentPointSize</li>
</ul>
<p>To indicate that this mesh should contain particular vertex content, construct a bitwise-OR combination of one or more of the component types listed above, and set this property to that combined value.</p>
<p>Setting each bitwise-OR component in this property instructs this instance to automatically construct the appropriate type of contained vertex array:</p>
<ul>
<li>kCC3VertexContentLocation - automatically constructs a <a class="el" href="interface_c_c3_vertex_locations.html" title="A CC3VertexArray that manages the location aspect of an array of vertices. ">CC3VertexLocations</a> instance in the vertexLocations property, that holds 3D vertex locations, in one <a class="el" href="struct_c_c3_vector.html" title="A vector in 3D space. ">CC3Vector</a> structure per vertex. This component is optional, as the vertexLocations property will be constructed regardless.</li>
<li>kCC3VertexContentNormal - automatically constructs a <a class="el" href="interface_c_c3_vertex_normals.html" title="A CC3VertexArray that manages the normal aspect of an array of vertices. ">CC3VertexNormals</a> instance in the vertexNormals property, that holds 3D vertex normals, in one <a class="el" href="struct_c_c3_vector.html" title="A vector in 3D space. ">CC3Vector</a> structure per vertex.</li>
<li>kCC3VertexContentTangent - automatically constructs a <a class="el" href="interface_c_c3_vertex_tangents.html" title="A CC3VertexArray that manages the tangent or bitangent aspect of an array of vertices. ">CC3VertexTangents</a> instance in the vertexTangents property, that holds 3D vertex tangents, in one <a class="el" href="struct_c_c3_vector.html" title="A vector in 3D space. ">CC3Vector</a> structure per vertex.</li>
<li>kCC3VertexContentBitangent - automatically constructs a <a class="el" href="interface_c_c3_vertex_tangents.html" title="A CC3VertexArray that manages the tangent or bitangent aspect of an array of vertices. ">CC3VertexTangents</a> instance in the vertexBitangents property, that holds 3D vertex tangents, in one <a class="el" href="struct_c_c3_vector.html" title="A vector in 3D space. ">CC3Vector</a> structure per vertex.</li>
<li>kCC3VertexContentColor - automatically constructs a <a class="el" href="interface_c_c3_vertex_colors.html" title="A CC3VertexArray that manages the per-vertex color aspect of an array of vertices. ">CC3VertexColors</a> instance in the vertexColors property, that holds RGBA colors with GLubyte components, in one ccColor4B structure per vertex.</li>
<li>kCC3VertexContentTextureCoordinates - automatically constructs a <a class="el" href="interface_c_c3_vertex_texture_coordinates.html" title="A CC3VertexArray that manages the texture coordinates aspect of an array of vertices. ">CC3VertexTextureCoordinates</a> instance in the vertexTextureCoordinates property, that holds 2D texture coordinates, in one ccTex2F structure per vertex.</li>
<li>kCC3VertexContentBoneWeights - automatically constructs a <a class="el" href="interface_c_c3_vertex_bone_weights.html" title="A CC3VertexArray that manages a collection of bone weights for each vertex. ">CC3VertexBoneWeights</a> instance in the vertexBoneWeights property, that holds several GLfloat values per vertex.</li>
<li>kCC3VertexContentBoneIndices - automatically constructs a <a class="el" href="interface_c_c3_vertex_bone_indices.html" title="A CC3VertexArray that manages a collection of bone indices for each vertex. ">CC3VertexBoneIndices</a> instance in the vertexBoneIndices property, that holds several GLubyte or GLushort values per vertex.</li>
<li>kCC3VertexContentPointSize - automatically constructs a <a class="el" href="interface_c_c3_vertex_point_sizes.html" title="A CC3VertexArray that manages the point sizes aspect of an array of point sprite vertices. ">CC3VertexPointSizes</a> instance in the vertexPointSizes property, that holds one GLfloat per vertex.</li>
</ul>
<p>This property is a convenience property. Instead of using this property, you can create the appropriate vertex arrays in those properties directly.</p>
<p>The vertex arrays constructed by this property will be configured to use interleaved data if the shouldInterleaveVertices property is set to YES. You should ensure the value of the shouldInterleaveVertices property to the desired value before setting the value of this property. The initial value of the shouldInterleaveVertices property is YES.</p>
<p>If the content is interleaved, for each vertex, the content is held in the structures identified in the list above, in the order that they appear in the list. You can use this consistent organization to create an enclosing structure to access all data for a single vertex, if it makes it easier to access vertex content that way. If vertex content is not specified, it is simply absent, and the content from the following type will be concatenated directly to the content from the previous type.</p>
<p>For instance, in a typical textured and illuminated mesh, you might not require per-vertex color, tangent and bitangent content. You would therefore omit the kCC3VertexContentColor, kCC3VertexContentTangent and kCC3VertexContentBitangent values in the bitmask when setting this property, and the resulting structure for each vertex would be a location <a class="el" href="struct_c_c3_vector.html" title="A vector in 3D space. ">CC3Vector</a>, followed by a normal <a class="el" href="struct_c_c3_vector.html" title="A vector in 3D space. ">CC3Vector</a>, followed immediately by a texture coordinate ccTex2F. You can then define an enclosing structure to hold and manage all content for a single vertex. In this particular example, this is already done for you with the <a class="el" href="struct_c_c3_textured_vertex.html" title="Defines a simple vertex, containing location, normal, and texture coordinate data. ">CC3TexturedVertex</a> structure.</p>
<p>You can declare and use such a custom vertex structure even if you have constructed the vertex arrays directly, without using this property. The structure of the content of a single vertex is the same in either case.</p>
<p>The vertex arrays created by this property cover the most common use cases and data formats. If you require more customized vertex arrays, you can use this property to create the typical vertex arrays, and then customize them, by accessing the vertex arrays individually through their respective properties. After doing so, if the vertex content is interleaved, you should invoke the updateVertexStride method on this instance to automatically align the elementOffset and vertexStride properties of all of the contained vertex arrays. After setting this property, you do not need to invoke the updateVertexStride method unless you subsequently make changes to the constructed vertex arrays.</p>
<p>It is safe to set this property more than once. Doing so will remove any existing vertex arrays and replace them with those indicated by this property.</p>
<p>When reading this property, the appropriate bitwise-OR values are returned, corresponding to the contained vertex arrays, even if those arrays were constructed directly, instead of by setting this property. If this mesh contains no vertex arrays, this property will return kCC3VertexContentNone. </p>

</div>
</div>
<a class="anchor" id="a90c40ec899a167c70a246cbe6b764f9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the number of vertices in this mesh. </p>
<p>Usually, you should treat this property as read-only. However, there may be occasions with meshes that contain dynamic content, such as particle systems, where it may be appropriate to set the value of this property.</p>
<p>Setting the value of this property changes the amount of vertex content that will be submitted to the GL engine during drawing.</p>
<p>When setting this property, care should be taken to ensure that the value is not set larger than the number of vertices that were allocated for this mesh. </p>

</div>
</div>
<a class="anchor" id="ac55a9dd79522edbd8e9cb5e3b0207abc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexIndexCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If indexed drawing is used by this mesh, indicates the number of vertex indices in the mesh. </p>
<p>If indexed drawing is not used by this mesh, this property has no effect, and reading it will return zero.</p>
<p>Usually, you should treat this property as read-only. However, there may be occasions with meshes that contain dynamic content, such as particle systems, where it may be appropriate to set the value of this property.</p>
<p>Setting the value of this property changes the amount of vertex content that will be submitted to the GL engine during drawing.</p>
<p>When setting this property, care should be taken to ensure that the value is not set larger than the number of vertices that were allocated for this mesh. </p>

</div>
</div>
<a class="anchor" id="a72231ba14ef8b065704fec46b1e6fe61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_indices.html">CC3VertexIndices</a>*) vertexIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertex array instance managing the index content for the vertices. </p>
<p>Setting this property is optional. If vertex index data is not provided, the vertices will be drawn in linear order as they appear in the vertexLocations property. </p>

</div>
</div>
<a class="anchor" id="a4129889b4359efd94392c13e9e7b8496"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_locations.html">CC3VertexLocations</a>*) vertexLocations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertex array instance managing the positional content for the vertices. </p>

</div>
</div>
<a class="anchor" id="a759320925da536ec2fe39195bac3fe91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_normals.html">CC3VertexNormals</a>*) vertexNormals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertex array instance managing the normal content for the vertices. </p>
<p>Setting this property is optional. Not all meshes require normals. </p>

</div>
</div>
<a class="anchor" id="a9b308254ced0f1f2c53dc49c0ffd99df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_point_sizes.html">CC3VertexPointSizes</a>*) vertexPointSizes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertex array instance managing a point size for each vertex. </p>
<p>Setting this property is optional. It is used for point particle systems, and even then, particle systems often do not require individual sizing for each particle. </p>

</div>
</div>
<a class="anchor" id="a1b467f2d94b7aaa44430e4fca87f9fb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexStride</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bytes used by the content of each vertex. </p>
<p>The value of this property is calculated each time it is read, by accumulating the values of the elementLength property of each enclosed vertex array. If this instance contains no vertex arrays, this property will return zero.</p>
<p>If the shouldInterleaveVertices property is set to YES, setting this property will set the same value in all enclosed vertex arrays. If the shouldInterleaveVertices property is set to NO, setting this property has no effect.</p>
<p>The initial value of this property is the same as the value of the elementLength property. </p>

</div>
</div>
<a class="anchor" id="a6e6d7fc3c5612df7fd66c3fef041ec8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_tangents.html">CC3VertexTangents</a>*) vertexTangents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertex array instance managing the tangent content for the vertices. </p>
<p>Setting this property is optional. Not all meshes require tangents. </p>

</div>
</div>
<a class="anchor" id="a6b82f5b33a840a8149e7cbfda3c0c14f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_texture_coordinates.html">CC3VertexTextureCoordinates</a>*) vertexTextureCoordinates</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertex array instance managing the texture mapping content for the vertices. </p>
<p>Setting this property is optional. Not all meshes use textures.</p>
<p>If multi-texturing is used, and separate texture coordinate mapping is required for each texture unit, additional texture coordinate arrays can be added using the addTextureCoordinates: method. If this property has not been set already, the first texture coordinate array that is added via addTextureCoordinates: will be placed in this property. This can simplify configurations in that all texture coordinate arrays can be treated the same. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_c_c3_mesh_8h.html">CC3Mesh.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<address class="footer">
<p class="footer"/>© 2010 - 2014 The Brenwill Workshop Ltd.</p>
</address>
</body>
</html>
