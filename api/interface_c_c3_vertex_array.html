<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Cocos3D: Cocos3D API reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-cocos3d.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">
	   <a href="http://cocos3d.org"><img src="http://cocos3d.org/images/cocos3d-Banner-55h.png" /></a>
	   <span id="projectnumber">v2.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="#pub-static-methods">Class Methods</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_c_c3_vertex_array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CC3VertexArray Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#import &lt;CC3VertexArrays.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3VertexArray:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_vertex_array__inherit__graph.png" border="0" usemap="#_c_c3_vertex_array_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_vertex_array_inherit__map" id="_c_c3_vertex_array_inherit__map">
<area shape="rect" id="node8" href="interface_c_c3_drawable_vertex_array.html" title="This abstract subclass of CC3VertexArray adds the functionality to draw the vertex content to the dis..." alt="" coords="823,31,999,57"/><area shape="rect" id="node11" href="interface_c_c3_vertex_bone_indices.html" title="A CC3VertexArray that manages a collection of bone indices for each vertex. " alt="" coords="831,81,991,108"/><area shape="rect" id="node12" href="interface_c_c3_vertex_bone_weights.html" title="A CC3VertexArray that manages a collection of bone weights for each vertex. " alt="" coords="827,132,994,159"/><area shape="rect" id="node13" href="interface_c_c3_vertex_colors.html" title="A CC3VertexArray that manages the per&#45;vertex color aspect of an array of vertices. " alt="" coords="848,183,973,209"/><area shape="rect" id="node14" href="interface_c_c3_vertex_normals.html" title="A CC3VertexArray that manages the normal aspect of an array of vertices. " alt="" coords="842,233,979,260"/><area shape="rect" id="node15" href="interface_c_c3_vertex_point_sizes.html" title="A CC3VertexArray that manages the point sizes aspect of an array of point sprite vertices. " alt="" coords="835,284,986,311"/><area shape="rect" id="node16" href="interface_c_c3_vertex_tangents.html" title="A CC3VertexArray that manages the tangent or bitangent aspect of an array of vertices. " alt="" coords="839,335,982,361"/><area shape="rect" id="node17" href="interface_c_c3_vertex_texture_coordinates.html" title="A CC3VertexArray that manages the texture coordinates aspect of an array of vertices. " alt="" coords="809,385,1013,412"/><area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="478,208,591,235"/><area shape="rect" id="node4" href="protocol_c_c3_cacheable-p.html" title="Defines the behaviour required for an object that can be held in a cache. " alt="" coords="301,208,429,235"/><area shape="rect" id="node5" href="protocol_c_c3_object-p.html" title="Extension to support Cocos3D functionality. " alt="" coords="150,208,253,235"/><area shape="rect" id="node9" href="interface_c_c3_vertex_indices.html" title="A CC3VertexArray that manages the drawing indices of an array of vertices. " alt="" coords="1069,5,1198,32"/><area shape="rect" id="node10" href="interface_c_c3_vertex_locations.html" title="A CC3VertexArray that manages the location aspect of an array of vertices. " alt="" coords="1061,56,1205,83"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:afce72de9b66374a791ef1f52513e2365"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#afce72de9b66374a791ef1f52513e2365">__deprecated</a></td></tr>
<tr class="separator:afce72de9b66374a791ef1f52513e2365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73475f15dc5619791a01a1d4db155de9"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a73475f15dc5619791a01a1d4db155de9">__deprecated</a></td></tr>
<tr class="separator:a73475f15dc5619791a01a1d4db155de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce72de9b66374a791ef1f52513e2365"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#afce72de9b66374a791ef1f52513e2365">__deprecated</a></td></tr>
<tr class="separator:afce72de9b66374a791ef1f52513e2365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08121bfc88d0643c6d54608e4ce119c"><td class="memItemLeft" align="right" valign="top">(GLvoid *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#ac08121bfc88d0643c6d54608e4ce119c">addressOfElement:</a></td></tr>
<tr class="separator:ac08121bfc88d0643c6d54608e4ce119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc60a3a6df5f7aaf046b03371d1e8797"><td class="memItemLeft" align="right" valign="top">(GLvoid *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#abc60a3a6df5f7aaf046b03371d1e8797">allocateElements:</a></td></tr>
<tr class="separator:abc60a3a6df5f7aaf046b03371d1e8797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac839476962c4d129596fe3e967e71169"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#ac839476962c4d129596fe3e967e71169">bindContentToAttributeAt:withVisitor:</a></td></tr>
<tr class="separator:ac839476962c4d129596fe3e967e71169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e362960bc883e421e767a726437947d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a3e362960bc883e421e767a726437947d">copyVertices:from:to:</a></td></tr>
<tr class="separator:a3e362960bc883e421e767a726437947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422e11911e0d967059c476b5d7a50fc7"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a422e11911e0d967059c476b5d7a50fc7">copyVertices:from:toAddress:</a></td></tr>
<tr class="separator:a422e11911e0d967059c476b5d7a50fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834bbe1b290b15193722133e4cb9f58b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a834bbe1b290b15193722133e4cb9f58b">copyVertices:fromAddress:to:</a></td></tr>
<tr class="separator:a834bbe1b290b15193722133e4cb9f58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe217bd65ee50dc33a070b9803142cf5"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#afe217bd65ee50dc33a070b9803142cf5">copyVertices:fromAddress:toAddress:</a></td></tr>
<tr class="separator:afe217bd65ee50dc33a070b9803142cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b837623f0311aa4ae96d237ba1621c7"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a2b837623f0311aa4ae96d237ba1621c7">createGLBuffer</a></td></tr>
<tr class="separator:a2b837623f0311aa4ae96d237ba1621c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d37942763061edb9e840b2435cfa127"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a9d37942763061edb9e840b2435cfa127">deleteGLBuffer</a></td></tr>
<tr class="separator:a9d37942763061edb9e840b2435cfa127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859471278c48dceb94a7669880e6dba3"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a859471278c48dceb94a7669880e6dba3">describeElements:</a></td></tr>
<tr class="separator:a859471278c48dceb94a7669880e6dba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8d5c0a8cd499884ee8bf9ef47e6275"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a5a8d5c0a8cd499884ee8bf9ef47e6275">describeElements:startingAt:</a></td></tr>
<tr class="separator:a5a8d5c0a8cd499884ee8bf9ef47e6275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31116aea140b00569508a7130d02030e"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a31116aea140b00569508a7130d02030e">describeVertices</a></td></tr>
<tr class="separator:a31116aea140b00569508a7130d02030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f65f1eae0328aa583da2fe9d0e0e1d6"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a6f65f1eae0328aa583da2fe9d0e0e1d6">describeVertices:</a></td></tr>
<tr class="separator:a6f65f1eae0328aa583da2fe9d0e0e1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95336ef0316dfb8dd60819831fc6b1f5"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a95336ef0316dfb8dd60819831fc6b1f5">describeVertices:startingAt:</a></td></tr>
<tr class="separator:a95336ef0316dfb8dd60819831fc6b1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307c422ebe22b80be2c8d31a04222df9"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a307c422ebe22b80be2c8d31a04222df9">ensureCapacity:</a></td></tr>
<tr class="separator:a307c422ebe22b80be2c8d31a04222df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d9bd2a907d45c55a63d407f9f162f7"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a50d9bd2a907d45c55a63d407f9f162f7">initFromCPODData:fromSPODMesh:</a></td></tr>
<tr class="separator:a50d9bd2a907d45c55a63d407f9f162f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f5d58b1d763e4961644ecd64d73024"><td class="memItemLeft" align="right" valign="top">(GLvoid *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a86f5d58b1d763e4961644ecd64d73024">interleaveWith:</a></td></tr>
<tr class="separator:a86f5d58b1d763e4961644ecd64d73024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c224913c328682a4dcc17c496fa5f38"><td class="memItemLeft" align="right" valign="top">(GLvoid *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a9c224913c328682a4dcc17c496fa5f38">interleaveWith:usingOffset:</a></td></tr>
<tr class="separator:a9c224913c328682a4dcc17c496fa5f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15812d11bdd7894146ab7e1d74c74b2e"><td class="memItemLeft" align="right" valign="top">(GLvoid *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a15812d11bdd7894146ab7e1d74c74b2e">reallocateElements:</a></td></tr>
<tr class="separator:a15812d11bdd7894146ab7e1d74c74b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1868836bb7ca3ef466550b2e0620f679"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a1868836bb7ca3ef466550b2e0620f679">releaseRedundantContent</a></td></tr>
<tr class="separator:a1868836bb7ca3ef466550b2e0620f679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523216f26f2445d7d77aa7dfb2743909"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a523216f26f2445d7d77aa7dfb2743909">updateGLBuffer</a></td></tr>
<tr class="separator:a523216f26f2445d7d77aa7dfb2743909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bfbadcaa0981c256ab6e01c56fa1f5"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_vertex_array.html#a31bfbadcaa0981c256ab6e01c56fa1f5">updateGLBufferStartingAt:forLength:</a></td></tr>
<tr class="separator:a31bfbadcaa0981c256ab6e01c56fa1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Instance Methods inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:ac177c497bf19de1f8208eb375edfef37 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#ac177c497bf19de1f8208eb375edfef37">copy</a></td></tr>
<tr class="separator:ac177c497bf19de1f8208eb375edfef37 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6048039af7b953470a6be1640f3f8fa8 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a6048039af7b953470a6be1640f3f8fa8">copyAsClass:</a></td></tr>
<tr class="separator:a6048039af7b953470a6be1640f3f8fa8 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba6f6333ec6b859b17394fa95a549f1 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aaba6f6333ec6b859b17394fa95a549f1">copyUserDataFrom:</a></td></tr>
<tr class="separator:aaba6f6333ec6b859b17394fa95a549f1 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc25bb52f8f0815c0985e02aeac0e35 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a2fc25bb52f8f0815c0985e02aeac0e35">copyWithName:</a></td></tr>
<tr class="separator:a2fc25bb52f8f0815c0985e02aeac0e35 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3b74491add447b79ad63f7f9912b9e inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aff3b74491add447b79ad63f7f9912b9e">copyWithName:asClass:</a></td></tr>
<tr class="separator:aff3b74491add447b79ad63f7f9912b9e inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5698b73dad043a09dd57c19290c1dcf inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aa5698b73dad043a09dd57c19290c1dcf">copyWithZone:withName:</a></td></tr>
<tr class="separator:aa5698b73dad043a09dd57c19290c1dcf inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6788277bbfff67ed111f2392db9f685a inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a6788277bbfff67ed111f2392db9f685a">copyWithZone:withName:asClass:</a></td></tr>
<tr class="separator:a6788277bbfff67ed111f2392db9f685a inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c7dcbb20dd8712720519d0d0c2410b inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#ae9c7dcbb20dd8712720519d0d0c2410b">deriveNameFrom:</a></td></tr>
<tr class="separator:ae9c7dcbb20dd8712720519d0d0c2410b inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60ad034ddbb26e568589c5254c12bff inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aa60ad034ddbb26e568589c5254c12bff">deriveNameFrom:usingSuffix:</a></td></tr>
<tr class="separator:aa60ad034ddbb26e568589c5254c12bff inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84be89f3c9397c4247d406009137b5d inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#af84be89f3c9397c4247d406009137b5d">fullDescription</a></td></tr>
<tr class="separator:af84be89f3c9397c4247d406009137b5d inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51802b824fd430e3281e22574f1266ed inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a51802b824fd430e3281e22574f1266ed">init</a></td></tr>
<tr class="separator:a51802b824fd430e3281e22574f1266ed inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf728516905642fd71b913636fab13c0 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#adf728516905642fd71b913636fab13c0">initAtIndex:fromPODResource:</a></td></tr>
<tr class="separator:adf728516905642fd71b913636fab13c0 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096bc5294d2cc78dd979782504456569 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a096bc5294d2cc78dd979782504456569">initUserData</a></td></tr>
<tr class="separator:a096bc5294d2cc78dd979782504456569 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc220d9cffa20a01ecebefa44a44f354 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#afc220d9cffa20a01ecebefa44a44f354">initWithName:</a></td></tr>
<tr class="separator:afc220d9cffa20a01ecebefa44a44f354 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d154e055437d2e0ba9e707a69e3ec0 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#af7d154e055437d2e0ba9e707a69e3ec0">initWithTag:</a></td></tr>
<tr class="separator:af7d154e055437d2e0ba9e707a69e3ec0 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e0ab825fd6f3e9a703d28039c98886 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a36e0ab825fd6f3e9a703d28039c98886">initWithTag:withName:</a></td></tr>
<tr class="separator:a36e0ab825fd6f3e9a703d28039c98886 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30472ca8359ea9480479ed8301a93eb8 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a30472ca8359ea9480479ed8301a93eb8">nextTag</a></td></tr>
<tr class="separator:a30472ca8359ea9480479ed8301a93eb8 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b647607269d0c6bce0d69459d4b7dea inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a5b647607269d0c6bce0d69459d4b7dea">populateFrom:</a></td></tr>
<tr class="separator:a5b647607269d0c6bce0d69459d4b7dea inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Class Methods</h2></td></tr>
<tr class="memitem:abd82c7cf034e979151dd64c929eedf01"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_vertex_array.html#abd82c7cf034e979151dd64c929eedf01">arrayFromCPODData:fromSPODMesh:</a></td></tr>
<tr class="separator:abd82c7cf034e979151dd64c929eedf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43835197908474e8013c6989fb423303"><td class="memItemLeft" align="right" valign="top">(GLenum)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_vertex_array.html#a43835197908474e8013c6989fb423303">defaultSemantic</a></td></tr>
<tr class="separator:a43835197908474e8013c6989fb423303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d91c9e3248eb0a35117dcb8fda01e5"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_vertex_array.html#af2d91c9e3248eb0a35117dcb8fda01e5">vertexArray</a></td></tr>
<tr class="separator:af2d91c9e3248eb0a35117dcb8fda01e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa8b3c366b0778c5de69b3141869aa9"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_vertex_array.html#a0aa8b3c366b0778c5de69b3141869aa9">vertexArrayWithName:</a></td></tr>
<tr class="separator:a0aa8b3c366b0778c5de69b3141869aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8e76de5f48794068b4f4cfedc1d02c"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_vertex_array.html#a9a8e76de5f48794068b4f4cfedc1d02c">vertexArrayWithTag:</a></td></tr>
<tr class="separator:a9a8e76de5f48794068b4f4cfedc1d02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8d3ddfc39938f055af9a259435da22"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_vertex_array.html#ada8d3ddfc39938f055af9a259435da22">vertexArrayWithTag:withName:</a></td></tr>
<tr class="separator:ada8d3ddfc39938f055af9a259435da22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Class Methods inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:a13ae00555f231e938fcfed31769b8fef inherit pub_static_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(GLint)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_identifiable.html#a13ae00555f231e938fcfed31769b8fef">instanceCount</a></td></tr>
<tr class="separator:a13ae00555f231e938fcfed31769b8fef inherit pub_static_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb2e642c739adb8e0a70f98cf1bfcde inherit pub_static_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_identifiable.html#a0eb2e642c739adb8e0a70f98cf1bfcde">resetTagAllocation</a></td></tr>
<tr class="separator:a0eb2e642c739adb8e0a70f98cf1bfcde inherit pub_static_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a4639c4c7720878b13221adf4e24d47cd"><td class="memItemLeft" align="right" valign="top">GLvoid *elements&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a4639c4c7720878b13221adf4e24d47cd">__deprecated</a></td></tr>
<tr class="separator:a4639c4c7720878b13221adf4e24d47cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6fc86d22a0843b279f2300143e6aec"><td class="memItemLeft" align="right" valign="top">GLuint elementCount&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a1c6fc86d22a0843b279f2300143e6aec">__deprecated</a></td></tr>
<tr class="separator:a1c6fc86d22a0843b279f2300143e6aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c6bde9852a8d7b6489367bfc72cb64"><td class="memItemLeft" align="right" valign="top">GLuint elementStride&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a65c6bde9852a8d7b6489367bfc72cb64">__deprecated</a></td></tr>
<tr class="separator:a65c6bde9852a8d7b6489367bfc72cb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e71173daa0c8db96fb593841a4abd8b"><td class="memItemLeft" align="right" valign="top">GLfloat capacityExpansionFactor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a8e71173daa0c8db96fb593841a4abd8b">__deprecated</a></td></tr>
<tr class="separator:a8e71173daa0c8db96fb593841a4abd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab762185962cb79732e6536881a36287a"><td class="memItemLeft" align="right" valign="top">BOOL shouldReleaseRedundantData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#ab762185962cb79732e6536881a36287a">__deprecated</a></td></tr>
<tr class="separator:ab762185962cb79732e6536881a36287a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a393bff4dfd679e29bded6d220b7893"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a0a393bff4dfd679e29bded6d220b7893">allocatedVertexCapacity</a></td></tr>
<tr class="separator:a0a393bff4dfd679e29bded6d220b7893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f149c521086bd292fb8e623986fa1f5"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a5f149c521086bd292fb8e623986fa1f5">bufferID</a></td></tr>
<tr class="separator:a5f149c521086bd292fb8e623986fa1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bb7095577ea63c833c2394800f7c2c"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a44bb7095577ea63c833c2394800f7c2c">bufferTarget</a></td></tr>
<tr class="separator:a44bb7095577ea63c833c2394800f7c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada83be4106cb3e5142660ce8fb9b659"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#aada83be4106cb3e5142660ce8fb9b659">bufferUsage</a></td></tr>
<tr class="separator:aada83be4106cb3e5142660ce8fb9b659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be0403d4b56731fb36fdb9b717a8d00"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a5be0403d4b56731fb36fdb9b717a8d00">elementLength</a></td></tr>
<tr class="separator:a5be0403d4b56731fb36fdb9b717a8d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fbc055d207e6cbd4cc1b871d7c8682"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a74fbc055d207e6cbd4cc1b871d7c8682">elementOffset</a></td></tr>
<tr class="separator:a74fbc055d207e6cbd4cc1b871d7c8682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2513170e3be6dcae78a8d3a0905683e1"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a2513170e3be6dcae78a8d3a0905683e1">elementSize</a></td></tr>
<tr class="separator:a2513170e3be6dcae78a8d3a0905683e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0585afe3cd645ef4443bb296be440d4d"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a0585afe3cd645ef4443bb296be440d4d">elementType</a></td></tr>
<tr class="separator:a0585afe3cd645ef4443bb296be440d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025e9bc48468966fab6b03058ae217ee"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a025e9bc48468966fab6b03058ae217ee">isUsingGLBuffer</a></td></tr>
<tr class="separator:a025e9bc48468966fab6b03058ae217ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b59fe54f5e5fa736d691b12ec45118a"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a5b59fe54f5e5fa736d691b12ec45118a">semantic</a></td></tr>
<tr class="separator:a5b59fe54f5e5fa736d691b12ec45118a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a2cb56553c8f4cff1557372174d57e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#ab1a2cb56553c8f4cff1557372174d57e">shouldAllowVertexBuffering</a></td></tr>
<tr class="separator:ab1a2cb56553c8f4cff1557372174d57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29a42e0cc84fc6a13a1b283b884dccb"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#ac29a42e0cc84fc6a13a1b283b884dccb">shouldNormalizeContent</a></td></tr>
<tr class="separator:ac29a42e0cc84fc6a13a1b283b884dccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8cbcd8a7373d72e955cd30a1ee1e6b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a5d8cbcd8a7373d72e955cd30a1ee1e6b">shouldReleaseRedundantContent</a></td></tr>
<tr class="separator:a5d8cbcd8a7373d72e955cd30a1ee1e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10cfdce4e79f0f0d7f9a1ea84b6bfa2"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#aa10cfdce4e79f0f0d7f9a1ea84b6bfa2">vertexCount</a></td></tr>
<tr class="separator:aa10cfdce4e79f0f0d7f9a1ea84b6bfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5555d24364fbad11458aad6c672d0e48"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a5555d24364fbad11458aad6c672d0e48">vertexStride</a></td></tr>
<tr class="separator:a5555d24364fbad11458aad6c672d0e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6247d2c9b06be109afcba2b8d3c3c0f3"><td class="memItemLeft" align="right" valign="top">GLvoid *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a6247d2c9b06be109afcba2b8d3c3c0f3">vertices</a></td></tr>
<tr class="separator:a6247d2c9b06be109afcba2b8d3c3c0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('properties_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:af603104494fba5d4791f720823528f9d inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSObject *sharedUserData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#af603104494fba5d4791f720823528f9d">__deprecated</a></td></tr>
<tr class="separator:af603104494fba5d4791f720823528f9d inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cccaa59a3f724bff77683237e271b6 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#ac8cccaa59a3f724bff77683237e271b6">name</a></td></tr>
<tr class="separator:ac8cccaa59a3f724bff77683237e271b6 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deeaefbf8e9fdc758bace96cb88b716 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a2deeaefbf8e9fdc758bace96cb88b716">nameSuffix</a></td></tr>
<tr class="separator:a2deeaefbf8e9fdc758bace96cb88b716 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93489bf1874209effdcb78761e7e3480 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a93489bf1874209effdcb78761e7e3480">podIndex</a></td></tr>
<tr class="separator:a93489bf1874209effdcb78761e7e3480 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65202edca1a66ef060b5b0411cb547c3 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a65202edca1a66ef060b5b0411cb547c3">shouldIncludeInDeepCopy</a></td></tr>
<tr class="separator:a65202edca1a66ef060b5b0411cb547c3 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe2d1079602a9b93e1803b5d8aefdcc inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a4fe2d1079602a9b93e1803b5d8aefdcc">tag</a></td></tr>
<tr class="separator:a4fe2d1079602a9b93e1803b5d8aefdcc inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82555dcf853eeb9fcdcc5fae1c1fcd5c inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a82555dcf853eeb9fcdcc5fae1c1fcd5c">userData</a></td></tr>
<tr class="separator:a82555dcf853eeb9fcdcc5fae1c1fcd5c inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_protocol_c_c3_cacheable-p"><td colspan="2" onclick="javascript:toggleInherit('properties_protocol_c_c3_cacheable-p')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="protocol_c_c3_cacheable-p.html">&lt;CC3Cacheable&gt;</a></td></tr>
<tr class="memitem:af3f0574df825aa03a7b7646918212512 inherit properties_protocol_c_c3_cacheable-p"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_c_c3_cacheable-p.html#af3f0574df825aa03a7b7646918212512">name</a></td></tr>
<tr class="separator:af3f0574df825aa03a7b7646918212512 inherit properties_protocol_c_c3_cacheable-p"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> manages the content associated with an aspect of a vertex. </p>
<p><a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> is an abstract implementation, and there are several sublcasses, each specialized to manage the vertex content for a different vertex aspect (locations, normals, colors, texture mapping, indices...).</p>
<p>Each instance of a subclass of <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> maintains a reference to the underlying vertex content in memory, along with various parameters describing the underlying content, such as its type, element size, stride, etc.</p>
<p>The underlying content can be interleaved and shared by several <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> subclasses, each looking at a different aspect of the content for each vertex. In this case, the vertices property of each of those vertex array instances will reference the same underlying content memory, and the elementOffset property of each <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> instance will indicate at which offset in each vertex content the datum of interest to that instance is located.</p>
<p>The <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> instance also manages buffering the content to the GL engine, including loading it into a server-side GL vertex buffer object (VBO) if desired. Once loaded into the GL engine buffers, the underlying content can be released from the <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> instance, thereby freeing memory, by using the releaseRedundantContent method.</p>
<p>The <a class="el" href="interface_c_c3_drawable_vertex_array.html" title="This abstract subclass of CC3VertexArray adds the functionality to draw the vertex content to the dis...">CC3DrawableVertexArray</a> abstract subclass adds the functionality to draw the vertex content to the display through the GL engine.</p>
<p>When drawing the vertices to the GL engine, each subclass remembers which vertices were last drawn, and only binds the vertices to the GL engine when a different set of vertices of the same type are drawn. This allows the application to organize the CC3MeshNodes within the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> so that nodes using the same mesh vertices are drawn together, before moving on to other meshes. This strategy can minimize the number of vertex pointer switches in the GL engine, which improves performance.</p>
<p>Vertex arrays support the <a class="el" href="class_n_s_copying-p.html">NSCopying</a> protocol, but in normal operation, the need to create copies of vertex arrays is rare.</p>
<p>By default, when a mesh node is copied, it does not make a separate copy of its model. Both the original and the copy make use of the same mesh instance. Similarly, when a mesh is copied, it does not make separate copies of its vertex arrays. Instead, both the original and the copy make use of the same vertex array instances.</p>
<p>However, in some cases, such as populating a mesh from a template and then manipulating the contents of each resulting mesh individually, creating copies of vertex arrays can be useful.</p>
<p>If you do find need to create a copy of a vertex array, you can do so by invoking the copy method. However, you should take care to understand several points about copying vertex arrays:</p>
<ul>
<li>Copying a vertex array creates a full copy of the vertex content. This may consume significant memory.</li>
<li>The vertex content is copied for each vertex array copy. If several vertex arrays share interleaved content, multiple copies of that content will be created. This is almost never what you intend to do, and results in significant redundant content in memory. Instead, consider creating a copy of one of the vertex arrays, and then manually populating the others so that the interleaved vertex content can be shared.</li>
<li>If the value of the shouldReleaseRedundantContent property of the original vertex array is YES and releaseRedundantContent has been invoked, there will be no vertex content to be copied.</li>
<li>The new vertex array will not have a GL vertex buffer object associated with it. To buffer the vertex content of the new vertex array, invoke the createGLBuffer method on the new vertex array. </li>
</ul>
</div><h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="afce72de9b66374a791ef1f52513e2365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000079">Deprecated:</a></b></dt><dd>This functionality has been replaced by the allocatedVertexCapacity property. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_vertex_locations.html#a5c33a6c3a847f48bb755fe21d57c8eb9">CC3VertexLocations</a>.</p>

</div>
</div>
<a class="anchor" id="afce72de9b66374a791ef1f52513e2365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000083">Deprecated:</a></b></dt><dd>Renamed to releaseRedundantContent. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_vertex_locations.html#a5c33a6c3a847f48bb755fe21d57c8eb9">CC3VertexLocations</a>.</p>

</div>
</div>
<a class="anchor" id="a73475f15dc5619791a01a1d4db155de9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000084">Deprecated:</a></b></dt><dd>Renamed to describeVertices. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_vertex_locations.html#a5c33a6c3a847f48bb755fe21d57c8eb9">CC3VertexLocations</a>.</p>

</div>
</div>
<a class="anchor" id="ac08121bfc88d0643c6d54608e4ce119c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLvoid*) addressOfElement: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>index</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the element in the underlying content at the specified index. </p>
<p>The implementation takes into consideration the vertexStride and elementOffset properties to locate the aspect of interest in this instance.</p>
<p>If the releaseRedundantContent method has been invoked and the underlying vertex content has been released, or the index is beyond the vertexCount, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="abc60a3a6df5f7aaf046b03371d1e8797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLvoid*) allocateElements: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000077">Deprecated:</a></b></dt><dd>This functionality has been replaced by the allocatedVertexCapacity property. </dd></dl>

</div>
</div>
<a class="anchor" id="abd82c7cf034e979151dd64c929eedf01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) arrayFromCPODData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_p_v_r_foundation_8h.html#a65a1a1916860ff530310204c0470b2f6">PODClassPtr</a>)&#160;</td>
          <td class="paramname"><em>aCPODData</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromSPODMesh:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a>)&#160;</td>
          <td class="paramname"><em>aSPODMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initialize an autoreleased instance from the specified CPODData and SPODMesh structures. </p>

<p>Provided by category <a class="el" href="category_c_c3_vertex_array_07_p_v_r_p_o_d_08.html#abd82c7cf034e979151dd64c929eedf01">CC3VertexArray(PVRPOD)</a>.</p>

</div>
</div>
<a class="anchor" id="ac839476962c4d129596fe3e967e71169"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) bindContentToAttributeAt: </td>
          <td></td>
          <td class="paramtype">(GLint)&#160;</td>
          <td class="paramname"><em>vaIdx</em></td>
        </tr>
        <tr>
          <td class="paramkey">withVisitor:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the vertex content to the vertex attribute at the specified index in the GL engine. </p>
<p>This is invoked automatically from the <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> containing this instance. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a3e362960bc883e421e767a726437947d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyVertices: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">from:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>srcIdx</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>dstIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies vertex content for the specified number of vertices from memory starting at the specified source vertex index to memory starting at the specified destination vertex index. </p>
<p>You can use this method to copy content from one area in the vertex array to another area.</p>
<p>This is a fast straight memory copy, and assumes that vertex content is consecutive and is spaced as defined by the vertexStride property. If vertex content is interleaved, the content in between consecutive elements of this vertex array will also be copied. </p>

</div>
</div>
<a class="anchor" id="a422e11911e0d967059c476b5d7a50fc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyVertices: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">from:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>srcIdx</em></td>
        </tr>
        <tr>
          <td class="paramkey">toAddress:</td>
          <td></td>
          <td class="paramtype">(GLvoid *)&#160;</td>
          <td class="paramname"><em>dstPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies vertex content for the specified number of vertices from memory starting at the specified source vertex index to memory starting at the specified destination address pointer. </p>
<p>You can use this method to copy content out of this vertex array to a memory location outside this vertex array.</p>
<p>This is a fast straight memory copy, assumes that vertex content is consecutive and is spaced as defined by the vertexStride property, and deposits the vertex content at the destination address in exactly the same format as in this vertex array. If vertex content is interleaved, the content in between consecutive elements of this vertex array will also be copied. </p>

</div>
</div>
<a class="anchor" id="a834bbe1b290b15193722133e4cb9f58b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyVertices: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromAddress:</td>
          <td></td>
          <td class="paramtype">(GLvoid *)&#160;</td>
          <td class="paramname"><em>srcPtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>dstIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies vertex content for the specified number of vertices from memory starting at the specified source address to memory starting at the specified destination vertex index. </p>
<p>You can use this method to copy content into this vertex array from a memory location outside this vertex array.</p>
<p>This is a fast straight memory copy, assumes that vertex content is consecutive is spaced as defined by the vertexStride property, and that the vertex content at the source address is structured identically to the content in this vertex array. If vertex content is interleaved, the content in between consecutive elements of this vertex array will also be copied. </p>

</div>
</div>
<a class="anchor" id="afe217bd65ee50dc33a070b9803142cf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) copyVertices: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromAddress:</td>
          <td></td>
          <td class="paramtype">(GLvoid *)&#160;</td>
          <td class="paramname"><em>srcPtr</em></td>
        </tr>
        <tr>
          <td class="paramkey">toAddress:</td>
          <td></td>
          <td class="paramtype">(GLvoid *)&#160;</td>
          <td class="paramname"><em>dstPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies vertex content for the specified number of vertices from memory starting at the specified source address to memory starting at the specified destination address. </p>
<p>You can use this method to copy content between two memory location outside this vertex array.</p>
<p>This is a fast straight memory copy, assumes that vertex content is consecutive and is spaced as defined by the vertexStride property, and that the vertex content at both the source and destination addresses are structured identically to the content of this vertex array. If vertex content is interleaved, the content in between consecutive elements of this vertex array will also be copied. </p>

</div>
</div>
<a class="anchor" id="a2b837623f0311aa4ae96d237ba1621c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) createGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the shouldAllowVertexBuffering property is set to YES, creates a vertex buffer object (VBO) within the GL engine, copies the content referenced by the vertices into the GL engine (which may make use of VRAM), and sets the value of the bufferID property to that of the new GL buffer. </p>
<p>If memory for the vertices was allocated via the allocatedVertexCapacity property, the GL VBO size is set to the same as the amount allocated by this instance. If memory was allocated externally, the GL VBO size is set to the value of vertexCount.</p>
<p>Calling this method is optional. Using GL engine buffers is more efficient than passing arrays on each GL draw call, but is optional. If you choose not to call this method, this instance will pass the mesh content properties to the GL engine on each draw call.</p>
<p>If the GL engine cannot allocate space for any of the buffers, this instance will revert to passing the array content for any unallocated buffer on each draw call.</p>
<p>When using interleaved content, this method should be invoked on only one of the CC3VertexArrays that share the content. The bufferID property of that instance should then be copied to the other vertex arrays.</p>
<p>Consider using the createGLBuffers of the mesh class instead of this method, which automatically handles the buffering all vertex arrays used by the mesh, and correctly coordinates buffering interleaved content.</p>
<p>It is safe to invoke this method more than once, but subsequent invocations will do nothing.</p>
<p>This method is invoked automatically by the createGLBuffers method of the mesh class, which also coordinates the invocations across multiple <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> instances when interleaved content is shared between them, along with the subsequent copying of the bufferID's. </p>

</div>
</div>
<a class="anchor" id="a43835197908474e8013c6989fb423303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (GLenum) defaultSemantic </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default value for the semantic property. </p>
<p>Each subclass will provide an appropriate value from the CC3VertexContentSemantic enumeration. </p>

</div>
</div>
<a class="anchor" id="a9d37942763061edb9e840b2435cfa127"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) deleteGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the GL engine buffers created with createGLBuffer. </p>
<p>After calling this method, if they have not been released by createGLBuffer, the vertex content will be passed to the GL engine on each subsequent draw operation. It is safe to call this method even if GL buffers have not been created.</p>
<p>This method may be invoked at any time to free up GL memory, but only if this vertex array will not be used again, or if the content was not released by releaseRedundantContent. This would be the case if the allocatedVertexCapacity property was not set.</p>
<p>This method is invoked automatically when this instance is deallocated. </p>

</div>
</div>
<a class="anchor" id="a859471278c48dceb94a7669880e6dba3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) describeElements: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000085">Deprecated:</a></b></dt><dd>Renamed to describeVertices:. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a8d5c0a8cd499884ee8bf9ef47e6275"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) <a class="el" href="interface_c_c3_vertex_array.html#a859471278c48dceb94a7669880e6dba3">describeElements:</a> </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">startingAt:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000086">Deprecated:</a></b></dt><dd>Renamed to describeVertices:startingAt:. </dd></dl>

</div>
</div>
<a class="anchor" id="a31116aea140b00569508a7130d02030e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) describeVertices </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing a description of the elements of this vertex array, with the contents of each element output on a different line. </p>
<p>The number of values output on each line is dictated by the elementSize property.</p>
<p>The output contains the all of the vertices in this vertex array. The total number of values output will therefore be (elementSize * vertexCount). </p>

</div>
</div>
<a class="anchor" id="a6f65f1eae0328aa583da2fe9d0e0e1d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) describeVertices: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing a description of the specified elements, with the contents of each element output on a different line. </p>
<p>The number of values output on each line is dictated by the elementSize property.</p>
<p>The output contains the number of elements specified, starting at the first element in this vertex array, and is limited to the number of vertices in this array. The total number of values output will therefore be (elementSize * MIN(vtxCount, vertexCount)). </p>

</div>
</div>
<a class="anchor" id="a95336ef0316dfb8dd60819831fc6b1f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) <a class="el" href="interface_c_c3_vertex_array.html#a6f65f1eae0328aa583da2fe9d0e0e1d6">describeVertices:</a> </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vtxCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">startingAt:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>startElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing a description of the specified elements, with the contents of each element output on a different line. </p>
<p>The number of values output on each line is dictated by the elementSize property.</p>
<p>The output contains the number of vertices specified, starting at the element at the specified index, and is limited to the number of vertices in this array. The total number of values output will therefore be (elementSize * MIN(vtxCount, vertexCount - startElem)). </p>

</div>
</div>
<a class="anchor" id="a307c422ebe22b80be2c8d31a04222df9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) ensureCapacity: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000080">Deprecated:</a></b></dt><dd>This functionality is now managed by the mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="a50d9bd2a907d45c55a63d407f9f162f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initFromCPODData: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_p_v_r_foundation_8h.html#a65a1a1916860ff530310204c0470b2f6">PODClassPtr</a>)&#160;</td>
          <td class="paramname"><em>aCPODData</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromSPODMesh:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a>)&#160;</td>
          <td class="paramname"><em>aSPODMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this instance from the specified CPODData and SPODMesh structures. </p>

<p>Provided by category <a class="el" href="category_c_c3_vertex_array_07_p_v_r_p_o_d_08.html#a50d9bd2a907d45c55a63d407f9f162f7">CC3VertexArray(PVRPOD)</a>.</p>

</div>
</div>
<a class="anchor" id="a86f5d58b1d763e4961644ecd64d73024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLvoid*) interleaveWith: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_vertex_array.html">CC3VertexArray</a> *)&#160;</td>
          <td class="paramname"><em>otherVtxArray</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure, or reconfigure, this vertex array to use the same underlying vertex content as the specified other vertex array, with the content used by this array interleaved with the content from the other vertex array. </p>
<p>This can be repeated with other arrays to interleave the content from several vertex arrays into one underlying memory buffer.</p>
<p>This is a convenience method that invokes the interleaveWith:usingOffset: method, passing the existing value of the elementOffset property of this vertex array for the elemOffset.</p>
<p>Returns a pointer to the vertices array, offset by the elementOffset of this vertex array. This is effectively a pointer to the first element in this vertex array, and can be used as a starting point to iterate the array to populate it.</p>
<p>This method assumes that the elementOffset property has already been set. The returned pointer will not be accurate if the elementOffset property has not been set already.</p>
<p>Because of this, when creating a new mesh containing several interleaved vertex arrays, it is better to use the interleaveWith:usingOffset: method. This method is useful when changing the vertex capacity of the mesh, and you want to retain the existing elementCount property of each vertex array. </p>

</div>
</div>
<a class="anchor" id="a9c224913c328682a4dcc17c496fa5f38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLvoid*) <a class="el" href="interface_c_c3_vertex_array.html#a86f5d58b1d763e4961644ecd64d73024">interleaveWith:</a> </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_vertex_array.html">CC3VertexArray</a> *)&#160;</td>
          <td class="paramname"><em>otherVtxArray</em></td>
        </tr>
        <tr>
          <td class="paramkey">usingOffset:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>elemOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure this vertex array to use the same underlying vertex content as the specified other vertex array, with the content used by this array interleaved with the content from the other vertex array. </p>
<p>This can be repeated with other arrays to interleave the content from several vertex arrays into one underlying memory buffer.</p>
<p>This is a convenience method that sets the vertices, vertexStride, and vertexCount properties of this vertex array to be the same as those of the other vertex array, and then sets the elementOffset property of this vertex array to the specified elemOffset value.</p>
<p>Returns a pointer to the vertices array, offset by the elemOffset. This is effectively a pointer to the first element in this vertex array, and can be used as a starting point to iterate the array to populate it. </p>

</div>
</div>
<a class="anchor" id="a15812d11bdd7894146ab7e1d74c74b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLvoid*) reallocateElements: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000078">Deprecated:</a></b></dt><dd>This functionality has been replaced by the allocatedVertexCapacity property. </dd></dl>

</div>
</div>
<a class="anchor" id="a1868836bb7ca3ef466550b2e0620f679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) releaseRedundantContent </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Once the vertices content has been buffered into a GL vertex buffer object (VBO) within the GL engine, via the createGLBuffer method, this method can be used to release the content in main memory that is now redundant. </p>
<p>If the shouldReleaseRedundantContent property is set to NO, or if the vertices content has not been successfully buffered to a VBO in the GL engine. this method does nothing. It is safe to invokde this method even if createGLBuffer has not been invoked, and even if VBO buffering was unsuccessful.</p>
<p>Typically, this method is not invoked directly by the application. Instead, consider using the same method on a node assembly in order to release as much memory as possible in one simply method invocation.</p>
<p>Subclasses may extend this behaviour to remove content loaded, for example, from files, but should ensure that content is only released if bufferId is valid (not zero), and the shouldReleaseRedundantContent property is set to YES. </p>

</div>
</div>
<a class="anchor" id="a523216f26f2445d7d77aa7dfb2743909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateGLBuffer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with all of the element content contained in this array. </p>

</div>
</div>
<a class="anchor" id="a31bfbadcaa0981c256ab6e01c56fa1f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateGLBufferStartingAt: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>offsetIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">forLength:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the GL engine buffer with the element content contained in this array, starting at the vertex at the specified offsetIndex, and extending for the specified number of vertices. </p>

</div>
</div>
<a class="anchor" id="af2d91c9e3248eb0a35117dcb8fda01e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) vertexArray </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased unnamed instance with an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="a0aa8b3c366b0778c5de69b3141869aa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) vertexArrayWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aName</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified name and an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="a9a8e76de5f48794068b4f4cfedc1d02c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) vertexArrayWithTag: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>aTag</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an unnamed autoreleased instance with the specified tag. </p>

</div>
</div>
<a class="anchor" id="ada8d3ddfc39938f055af9a259435da22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) <a class="el" href="interface_c_c3_vertex_array.html#a9a8e76de5f48794068b4f4cfedc1d02c">vertexArrayWithTag:</a> </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>aTag</em></td>
        </tr>
        <tr>
          <td class="paramkey">withName:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified tag and name. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a4639c4c7720878b13221adf4e24d47cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLvoid* elements) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000074">Deprecated:</a></b></dt><dd>Renamed to vertices. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c6fc86d22a0843b279f2300143e6aec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint elementCount) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000075">Deprecated:</a></b></dt><dd>Renamed to vertexCount. </dd></dl>

</div>
</div>
<a class="anchor" id="a65c6bde9852a8d7b6489367bfc72cb64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint elementStride) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000076">Deprecated:</a></b></dt><dd>Renamed to vertexStride. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e71173daa0c8db96fb593841a4abd8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat capacityExpansionFactor) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated:</a></b></dt><dd>This property is no longer used, and is fixed at 1.25. </dd></dl>

</div>
</div>
<a class="anchor" id="ab762185962cb79732e6536881a36287a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL shouldReleaseRedundantData) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000082">Deprecated:</a></b></dt><dd>Renamed to shouldReleaseRedundantContent. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a393bff4dfd679e29bded6d220b7893"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) allocatedVertexCapacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates, reallocates, or deallocates underlying memory for the specified number of vertices, taking into consideration the amount of memory required by each vertex. </p>
<p>Specifically, the total amount of memory allocated will be (allocatedVertexCapacity * self.vertexStride) bytes.</p>
<p>Setting this property affects the value of the vertices and vertexCount properties. After setting this property, the vertices property will point to the allocated memory, and the vertexCount property will be set to the same value as this property. After setting this property, if you will not be using all of the allocated vertices immediately, you should set the value of the vertexCount property to the actual number of vertices in use.</p>
<p>Use of this property is not required if the vertex content has already been loaded into memory by a file loader, or defined by a static array. In that situation, you should set the vertices and vertexCount properties directly, and avoid using this property.</p>
<p>Since memory allocation is dependent on the vertex stride, before setting this property, ensure that the vertexStride, or elementSize and elementType properties have been set appropriately. If the underlying content is to be interleaved, set the value of the vertexStride property to the appropriate value before setting this property. If the underlying content will NOT be interleaved, the vertexStride property can be determined by the elementType and elementSize properties, and you should set the correct values of those two properties before setting the value of this property.</p>
<p>This property may be set repeatedly to manage the underlying mesh vertex content as a dynamically-sized array, growing and shrinking the allocated memory as needed. When doing so, keep in mind the vertices property can change as a result of any reallocation of memory.</p>
<p>In addition, you can set this property to zero to safely deallocate all memory used by the vertex content of this array. After setting this property to zero, the value of the vertices property will be a NULL pointer, and the value of the vertexCount property will be zero.</p>
<p>When setting the value of this property to a new non-zero value, all current vertex content, up to the lesser of the new and old values of this property, will be preserved. However, keep in mind that, if the memory allocation has increased, that vertex content may have been moved to a new location, resulting in a change to the vertices property.</p>
<p>If the value of this property is increased (including from zero on the first assignement), vertex content for those vertices beyond the old value of this property will be undefined, and must be populated by the application before attempting to draw that vertex content.</p>
<p>If you are not ready to populate the newly allocated vertex content yet, after setting the value of this property, you can set the value of the vertexCount property to a value less than the value of this property (including to zero) to stop such undefined vertex content from being drawn.</p>
<p>When interleaving content, this method should be invoked on only one of the <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> instances that are sharing the underlying content (typically the <a class="el" href="interface_c_c3_vertex_locations.html" title="A CC3VertexArray that manages the location aspect of an array of vertices. ">CC3VertexLocations</a> instance). After allocating on one <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> instances, set the vertices property of the other instances to be equal to the vertices property of the <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> instance on which this method was invoked (or just simply to the pointer returned by this method). </p>

</div>
</div>
<a class="anchor" id="a5f149c521086bd292fb8e623986fa1f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) bufferID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the underlying content has been loaded into a GL engine vertex buffer object, this property holds the ID of that GL buffer as provided by the GL engine when the createGLBuffer method was invoked. </p>
<p>If the createGLBuffer method was not invoked, and the underlying vertex was not loaded into a GL VBO, this property will be zero. </p>

</div>
</div>
<a class="anchor" id="a44bb7095577ea63c833c2394800f7c2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLenum) bufferTarget</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The GL engine buffer target. </p>
<p>Must be one of GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.</p>
<p>The default value is GL_ARRAY_BUFFER. Subclasses that manage index content will override. </p>

</div>
</div>
<a class="anchor" id="aada83be4106cb3e5142660ce8fb9b659"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLenum) bufferUsage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The GL engine buffer usage hint, used by the GL engine to arrange content for access when loading content into a server-side vertex buffer object. </p>
<p>The default value is GL_STATIC_DRAW, indicating to the GL engine that the content will generally not be re-accessed after loading. If you will be updating the content frequently, you can change this to GL_DYNAMIC_DRAW. </p>

</div>
</div>
<a class="anchor" id="a5be0403d4b56731fb36fdb9b717a8d00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) elementLength</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length, or size, of each individual element, measured in bytes. </p>
<p>The returned value is the result of multiplying the size of the content type identified by the elementType property, with the value of the elementSize property.</p>
<p>For example, if the elementType property is GL_FLOAT and the elementSize property is 3, this property will return (sizeof(GLfloat) * 3) = (4 * 3) = 12.</p>
<p>For non-interleaved content, the value of this property will be the same as the value of the vertexStride property. For interleaved content, the value of this property will be smaller than the value of the vertexStride property. </p>

</div>
</div>
<a class="anchor" id="a74fbc055d207e6cbd4cc1b871d7c8682"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) elementOffset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When using interleaved content, this property indicates the offset, within the content for a single vertex, at which the datum managed by this instance is located. </p>
<p>When content is not interleaved, and the vertices content is dedicated to this instance, this property will be zero.</p>
<p>The initial value is zero. </p>

</div>
</div>
<a class="anchor" id="a2513170e3be6dcae78a8d3a0905683e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLint) elementSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of components associated with each vertex in the underlying content. </p>
<p>As an example, the location of each vertex in 3D space is specified by three components (X,Y &amp; Z), so the value of this property in an instance tracking vertex locations would be three.</p>
<p>When allocating non-interleaved vertex memory, setting this property affects the amount of memory allocated by the allocatedVertexCapacity property. If this property is set after the allocatedVertexCapacity property has been set, vertex memory will be reallocated again. To avoid allocating twice, if you are not interleaving content, and you need to set this property, do so before setting the allocatedVertexCapacity property.</p>
<p>The initial value is three. Subclass may override this default. </p>

</div>
</div>
<a class="anchor" id="a0585afe3cd645ef4443bb296be440d4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLenum) elementType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of content associated with each component of a vertex. </p>
<p>This must be a valid enumerated GL content type suitable for the type of element.</p>
<p>When allocating non-interleaved vertex memory, setting this property affects the amount of memory allocated by the allocatedVertexCapacity property. If this property is set after the allocatedVertexCapacity property has been set, vertex memory will be reallocated again. To avoid allocating twice, if you are not interleaving content, and you need to set this property, do so before setting the allocatedVertexCapacity property.</p>
<p>The initial value is GL_FLOAT. </p>

</div>
</div>
<a class="anchor" id="a025e9bc48468966fab6b03058ae217ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isUsingGLBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the underlying vertex content has been loaded into a GL engine vertex buffer object. </p>
<p>Vertex buffer objects are engaged via the createGLBuffer method. </p>

</div>
</div>
<a class="anchor" id="a5b59fe54f5e5fa736d691b12ec45118a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLenum) semantic</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="interface_c_c3_vertex_array_content.html" title="CC3VertexArrayContent contains the vertex content data on behalf of a CC3VertexArray. ">CC3VertexArrayContent</a> instance that contains the vertex content data on behalf of this vertex array. </p>
<p>This property is set automatically when the vertex array is assigned to a mesh, or when the shouldInterleaveVertices property of the mesh is changed. Usually, the application never needs to access or set this property. Indicates the vertex attribute semantic of this array.</p>
<p>Under OpenGL ES 2, this values are used to match a vertex array to its semantic usage within a GLSL vertex shader.</p>
<p>The initial value of this property is set by from the defaultSemantic class property, which subclasses override to provide an appropriate semantic value from the CC3VertexContentSemantic enumeration, based on the vertex array type.</p>
<p>The app may change this property to a custom value if desired. The custom value should be kept within the range defined by kCC3SemanticAppBase and kCC3SemanticMax. </p>

</div>
</div>
<a class="anchor" id="ab1a2cb56553c8f4cff1557372174d57e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldAllowVertexBuffering</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this instance should allow the vertex content to be copied to a vertex buffer object within the GL engine when the createGLBuffer method is invoked. </p>
<p>The initial value of this property is YES. In most cases, this is appropriate, but for specific meshes, it might make sense to retain content in main memory and submit it to the GL engine during each frame rendering.</p>
<p>As an alternative to setting this property to NO, consider leaving it as YES, and making use of the updateGLBuffer and updateGLBufferStartingAt:forLength: to dynamically update the content in the GL engine buffer. Doing so permits the content to be copied to the GL engine only when it has changed, and permits copying only the range of content that has changed, both of which offer performance improvements over submitting all of the vertex content on each frame render. </p>

</div>
</div>
<a class="anchor" id="ac29a42e0cc84fc6a13a1b283b884dccb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldNormalizeContent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the vertex content should be normalized during drawing. </p>
<p>This property applies only to OpenGL ES 2. When using OpenGL ES 1, this property can be ignored.</p>
<p>Under OpenGL ES 2, vertex content that is provided in an integer format (eg. the elementType property is set to anything other than GL_FLOAT), this property indicates whether the element content should be normalized, by being divided by their maximum range, to convert them into floating point variables between 0 &amp; 1 (for unsigned integer types), or -1 &amp; +1 (for signed integer types).</p>
<p>If this property is set to YES, the element content will be normalized, otherwise it will be used as is. The normalization activity takes place in the GL engine.</p>
<p>The default value of this property is NO, indicating that the element content will not be normalized during drawing. </p>

</div>
</div>
<a class="anchor" id="a5d8cbcd8a7373d72e955cd30a1ee1e6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldReleaseRedundantContent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this instance should release the content held in the elments array when the releaseRedundantContent method is invoked. </p>
<p>The initial value of this property is YES. In most cases, this is appropriate, but in some circumstances it might make sense to retain some content (usually the vertex locations) in main memory for potantial use in collision detection, etc. </p>

</div>
</div>
<a class="anchor" id="aa10cfdce4e79f0f0d7f9a1ea84b6bfa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of vertices in the underlying content referenced by the vertices property. </p>
<p>The vertices property must point to an underlying memory space that is large enough to hold the amount of content specified by this property.</p>
<p>The initial value is zero.</p>
<p>Setting the value of the allocatedVertexCapacity property also sets the value of this property to the same value. After setting the allocatedVertexCapacity property, if you will not be using all of the allocated vertices immediately, you should set the value of this vertexCount property to the actual number of vertices in use. </p>

</div>
</div>
<a class="anchor" id="a5555d24364fbad11458aad6c672d0e48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexStride</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bytes between consecutive vertices for the vertex aspect being managed by this instance. </p>
<p>If the underlying content is not interleaved, and contains only the content managed by this instance, the value of this property will be the same as that of the elementLength property, and this property does not need to be set explicitly.</p>
<p>If the underlying content is interleaved and contains content for several vertex aspects (location, normals, colors...) interleaved in one memory space, this value should be set by the application to indicate the distance, in bytes, from one element of this aspect to the next.</p>
<p>When allocating interleaved vertex memory, setting this property affects the amount of memory allocated by the allocatedVertexCapacity property. If this property is set after the allocatedVertexCapacity property has been set, vertex memory will be reallocated again. To avoid allocating twice, if you need to set this property, do so before setting the allocatedVertexCapacity property.</p>
<p>The initial value of this property is the same as the value of the elementLength property. </p>

</div>
</div>
<a class="anchor" id="a6247d2c9b06be109afcba2b8d3c3c0f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLvoid*) vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the underlying vertex content. </p>
<p>If the underlying content memory is assigned to this instance using this property directly, the underlying content memory is neither retained nor deallocated by this instance. It is up to the application to manage the allocation and deallocation of the underlying content memory.</p>
<p>Alternately, the allocatedVertexCapacity property can be used to have this instance allocate and manage the underlying vertex content. When this is done, the underlying content memory will be retained and deallocated by this instance.</p>
<p>The underlying content can be interleaved and shared by several <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the content associated with an aspect of a vertex. ">CC3VertexArray</a> subclasses, each looking at a different aspect of the content for each vertex. In this case, the vertices property of each of those vertex array instances will reference the same underlying content memory, and the elementOffset property will indicate at which offset in each vertex content the datum of interest to that instance is located. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_c_c3_vertex_arrays_8h.html">CC3VertexArrays.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<address class="footer">
<p class="footer"/>© 2010 - 2014 The Brenwill Workshop Ltd.</p>
</address>
</body>
</html>
