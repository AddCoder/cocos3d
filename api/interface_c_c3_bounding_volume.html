<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Cocos3D: CC3BoundingVolume Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cocos3D
   &#160;<span id="projectnumber">2.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="#pub-static-methods">Class Methods</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_c_c3_bounding_volume-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CC3BoundingVolume Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#import &lt;CC3BoundingVolumes.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3BoundingVolume:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_bounding_volume__inherit__graph.png" border="0" usemap="#_c_c3_bounding_volume_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_bounding_volume_inherit__map" id="_c_c3_bounding_volume_inherit__map">
<area shape="rect" id="node4" href="interface_c_c3_frustum.html" title="Represents a camera&#39;s frustum. " alt="" coords="417,5,514,32"/><area shape="rect" id="node5" href="interface_c_c3_light_camera_bridge_volume.html" title="A bounding volume that encloses a volume between a light and all or part of the frustum of the camera..." alt="" coords="361,56,570,83"/><area shape="rect" id="node8" href="interface_c_c3_node_bounding_volume.html" title="CC3NodeBoundingVolumes are used by CC3Nodes to determine whether a node intersets another bounding vo..." alt="" coords="374,275,557,301"/><area shape="rect" id="node6" href="interface_c_c3_camera_shadow_volume.html" title="A bounding volume that encloses a pyramidal volume between the view plane (near clipping plane) of th..." alt="" coords="649,5,839,32"/><area shape="rect" id="node7" href="interface_c_c3_shadow_casting_volume.html" title="A bounding volume that encloses a volume that includes the camera frustum plus the space between the ..." alt="" coords="651,56,837,83"/><area shape="rect" id="node9" href="interface_c_c3_node_bounding_area.html" title="A bounding volume that defines a 2D bounding area for a node, and checks that bounding area against a..." alt="" coords="661,107,827,133"/><area shape="rect" id="node11" href="interface_c_c3_node_box_bounding_volume.html" title="A bounding volume that forms an axially aligned bounding box (AABB) around the node, in the node&#39;s local coordinate system. " alt="" coords="641,157,847,184"/><area shape="rect" id="node14" href="interface_c_c3_node_center_of_geometry_bounding_volume.html" title="CC3NodeCenterOfGeometryBoundingVolume is simply a single point at the node&#39;s center of geometry..." alt="" coords="619,209,869,250"/><area shape="rect" id="node16" href="interface_c_c3_node_infinite_bounding_volume.html" title="A bounding volume that forms a volume of infinite size. " alt="" coords="633,275,855,301"/><area shape="rect" id="node17" href="interface_c_c3_node_null_bounding_volume.html" title="A bounding volume that forms a volume of zero size and location. " alt="" coords="641,325,847,352"/><area shape="rect" id="node18" href="interface_c_c3_node_sphere_then_box_bounding_volume.html" title="CC3NodeSphereThenBoxBoundingVolume is a CC3NodeBoundingVolume that contains a CC3NodeSphericalBoundin..." alt="" coords="627,377,861,418"/><area shape="rect" id="node19" href="interface_c_c3_node_spherical_bounding_volume.html" title="A bounding volume that forms a sphere around a single point. " alt="" coords="648,442,840,483"/><area shape="rect" id="node21" href="interface_c_c3_node_tightening_bounding_volume_sequence.html" title="A composite bounding volume that contains other bounding volumes. " alt="" coords="645,507,843,549"/><area shape="rect" id="node10" href="interface_c_c3_billboard_bounding_box_area.html" title="A CC3NodeBoundingArea, used exclusively with CC3Billboards, that uses the billboardBoundingRect prope..." alt="" coords="917,77,1125,104"/><area shape="rect" id="node12" href="interface_c_c3_node_bounding_box_volume.html" title="Deprecated. " alt="" coords="919,128,1124,155"/><area shape="rect" id="node13" href="interface_c_c3_vertex_locations_bounding_box_volume.html" title="Deprecated. " alt="" coords="921,179,1121,221"/><area shape="rect" id="node15" href="interface_c_c3_vertex_locations_bounding_volume.html" title="Deprecated. " alt="" coords="921,245,1121,286"/><area shape="rect" id="node20" href="interface_c_c3_vertex_locations_spherical_bounding_volume.html" title="Deprecated. " alt="" coords="921,442,1121,483"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:a7926ef6d14e8a65baf0f4a992b348e0d"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#a7926ef6d14e8a65baf0f4a992b348e0d">doesIntersect:</a></td></tr>
<tr class="separator:a7926ef6d14e8a65baf0f4a992b348e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c90e43d3752c43c6f99e69adf0acf8"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#af0c90e43d3752c43c6f99e69adf0acf8">doesIntersectConvexHullOf:planes:</a></td></tr>
<tr class="separator:af0c90e43d3752c43c6f99e69adf0acf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe98a4f2d5688957b12002a89349fbe"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#a8fe98a4f2d5688957b12002a89349fbe">doesIntersectConvexHullOf:planes:from:</a></td></tr>
<tr class="separator:a8fe98a4f2d5688957b12002a89349fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be2148957850ad5f68d613897a3bc42"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#a0be2148957850ad5f68d613897a3bc42">doesIntersectLocation:</a></td></tr>
<tr class="separator:a0be2148957850ad5f68d613897a3bc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6510fa8c3a33ae82fc25811e60b695e1"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#a6510fa8c3a33ae82fc25811e60b695e1">doesIntersectRay:</a></td></tr>
<tr class="separator:a6510fa8c3a33ae82fc25811e60b695e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e671468ae8dd7572942da9b059fbc0"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#a01e671468ae8dd7572942da9b059fbc0">doesIntersectSphere:</a></td></tr>
<tr class="separator:a01e671468ae8dd7572942da9b059fbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee30095ec1bb5c7aeb8bac5cc61b91e"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#a3ee30095ec1bb5c7aeb8bac5cc61b91e">doesIntersectSphere:from:</a></td></tr>
<tr class="separator:a3ee30095ec1bb5c7aeb8bac5cc61b91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9089f263edeedad0c47c87e2313235a6"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#a9089f263edeedad0c47c87e2313235a6">fullDescription</a></td></tr>
<tr class="separator:a9089f263edeedad0c47c87e2313235a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6399c4dd588bbf8b9450547c519fe1ec"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#a6399c4dd588bbf8b9450547c519fe1ec">globalLocationOfGlobalRayIntesection:</a></td></tr>
<tr class="separator:a6399c4dd588bbf8b9450547c519fe1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62f8e6982353557e3145f82f9fd89aa"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#ae62f8e6982353557e3145f82f9fd89aa">isInFrontOfPlane:</a></td></tr>
<tr class="separator:ae62f8e6982353557e3145f82f9fd89aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88101ad71a203b798b90d3d78b385e0"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#af88101ad71a203b798b90d3d78b385e0">markDirty</a></td></tr>
<tr class="separator:af88101ad71a203b798b90d3d78b385e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8bc4a995468a384bec7a86afd37dff"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_bounding_volume.html#a5b8bc4a995468a384bec7a86afd37dff">populateFrom:</a></td></tr>
<tr class="separator:a5b8bc4a995468a384bec7a86afd37dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Class Methods</h2></td></tr>
<tr class="memitem:a083ccfdd5c2436acc881fdd7987e56e4"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_bounding_volume.html#a083ccfdd5c2436acc881fdd7987e56e4">boundingVolume</a></td></tr>
<tr class="separator:a083ccfdd5c2436acc881fdd7987e56e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:aa7d5c66769038517d53dceefd9ca9f73"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_bounding_volume.html#aa7d5c66769038517d53dceefd9ca9f73">isDirty</a></td></tr>
<tr class="separator:aa7d5c66769038517d53dceefd9ca9f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86047d96d15b324a18f759027b693243"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_bounding_volume.html#a86047d96d15b324a18f759027b693243">planeCount</a></td></tr>
<tr class="separator:a86047d96d15b324a18f759027b693243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cc407060662cb69f4439c081df6140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_plane.html">CC3Plane</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_bounding_volume.html#ac3cc407060662cb69f4439c081df6140">planes</a></td></tr>
<tr class="separator:ac3cc407060662cb69f4439c081df6140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1fe7d1e5eb552a0ec3d2a6ec58c4a4"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_bounding_volume.html#a8f1fe7d1e5eb552a0ec3d2a6ec58c4a4">shouldIgnoreRayIntersection</a></td></tr>
<tr class="separator:a8f1fe7d1e5eb552a0ec3d2a6ec58c4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad584b22fadc15519412945957485f8e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_bounding_volume.html#aad584b22fadc15519412945957485f8e">shouldLogIntersectionMisses</a></td></tr>
<tr class="separator:aad584b22fadc15519412945957485f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64637a59a93d5faad785fce141cceb18"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_bounding_volume.html#a64637a59a93d5faad785fce141cceb18">shouldLogIntersections</a></td></tr>
<tr class="separator:a64637a59a93d5faad785fce141cceb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02c598c3a75fd6cf13a87cf1d274fa0"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_bounding_volume.html#aa02c598c3a75fd6cf13a87cf1d274fa0">vertexCount</a></td></tr>
<tr class="separator:aa02c598c3a75fd6cf13a87cf1d274fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1b517961c50f50ab329878448580a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_bounding_volume.html#a2c1b517961c50f50ab329878448580a7">vertices</a></td></tr>
<tr class="separator:a2c1b517961c50f50ab329878448580a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Bounding volumes define a volume of space. </p>
<p>Through the doesIntersect: method, a bounding volume can indicate whether it intersects another bounding volume. This capability can be used for detecting collisions between objects, or to indicate whether an object is located in a particular volume of space, for example, the frustum of the camera.</p>
<p>Many different shapes of boundaries are available, including points, spheres, bounding boxes, cylinders, frustums, convex hulls, etc, permitting flexible volume definition, and tradeoffs between accuracy and computational processing time when testing intersections. </p>
</div><h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="a083ccfdd5c2436acc881fdd7987e56e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) boundingVolume </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased instance. </p>

<p>Implemented in <a class="el" href="interface_c_c3_node_sphere_then_box_bounding_volume.html#a29592557322256f44e3989f12d79fc7d">CC3NodeSphereThenBoxBoundingVolume</a>.</p>

</div>
</div>
<a class="anchor" id="a7926ef6d14e8a65baf0f4a992b348e0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doesIntersect: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_bounding_volume.html">CC3BoundingVolume</a> *)&#160;</td>
          <td class="paramname"><em>aBoundingVolume</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this bounding volume intersects the specfied other bounding volume. </p>
<p>This implementation tests whether the other bounding volume intersects the convex hull of this bounding volume, by double-dispatching to the doesIntersectConvexHullOf:planes:from: method of the other bounding volume, passing this bounding volume's planes property as the planes to test, and passing this bounding volume as the otherBoundingVolume argument to that method.</p>
<p>Subclasses whose bounding volumes are not described in terms of a hull of vertices and planes must override this method to perform some other test. Typically, subclasses that do override will implement this method as the double-dispatch pattern, invoking one of the doesIntersect...:from: methods on the specified other bounding volume, and even potentially adding other such methods in an extension category. </p>

<p>Implemented in <a class="el" href="interface_c_c3_node_null_bounding_volume.html#afedd3dad4173059063a80b63f7265fbe">CC3NodeNullBoundingVolume</a>, <a class="el" href="interface_c_c3_node_infinite_bounding_volume.html#a4f2b9560e0cbdd2288d227fcba75c239">CC3NodeInfiniteBoundingVolume</a>, <a class="el" href="interface_c_c3_node_tightening_bounding_volume_sequence.html#a026e8b457cdf75eda6826a377cba87c0">CC3NodeTighteningBoundingVolumeSequence</a>, <a class="el" href="interface_c_c3_node_spherical_bounding_volume.html#a96d13fda533b515821c919dda72b8807">CC3NodeSphericalBoundingVolume</a>, and <a class="el" href="interface_c_c3_node_center_of_geometry_bounding_volume.html#ae8d4359acf4b850481c4a139f642badc">CC3NodeCenterOfGeometryBoundingVolume</a>.</p>

</div>
</div>
<a class="anchor" id="af0c90e43d3752c43c6f99e69adf0acf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doesIntersectConvexHullOf: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>numOtherPlanes</em></td>
        </tr>
        <tr>
          <td class="paramkey">planes:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_plane.html">CC3Plane</a> *)&#160;</td>
          <td class="paramname"><em>otherPlanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a convex hull composed of the specified global planes intersects this bounding volume. </p>
<p>The planes may be the face planes of a mesh, or they may be the sides of an oriented bounding box (OBB), or frustum, etc.</p>
<p>This implementation delegates to the doesIntersectConvexHullOf:planes:from: method, passing nil as the other bounding volume. </p>

</div>
</div>
<a class="anchor" id="a8fe98a4f2d5688957b12002a89349fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doesIntersectConvexHullOf: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>numOtherPlanes</em></td>
        </tr>
        <tr>
          <td class="paramkey">planes:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_plane.html">CC3Plane</a> *)&#160;</td>
          <td class="paramname"><em>otherPlanes</em></td>
        </tr>
        <tr>
          <td class="paramkey">from:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_bounding_volume.html">CC3BoundingVolume</a> *)&#160;</td>
          <td class="paramname"><em>otherBoundingVolume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a convex hull composed of the specified global planes from the specified other bounding volume intersects this bounding volume. </p>
<p>The planes may be the face planes of a mesh, or they may be the sides of an oriented bounding box (OBB), or frustum, etc.</p>
<p>If all of the vertices of this bounding volume lie outside at least one of the specified planes, then this bounding volume cannot intersect the convex hull defined by those planes, and this method returns NO.</p>
<p>Such a test will not return any false-negative results. When an intersection really does occur, it will always return YES, and will never return NO.</p>
<p>However, a false-positive result is possible with this test and, depending on the relative orientations of the bounding volumes, can occasionally return YES when an intersection has not actually happened.</p>
<p>To compensate, this method also performs the same test from the opposite direction by invoking the doesIntersectConvexHullOf:planes: method of the specified otherBoundingVolume, passing the planes of this bounding volume.</p>
<p>Therefore, with the goal of reducing the occurences of false-positive results, this test is implmented by eliminating intersection failures. Each bounding volume is tested against the planes of the other, and this method returns NO as soon as one of those tests indicates intersection failure. If neither test rejects the intersection, then this method assumes that the intersection has occurred, and return YES.</p>
<p>False-positives are still possible, and this method can still indicate an intersection has occurred when it really hasn't. But, by combining the tests from both directions, the accuracy is improved. </p>

<p>Implemented in <a class="el" href="interface_c_c3_node_null_bounding_volume.html#af233ac3684c4798e9673b01180786cf1">CC3NodeNullBoundingVolume</a>, <a class="el" href="interface_c_c3_node_infinite_bounding_volume.html#af09cd84e9f49b7c7d6468928e6a523aa">CC3NodeInfiniteBoundingVolume</a>, <a class="el" href="interface_c_c3_node_tightening_bounding_volume_sequence.html#a4600df7bf561417a1aa7e79b22580aa8">CC3NodeTighteningBoundingVolumeSequence</a>, <a class="el" href="interface_c_c3_node_spherical_bounding_volume.html#ad8a0805984692441f7530dd8fe2f0096">CC3NodeSphericalBoundingVolume</a>, and <a class="el" href="interface_c_c3_node_center_of_geometry_bounding_volume.html#a2d13ec5e7e1d41626f61c9269f5c1807">CC3NodeCenterOfGeometryBoundingVolume</a>.</p>

</div>
</div>
<a class="anchor" id="a0be2148957850ad5f68d613897a3bc42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doesIntersectLocation: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>aLocation</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the specified global location intersects (is inside) this bounding volume. </p>
<p>Returns whether the specified location is contained within the convex hull of this bounding volume, by testing if the specified location is behind all of the planes in the planes property of this bounding volume.</p>
<p>Subclasses whose bounding volumes are not described in terms of a hull of vertices and planes must override this method to perform some other test. </p>

<p>Implemented in <a class="el" href="interface_c_c3_node_null_bounding_volume.html#a54078e9e9b818813f23c346f1b30d7d4">CC3NodeNullBoundingVolume</a>, <a class="el" href="interface_c_c3_node_infinite_bounding_volume.html#aa0df3420315f27ea87c5a04d94fda1b8">CC3NodeInfiniteBoundingVolume</a>, <a class="el" href="interface_c_c3_node_tightening_bounding_volume_sequence.html#aa9651ea532926c2d36051bb460da3407">CC3NodeTighteningBoundingVolumeSequence</a>, <a class="el" href="interface_c_c3_node_spherical_bounding_volume.html#a9709ddfcd9ac5de393357f31964f8b10">CC3NodeSphericalBoundingVolume</a>, and <a class="el" href="interface_c_c3_node_center_of_geometry_bounding_volume.html#aea1d0e6d64579cc945adfb010568e787">CC3NodeCenterOfGeometryBoundingVolume</a>.</p>

</div>
</div>
<a class="anchor" id="a6510fa8c3a33ae82fc25811e60b695e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doesIntersectRay: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_ray.html">CC3Ray</a>)&#160;</td>
          <td class="paramname"><em>aRay</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the specified global-coordinate ray intersects this bounding volume. </p>
<p>Returns whether the specified ray intersects the convex hull of this bounding volume, by testing if the intesection point of the ray and one of the planes in the planes property of this bounding volume is behind all of the remaining planes of this bounding volume.</p>
<p>The operation of this method is affected by the shouldIgnoreRayIntersection property. If that property is set to YES, this method will always return NO. See the notes of the shouldIgnoreRayIntersection property for more info.</p>
<p>Subclasses whose bounding volumes are not described in terms of a hull of vertices and planes must override this method to perform some other test. </p>

<p>Implemented in <a class="el" href="interface_c_c3_node_null_bounding_volume.html#a9beb89c8fb0afffc9173c712acd5fa42">CC3NodeNullBoundingVolume</a>, <a class="el" href="interface_c_c3_node_infinite_bounding_volume.html#a0df874e90c201d45ed10b4be31cb8803">CC3NodeInfiniteBoundingVolume</a>, <a class="el" href="interface_c_c3_node_tightening_bounding_volume_sequence.html#ac0ca9ee45589404cdb8e95e2e6acaf7b">CC3NodeTighteningBoundingVolumeSequence</a>, <a class="el" href="interface_c_c3_node_spherical_bounding_volume.html#a0bed392a359913bbd9ebb4c3cafcb292">CC3NodeSphericalBoundingVolume</a>, and <a class="el" href="interface_c_c3_node_center_of_geometry_bounding_volume.html#a56d36c3b36edaad983471a098e7b1059">CC3NodeCenterOfGeometryBoundingVolume</a>.</p>

</div>
</div>
<a class="anchor" id="a01e671468ae8dd7572942da9b059fbc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doesIntersectSphere: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_sphere.html">CC3Sphere</a>)&#160;</td>
          <td class="paramname"><em>aSphere</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the specified sphere intersects this bounding volume. </p>
<p>This implementation delegates to the doesIntersectSphere:from: method, passing nil as the other bounding volume. </p>

</div>
</div>
<a class="anchor" id="a3ee30095ec1bb5c7aeb8bac5cc61b91e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) <a class="el" href="interface_c_c3_bounding_volume.html#a01e671468ae8dd7572942da9b059fbc0">doesIntersectSphere:</a> </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_sphere.html">CC3Sphere</a>)&#160;</td>
          <td class="paramname"><em>aSphere</em></td>
        </tr>
        <tr>
          <td class="paramkey">from:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_bounding_volume.html">CC3BoundingVolume</a> *)&#160;</td>
          <td class="paramname"><em>otherBoundingVolume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the specified sphere intersects this bounding volume. </p>
<p>Returns whether the specified sphere intersects the convex hull of this bounding volume.</p>
<p>For the specified sphere to intesect this bounding volume, the center of the sphere must be closer to the convex hull formed by the planes of this bounding volume than the radius of the sphere.</p>
<p>In other words, the sphere will be outside this bounding volume if the center of the sphere lies in front of any one of the planes in the planes property of this bounding volume by more than the radius of the sphere.</p>
<p>This implementation ignores the otherBoundingVolume argument.</p>
<p>Subclasses whose bounding volumes are not described in terms of a hull of vertices and planes must override this method to perform some other test. </p>

<p>Implemented in <a class="el" href="interface_c_c3_node_null_bounding_volume.html#a66e073f8f68a2ece992a0de902591cc8">CC3NodeNullBoundingVolume</a>, <a class="el" href="interface_c_c3_node_infinite_bounding_volume.html#a11df3a571465f5828a39dfda024ed1fd">CC3NodeInfiniteBoundingVolume</a>, <a class="el" href="interface_c_c3_node_tightening_bounding_volume_sequence.html#a0622d5c84a4f6e6ecabc75a360bc2318">CC3NodeTighteningBoundingVolumeSequence</a>, <a class="el" href="interface_c_c3_node_spherical_bounding_volume.html#a83e772230e6354de3556f42315bcb9de">CC3NodeSphericalBoundingVolume</a>, and <a class="el" href="interface_c_c3_node_center_of_geometry_bounding_volume.html#a90f8e8a0ce33be51adc4c6123b1151aa">CC3NodeCenterOfGeometryBoundingVolume</a>.</p>

</div>
</div>
<a class="anchor" id="a9089f263edeedad0c47c87e2313235a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) fullDescription </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing a more complete description of this bounding volume, including the vertices and planes. </p>
<p>Subclasses whose bounding volumes are not described in terms of a hull of vertices and planes should override this method to return a more appropriate description. </p>

</div>
</div>
<a class="anchor" id="a6399c4dd588bbf8b9450547c519fe1ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) globalLocationOfGlobalRayIntesection: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_ray.html">CC3Ray</a>)&#160;</td>
          <td class="paramname"><em>aRay</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the location at which the specified ray intersects this bounding volume, or returns kCC3VectorNull if the ray does not intersect this bounding volume. </p>
<p>The result honours the startLocation of the ray, and will return kCC3VectorNull if this bounding volume is "behind" the startLocation, even if the line projecting back through the startLocation in the negative direction of the ray intersects this bounding volume.</p>
<p>The ray may start inside this bounding volume, in which case, the returned location represents the exit location of the ray.</p>
<p>The operation of this method is affected by the shouldIgnoreRayIntersection property. If that property is set to YES, this method will always return kCC3VectorNull. See the notes of the shouldIgnoreRayIntersection property for more info.</p>
<p>Both the input ray and the returned location are specified in global coordinates.</p>
<p>The returned result can be tested for null using the CC3VectorIsNull function. </p>

</div>
</div>
<a class="anchor" id="ae62f8e6982353557e3145f82f9fd89aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isInFrontOfPlane: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_plane.html">CC3Plane</a>)&#160;</td>
          <td class="paramname"><em>aPlane</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this bounding volume lies completely in front of the specified normalized global coordinate plane. </p>
<p>This method returns YES if the bounding volume lies completely on the side of the plane from which the plane normal points. It returns NO if this bounding volume intersects the plane or lies completely on the opposite side of the plane.</p>
<p>Returns whether all of the vertices of this bounding volume are on the side of the plane from which the normal points.</p>
<p>Subclasses whose bounding volumes are not described in terms of a hull of vertices and planes must override this method to perform some other test. </p>

<p>Implemented in <a class="el" href="interface_c_c3_node_null_bounding_volume.html#a7fc39af99d05d76e8f2faf8d86857e79">CC3NodeNullBoundingVolume</a>, <a class="el" href="interface_c_c3_node_infinite_bounding_volume.html#a6848e2bf32d4664ff3a791e23adf281d">CC3NodeInfiniteBoundingVolume</a>, <a class="el" href="interface_c_c3_node_tightening_bounding_volume_sequence.html#a1b0fb962fce9e79bb410f0735760a679">CC3NodeTighteningBoundingVolumeSequence</a>, <a class="el" href="interface_c_c3_node_spherical_bounding_volume.html#aa2bbf5cfa90c320248cd9e5b8c0ff134">CC3NodeSphericalBoundingVolume</a>, and <a class="el" href="interface_c_c3_node_center_of_geometry_bounding_volume.html#a17ebe95c3a2b570e7c68b7428dbadc02">CC3NodeCenterOfGeometryBoundingVolume</a>.</p>

</div>
</div>
<a class="anchor" id="af88101ad71a203b798b90d3d78b385e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) markDirty </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks this volume as dirty and in need of rebuilding. </p>
<p>The bounding volume will automatically be marked as dirty by changing any of the properties of the bounding volume. However, for subclasses that depend on content managed elsewhere, this method may be used to indicate to this bounding volume that it needs to be rebuilt.</p>
<p>If needed, rebuilding is lazily performed automatically when the bounding volume is tested against another bounding volume, or when a property that depends on the rebuilding is accessed. </p>

</div>
</div>
<a class="anchor" id="a5b8bc4a995468a384bec7a86afd37dff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateFrom: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_bounding_volume.html">CC3BoundingVolume</a> *)&#160;</td>
          <td class="paramname"><em>another</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template method that populates this instance from the specified other instance. </p>
<p>This method is invoked automatically during object copying via the copy or copyWithZone: method. In most situations, the application should use the copy method, and should never need to invoke this method directly.</p>
<p>Subclasses that add additional instance state (instance variables) should extend copying by overriding this method to copy that additional state. Superclass that override this method should be sure to invoke the superclass implementation to ensure that superclass state is copied as well. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="aa7d5c66769038517d53dceefd9ca9f73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this volume is dirty and in need of rebuilding. </p>

</div>
</div>
<a class="anchor" id="a86047d96d15b324a18f759027b693243"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) planeCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For bounding volumes that are described in terms of a hull of vertices and planes, this property returns the number of planes in the array returned by the planes property. </p>
<p>Not all bounding volumes are based on vertices and planes, and this abstract implementation returns zero. Subclasses that make use of vertices and planes will allocate the underlying array and override this implementation. </p>

</div>
</div>
<a class="anchor" id="ac3cc407060662cb69f4439c081df6140"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_plane.html">CC3Plane</a>*) planes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For bounding volumes that are described in terms of a hull of vertices and planes, this property returns the array of planes that define the boundary surface of this bounding volume. </p>
<p>The planes are defined in the global coordinate system. The number of planes in the array is specified by the planeCount property.</p>
<p>Not all bounding volumes are based on vertices and planes, and this abstract implementation returns the NULL pointer. Subclasses that make use of vertices and planes will allocate the underlying array and override this implementation. </p>

</div>
</div>
<a class="anchor" id="a8f1fe7d1e5eb552a0ec3d2a6ec58c4a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldIgnoreRayIntersection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this bounding volume should ignore intersections from rays. </p>
<p>If this property is set to YES, intersections with rays will be ignored, and the doesIntersectRay: method will always return NO.</p>
<p>The initial value of this property is NO, and most of the time this is sufficient.</p>
<p>For some uses, such as the bounding volumes of nodes that should be excluded from puncturing from touch selection rays, such as particle emitters, it might make sense to set this property to YES, so that the bounding volume is not affected by rays from touch events. </p>

</div>
</div>
<a class="anchor" id="aad584b22fadc15519412945957485f8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldLogIntersectionMisses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When this property is set to YES, a log message will be output whenever the doesIntersect: method returns NO (indicating that another bounding volume does not intersect this bounding volume), if the shouldLogIntersectionMisses property of the other bounding volume is also set to YES. </p>
<p>The shouldLogIntersectionMisses property of both bounding volumes must be set to YES for the log message to be output.</p>
<p>The initial value of this property is NO.</p>
<p>This property is useful during development to help trace intersections between bounding volumes, such as collision detection between nodes, or whether a node is within the camera's frustum.</p>
<p>This property is only effective when the LOGGING_ENABLED compiler build setting is defined and set to 1. </p>

</div>
</div>
<a class="anchor" id="a64637a59a93d5faad785fce141cceb18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldLogIntersections</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When this property is set to YES, a log message will be output whenever the doesIntersect: method returns YES (indicating that another bounding volume intersects this bounding volume), if the shouldLogIntersections property of the other bounding volume is also set to YES. </p>
<p>The shouldLogIntersections property of both bounding volumes must be set to YES for the log message to be output.</p>
<p>The initial value of this property is NO.</p>
<p>This property is useful during development to help trace intersections between bounding volumes, such as collision detection between nodes, or whether a node is within the camera's frustum.</p>
<p>This property is only effective when the LOGGING_ENABLED compiler build setting is defined and set to 1. </p>

</div>
</div>
<a class="anchor" id="aa02c598c3a75fd6cf13a87cf1d274fa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) vertexCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For bounding volumes that are described in terms of a hull of vertices and planes, this property returns the number of planes in the array returned by the vertices property. </p>
<p>Not all bounding volumes are based on vertices and planes, and this abstract implementation returns zero. Subclasses that make use of vertices and planes will allocate the underlying array and override this implementation. </p>

</div>
</div>
<a class="anchor" id="a2c1b517961c50f50ab329878448580a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>*) vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For bounding volumes that are described in terms of a hull of vertices and planes, this property returns the array of vertices at the points where the planes intersect. </p>
<p>The vertices are defined in the global coordinate system. The number of vertices in the array is defined by the vertexCount property.</p>
<p>The returned vertices are not in any defined order.</p>
<p>Not all bounding volumes are based on vertices and planes, and this abstract implementation returns the NULL pointer. Subclasses that make use of vertices and planes will allocate the underlying array and override this implementation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_c_c3_bounding_volumes_8h.html">CC3BoundingVolumes.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 19 2014 21:44:14 for Cocos3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
