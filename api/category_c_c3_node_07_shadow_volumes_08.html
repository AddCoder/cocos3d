<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Cocos3D: CC3Node(ShadowVolumes) Category Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cocos3D
   &#160;<span id="projectnumber">2.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="category_c_c3_node_07_shadow_volumes_08-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CC3Node(ShadowVolumes) Category Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#import &lt;CC3ShadowVolumes.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:ab3752cf2ecc791b495f3f5291312908b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#ab3752cf2ecc791b495f3f5291312908b">addShadowVolumes</a></td></tr>
<tr class="separator:ab3752cf2ecc791b495f3f5291312908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a26a75747b710ba9b8138c0ff9ddc4d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a2a26a75747b710ba9b8138c0ff9ddc4d">addShadowVolumesForLight:</a></td></tr>
<tr class="separator:a2a26a75747b710ba9b8138c0ff9ddc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe8ee8dc78ba7d6db86f48475c2dd48"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_shadow_volume_mesh_node.html">CC3ShadowVolumeMeshNode</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#aabe8ee8dc78ba7d6db86f48475c2dd48">getShadowVolumeForLight:</a></td></tr>
<tr class="separator:aabe8ee8dc78ba7d6db86f48475c2dd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3061a77b9f3bc1a77e1d41a732911f2b"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a3061a77b9f3bc1a77e1d41a732911f2b">hasShadowVolumes</a></td></tr>
<tr class="separator:a3061a77b9f3bc1a77e1d41a732911f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0723edbc79ce0b3518e11f35594ccd41"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a0723edbc79ce0b3518e11f35594ccd41">hasShadowVolumesForLight:</a></td></tr>
<tr class="separator:a0723edbc79ce0b3518e11f35594ccd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652b0691f722e172b87cd5a9c10647ee"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a652b0691f722e172b87cd5a9c10647ee">isShadowVisible</a></td></tr>
<tr class="separator:a652b0691f722e172b87cd5a9c10647ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e40a66f9647fc9a7ff01de3cc2645db"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a5e40a66f9647fc9a7ff01de3cc2645db">prewarmForShadowVolumes</a></td></tr>
<tr class="separator:a5e40a66f9647fc9a7ff01de3cc2645db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfe025f79b0e7ce367b5e2e43818aa3"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#abdfe025f79b0e7ce367b5e2e43818aa3">removeShadowVolumes</a></td></tr>
<tr class="separator:abdfe025f79b0e7ce367b5e2e43818aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d0af035ee74b21441ff1860a4094db"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a55d0af035ee74b21441ff1860a4094db">removeShadowVolumesForLight:</a></td></tr>
<tr class="separator:a55d0af035ee74b21441ff1860a4094db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a243087849ddd0878811a3fd2d9be85e3"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a243087849ddd0878811a3fd2d9be85e3">isShadowVolume</a></td></tr>
<tr class="separator:a243087849ddd0878811a3fd2d9be85e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8ba79801408f832114cf0015d6d709"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a9c8ba79801408f832114cf0015d6d709">shadowExpansionLimitFactor</a></td></tr>
<tr class="separator:a9c8ba79801408f832114cf0015d6d709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf664f8d955af2cca08a225854c06aa"><td class="memItemLeft" align="right" valign="top">GLushort&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a4cf664f8d955af2cca08a225854c06aa">shadowLagCount</a></td></tr>
<tr class="separator:a4cf664f8d955af2cca08a225854c06aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e5c7fd0e89e322cdba3830a7aa01e6"><td class="memItemLeft" align="right" valign="top">GLushort&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a48e5c7fd0e89e322cdba3830a7aa01e6">shadowLagFactor</a></td></tr>
<tr class="separator:a48e5c7fd0e89e322cdba3830a7aa01e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c68a1ac21d067436344c5710acdcfd"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a86c68a1ac21d067436344c5710acdcfd">shadowOffsetFactor</a></td></tr>
<tr class="separator:a86c68a1ac21d067436344c5710acdcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c702551a8be555cef1f68a1d71c59e"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a11c702551a8be555cef1f68a1d71c59e">shadowOffsetUnits</a></td></tr>
<tr class="separator:a11c702551a8be555cef1f68a1d71c59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26210b7713c538378d2042733a112e1"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#ab26210b7713c538378d2042733a112e1">shadowVolumes</a></td></tr>
<tr class="separator:ab26210b7713c538378d2042733a112e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22c2849e08e0f698bfa7c14a864a3ab"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#ab22c2849e08e0f698bfa7c14a864a3ab">shadowVolumeVertexOffsetFactor</a></td></tr>
<tr class="separator:ab22c2849e08e0f698bfa7c14a864a3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216302555d47b0ab179cccc47aa342aa"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a216302555d47b0ab179cccc47aa342aa">shouldAddShadowVolumeEndCapsOnlyWhenNeeded</a></td></tr>
<tr class="separator:a216302555d47b0ab179cccc47aa342aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6148501d14c6d4dec9e418e3c6ddb7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#aaf6148501d14c6d4dec9e418e3c6ddb7">shouldShadowBackFaces</a></td></tr>
<tr class="separator:aaf6148501d14c6d4dec9e418e3c6ddb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea076319848bb9c70158ffed4610df4"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a7ea076319848bb9c70158ffed4610df4">shouldShadowFrontFaces</a></td></tr>
<tr class="separator:a7ea076319848bb9c70158ffed4610df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Extension category to support shadow volumes. </p>
</div><h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="ab3752cf2ecc791b495f3f5291312908b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addShadowVolumes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each light currently in the scene, adds a shadow volume to each descendant node that contains a mesh. </p>
<p>This method is a convenience method that invokes the addShadowVolumesForLight: on this node for each existing light in the scene. See the notes for the addShadowVolumesForLight: method for detailed information about adding shadow volumes to nodes.</p>
<p>It is safe to invoke this method more than once with the same, or a different light. Only one shadow volume will be added to any mesh node for a particular light. The mesh node implementation checks to see if a shadow volume has been added already, and will not add a second shadow volume for the same light.</p>
<p>This method requires access to the lights in the scene, and will only be effective when invoked after:</p>
<ul>
<li>The node has been added to the scene.</li>
<li>The lights that are to cast shadows have been added to the scene. Invoking this method before adding this node, its descendants, and the lights, to the scene will have no effect. </li>
</ul>

<p>Extends class <a class="el" href="interface_c_c3_node.html#ab3752cf2ecc791b495f3f5291312908b">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a2a26a75747b710ba9b8138c0ff9ddc4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addShadowVolumesForLight: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_light.html">CC3Light</a> *)&#160;</td>
          <td class="paramname"><em>aLight</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a shadow volume to each descendant node that contains a mesh, for the specified light. </p>
<p>By using this method, you can control which lights cast shadows for each mesh node in your scene.</p>
<p>A shadow volume is a special child mesh node added to each descendant mesh node. The effect is to have each descendant mesh cast a shadow from the specified light. Invoking this method on the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> will cause all meshes in the scene to cast shadows from the specified light.</p>
<p>These shadow volume meshes are invisible, but are used to populate a stencil buffer that keeps track of where a shadow volume mesh intersects a visible object mesh. This stencil is used to paint the shadows onto the scene.</p>
<p>The shadow volume created by this method will only have effect if the visible property of both the node and the light are set to YES (ie- turning off a light also turns off any shadows it is casting).</p>
<p>Shadow volumes use a stencil buffer to determine the areas that require shading. The stencil buffer must be allocated within the EAGLView when the view is created and initialized. On the iOS, the sencil buffer is combined with the depth buffer. You create a stencil buffer by passing the value GL_DEPTH24_STENCIL8 as the depth format argument in the CCGLView method viewWithFrame:pixelFormat:depthFormat:preserveBackbuffer:sharegroup:multiSampling:numberOfSamples:.</p>
<p>It is safe to invoke this method more than once with the same, or a different light. Only one shadow volume will be added to any mesh node for a particular light. Each mesh node checks to see if a shadow volume has been added already, and will not add a second shadow volume for the same light.</p>
<p>To ensure that all objects behind each shadow-casting mesh node are shadowed, each shadow volume mesh extends to infinity. As a result, when a shadow volum is added using this method, the hasInfiniteDepthOfField property of the active camera is automatically set to YES, so that the shadow volume is not clipped by the far clipping plane of the camera's frustum.</p>
<p>If you know that you will never require end-caps, and want a finite camera frustum, you can set the hasInfiniteDepthOfField of the active camera back to NO. See the notes for the shouldAddShadowVolumeEndCapsOnlyWhenNeeded property for more info on the use of shadow volume end caps.</p>
<p>Shadows are inherently dynamic, and change as the shadow-casting node and light move relative to one another. For this reason, this method causes all meshes with a shadow volume to retain vertex location and index data (and for skinned meshes vertex weight and matrix index data).</p>
<p>If you know that the mesh nodes and light are fixed, after the first update to the scene, you can save memory by retrieving the vertex locations, indices, weights and matrix indices vertex arrays, set the shouldReleaseRedundantContent property on each to YES, and invoke the releaseRedundantContent method on each.</p>
<p>The internal management of shadow volumes requires intense access to the faces of the mesh that is casting the shadow. For this reason, when a shadow volume is added to a mesh node, the shouldCacheFaces property of that node is automatically set to YES, to improve the performance of shadow volume calculations. If you prefer to preserve memory instead, you can explicitly set this property back to NO.</p>
<p>This method will affect only the current descendant mesh nodes. Descendants added after this method is invoked will not automatically cast shadows. When dynamically adding a descendant node, invoke this method to have the new node cast a shadow from the specified light.</p>
<p>When a light is removed from the scene, the shadow volume for that light will automatically be removed from each mesh node. However, when a light is added, shadow volumes will not automatically be created for that light. When dyamically adding a light, you should invoke this method, or the addShadowVolumes method, to create a shadow volume for that light. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a2a26a75747b710ba9b8138c0ff9ddc4d">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="aabe8ee8dc78ba7d6db86f48475c2dd48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_shadow_volume_mesh_node.html">CC3ShadowVolumeMeshNode</a>*) getShadowVolumeForLight: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_light.html">CC3Light</a> *)&#160;</td>
          <td class="paramname"><em>aLight</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the shadow volume that was added to this node for the specified light, or returns nil if such a shadow volume does not exist in this node. </p>
<p>This implementation only looks through the immediate child nodes of this node, and does not recurse below this level. As such, this method only has meaning when invoked on a mesh node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#aabe8ee8dc78ba7d6db86f48475c2dd48">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a3061a77b9f3bc1a77e1d41a732911f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasShadowVolumes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this node, or any descendant, has had a shadow volume added for any light. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a3061a77b9f3bc1a77e1d41a732911f2b">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a0723edbc79ce0b3518e11f35594ccd41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasShadowVolumesForLight: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_light.html">CC3Light</a> *)&#160;</td>
          <td class="paramname"><em>aLight</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this node, or any descendant, has had a shadow volume added for the specified light. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a0723edbc79ce0b3518e11f35594ccd41">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a652b0691f722e172b87cd5a9c10647ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isShadowVisible </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this node is a shadow volume, returns whether the shadow cast by the shadow volume will be visible. </p>
<p>Returns NO if this node is not a shadow volume node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a652b0691f722e172b87cd5a9c10647ee">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a5e40a66f9647fc9a7ff01de3cc2645db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) prewarmForShadowVolumes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prewarms the meshes of all descendant mesh nodes to prepare for shadow volumes. </p>
<p>Shadow volumes make very heavy use of many mesh face characteristics. This method ensures that the faces have been populated for each descendant mesh node.</p>
<p>This method is invoked automatically when a shadow volume is added to a mesh node. Usually, the application should never need to invoke this method directly. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a5e40a66f9647fc9a7ff01de3cc2645db">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="abdfe025f79b0e7ce367b5e2e43818aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeShadowVolumes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the shadow volume child nodes that were previously added using the addShadowVolumesForLight: and addShadowVolumes methods, from this node and all descendant nodes, by invoking the removeShadowVolumesForLight: method for each light in the scene. </p>
<p>It is safe to invoke this method more than once, or even if no shadow volumes have previously been added. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#abdfe025f79b0e7ce367b5e2e43818aa3">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a55d0af035ee74b21441ff1860a4094db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeShadowVolumesForLight: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_light.html">CC3Light</a> *)&#160;</td>
          <td class="paramname"><em>aLight</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the shadow volume child nodes that were previously added using the addShadowVolumesForLight: and addShadowVolumes methods for the specified light, from this node and all descendant nodes. </p>
<p>Removing shadow volumes from a node will NOT automatically set its shouldCacheFaces property to NO, and will not automatically free up vertex data that was retained to build the shadow volumes. If you no longer need the face or vertex data to be cached, you should explicitly set the shouldCacheFaces property to NO, and the shouldReleaseRedundantContent property to YES, and invoke the releaseRedundantContent method.</p>
<p>It is safe to invoke this method more than once, or even if no shadow volumes have previously been added. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a55d0af035ee74b21441ff1860a4094db">CC3Node</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a243087849ddd0878811a3fd2d9be85e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isShadowVolume</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this node is an instance of a shadow volume. </p>
<p>Always returns NO. Subclasses that are shadow volumes will return YES. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a243087849ddd0878811a3fd2d9be85e3">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a9c8ba79801408f832114cf0015d6d709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) shadowExpansionLimitFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For shadows cast from locational lights, indicates a maximum distance that the shadow will be allowed to expand. </p>
<p>A shadow from lights at a specific location (locational lights), will expand in size the farther it is cast from the shadow casting node. For some types of shadows, allowing it to expand forever can cause visual artifacts, and so it can be beneficial to limit that expansion.</p>
<p>For example, an infinitely expanding shadow volume can display ghost-shadow artifacts from single-sided shadow meshes (such as planes). In this case, limiting the expansion allows the shadow volume to be closed off at the end by extending the remaining shadow volume to a single point at infinity, rather than an infinite size at infinity.</p>
<p>The value is specified as a multiplicative factor of the distance from the light to the shadow casting node. For example, a value of 10 indicates that the shadow will continue to expand for a distance behind the shadow-caster equivalent to 10 times the distance from the light to the shadow-caster, and then it will remain the same size out to infinity.</p>
<p>The initial value of this property is 100. The value of this property can only be changed after the shadows have been added.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the value of this property from any descendant shadow node, or will return zero if no shadow nodes are found in the descendants of this node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a9c8ba79801408f832114cf0015d6d709">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a4cf664f8d955af2cca08a225854c06aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLushort) shadowLagCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the current number of update cycles to the shadow-casting node, light and camera that must be processed before the shadow shape and movement will be updated. </p>
<p>In order to improve performance, the shadowLagFactor property can be used to control how often the shape and location of the shadow should be updated. The value of that property indicates the number of update cycles (usually the same as the number of frames) between successive updates of the shadow volume shape and location. This introduces a lag between the movement of the shadow-casting node, and its shadow, which in many cases will not be visibly significant See the notes of the shadowLagFactor for more info about controlling this behaviour.</p>
<p>The value of this property is decremented just before the updateBeforeTransform: method is invoked during each update cycle, and when the value reaches zero, the transform, shape, and location of the shadow will be recalculated. Once the recalculation is complete, the value of this property is set to the value of the shadowLagFactor, to being the update cycle countdown again.</p>
<p>When the shadowLagFactor property is used to improve performance, to avoid having all shadows updated in the same update cycle, setting the value of this property to a different value across different shadow-casting nodes can help distribute the load of calculating the shadows for a number of shadow-casting nodes across several update cycles.</p>
<p>In most cases, you do not need to set the value of this property directly. becuase when the value of the shadowLagFactor property is set, the value of this property is automatically set to a random value between one and the value of the shadowLagFactor.</p>
<p>When setting the value of this property, it is usually desireable to set the same value in all the nodes within each structural node assembly so that the shadows of all shadow-casting nodes that are moving together, will move together.</p>
<p>Reading the value of this property will tell you where in the update cycle the shadow is currently sitting. The value of this property will change on each update, cycling between the value of the shadowLagFactor, and zero.</p>
<p>The initial value of this property is one, indicating that the shadow shape and motion will be updated on the next update of the shadow-casting node, light or camera.</p>
<p>After that update, the value will be automatically changed to the value of the shadowLagFactor property.</p>
<p>The value of this property can only be changed after the shadow volumes have been added.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first value greater than zero from this property from any descendant shadow node, or will return zero if no shadow nodes are found in the descendants of this node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a4cf664f8d955af2cca08a225854c06aa">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a48e5c7fd0e89e322cdba3830a7aa01e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLushort) shadowLagFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calculation of shadow shape and movement can often be quite expensive. </p>
<p>To keep performance high, these calculations are performed only when necessary, specifically when any of the shadow-casting node, light or camera moves.</p>
<p>Because of this design, few updates will be required for a relatively static environment where the light, camera, and node do not often move. In such a situation, the processing load added by the shadow calculations will be low.</p>
<p>However, when the node, light and camera are in constant motion, a noticable performance penalty may arise as the shadow shape and movement is re-calculated frequently.</p>
<p>This property can be used to control how often the shape and location of the shadow should be updated. The value of this property indicates the number of update cycles (usually the same as the number of frames) between successive updates of the shadow volume shape and location.</p>
<p>Setting the value of this property to one will cause the shape and location of the shadow to be updated on every update to the locations of the node, light and camera (ie- every frame). Setting the value of this property to an integer greater than one will cause the update of the shadow to occur only once per that many updates to the shadow-casting node, light and camera (ie- once per that number of frames), effectively creating a lag between the movement of the shadow-casting node, and its shadow.</p>
<p>The visible effect of this lag depends on the nature of the movement of the shadow-casting node. In many situations, the lag will be unnoticable, or at least acceptablly low. However, the lag can sometimes create self-shadowing effects on the side of the node that is in shadow. The acceptability of this will depend on whether the camera can move behind the node to view the sides that are in shadow, and whether the self-shadow is visible on the darkened side.</p>
<p>The use of a value larger than one for this property can often be particularly useful for the shadows of skinned mesh nodes (bone-rigged characters), because the calculations involved in updating the shape and motion of deformable meshes are particularly performance-heavy, and the additional lag introduced by this property is usually quite acceptable visually.</p>
<p>When a number of shadows are being calculated, and the value of this property is set to a value greater than one, the shadowLagCount property can be used to ensure that all shadows are not calculated during the same update cycle, spreading the load of calculating shadow updates for a number of mesh nodes across several update cycles. See the notes of the shadowLagCount property for more info.</p>
<p>The initial value of this property is one, indicating that the shadow shape and motion will be updated on every update of the shadow-casting node, light or camera.</p>
<p>The value of this property can only be changed after the shadow volumes have been added.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first value greater than one from this property from any descendant shadow node, or will return one if no shadow nodes are found in the descendants of this node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a48e5c7fd0e89e322cdba3830a7aa01e6">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a86c68a1ac21d067436344c5710acdcfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) shadowOffsetFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An offset factor used by the GL engine when comparing the Z-distance of the content of shadows against previously drawn content. </p>
<p>This can be used to correct for Z-fighting between shadows and the surrounding objects (including the node casting the shadow itself).</p>
<p>For descendant nodes that are shadow volumes, this property combines with the shadowOffsetUnits property to offset the shadow volume from the shadow-casting node itself, so that the shadow volume end caps are drawn slightly in front of the shadow-casting node, to ensure that the shadow volume end caps do not acquire holes caused by Z-fighting with the shadow-caster.</p>
<p>For shadow volume nodes, the initial value of this property is zero. You can adjust this value (typically negative) if Z-fighting occurs. However, be aware that larger absolute values can distort the shadows.</p>
<p>This is a convenience property that sets or queries the decalOffsetFactor property on any descendant shadow nodes. The decalOffsetFactor property will only be set on descendant nodes that represent shadows. The value of that property on other nodes that are not shadows will be left unchanged.</p>
<p>See the notes for the decalOffsetFactor property for technical details about how the value of this property affects drawing.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first non-zero value of this property from any descendant shadow node, or will return zero if no shadow nodes are found in the descendants of this node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a86c68a1ac21d067436344c5710acdcfd">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a11c702551a8be555cef1f68a1d71c59e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) shadowOffsetUnits</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An offset value used by the GL engine when comparing the Z-distance of the content of shadows against previously drawn content. </p>
<p>This can be used to correct for Z-fighting between shadows and the surrounding objects (including the node casting the shadow itself).</p>
<p>For descendant nodes that are shadow volumes, this property combines with the shadowOffsetFactor property to offset the shadow volume from the shadow-casting node itself, so that the shadow volume end caps are drawn slightly in front of the shadow-casting node, to ensure that the shadow volume end caps do not acquire holes caused by Z-fighting with the shadow-caster.</p>
<p>For shadow volume nodes, the initial value of this property is minus one (-1) unit. You can adjust this value (typically negative) if Z-fighting occurs. However, be aware that larger absolute values will tend to distort shadows cast.</p>
<p>This is a convenience property that sets or queries the decalOffsetUnits property on any descendant shadow nodes. The decalOffsetUnits property will only be set on descendant nodes that represent shadows. The value of that property on other nodes that are not shadows will be left unchanged.</p>
<p>See the notes for the decalOffsetUnits property for technical details about how the value of this property affects drawing.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first non-zero value of this property from any descendant shadow node, or will return zero if no shadow nodes are found in the descendants of this node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a11c702551a8be555cef1f68a1d71c59e">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="ab26210b7713c538378d2042733a112e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray*) shadowVolumes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of all the shadow volume child nodes that were previously added to this node using the addShadowVolumesForLight: and addShadowVolumes methods. </p>
<p>This implementation only looks through the immediate child nodes of this node, and does not recurse below this level. As such, this method only has meaning when invoked on a mesh node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#ab26210b7713c538378d2042733a112e1">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="ab22c2849e08e0f698bfa7c14a864a3ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) shadowVolumeVertexOffsetFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertices of a shadow volume start at the vertices of the light terminator of the shadow-casting node, and extend away from the light source. </p>
<p>The value of this property is multiplied by the distance from the camera to the shadow-casting node to derive a short distance to offset the shadow volume vertices from the corresponding vertices of the shadow-casting node, in the direction away from the light.</p>
<p>The purpose of nudging the vertices of the shadow volume away from the shadow-casting mesh is to reduce Z-fighting between the shadow-caster mesh and the shadow volume mesh. In this sense, this property aims to fix the same issue that the shadowOffsetUnits and shadowOffsetFactor properties attempt to resolve.</p>
<p>The difference is that the shadowVolumeVertexOffsetFactor is always applied in the direction away from the <em>light</em>, whereas the shadowOffsetUnits and shadowOffsetFactor properties move the depth testing towards or away from the <em>camera</em>. This difference can sometimes show up as the relative positions of the shadow-caster, light and camera move around, and is particularly apparent with 2D planar meshes.</p>
<p>Particularly with 2D planar meshes, you can set this property to a positive, non-zero value to nudge the shadow volume vertices away from the shadow-caster vertices in the direction away from the light.</p>
<p>Although both this property and the shadowOffsetUnits and shadowOffsetFactor properties can be used together, doing so can introduce conflicts, again depending on the relative positions of the shadow-casting node, light and camera. It is recommended that you use one or the other technique. Either set one or both of the shadowOffsetUnits and shadowOffsetFactor properties to a non-zero value, and leave this property with a zero value, or set this property to a non-zero value, and set the shadowOffsetUnits and shadowOffsetFactor properties each to zero.</p>
<p>For non-planar convex meshes, leave this property set to zero. For planar meshes, set this property to a positive non-zero value, and set the shadowOffsetUnits and shadowOffsetFactor properties to zero.</p>
<p>The initial value of this property is zero, indicating that no offset will be applied to the shadow volume vertices. Typically, the value of this property is measured in thousandths. As a convenience, the constant kCC3DefaultShadowVolumeVertexOffsetFactor can be used to set the value of this property to an appropriate value.</p>
<p>The value of this property can only be changed after the shadow volumes have been added.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first non-zero value of this property from any descendant shadow node, or will return zero if no shadow nodes are found in the descendants of this node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#ab22c2849e08e0f698bfa7c14a864a3ab">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a216302555d47b0ab179cccc47aa342aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldAddShadowVolumeEndCapsOnlyWhenNeeded</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When using shadow volumes, the shadow volume can be drawn with or without end-caps. </p>
<p>This property determines whether the end-caps will always be added, or will be automatically added only when needed.</p>
<p>Adding end-caps can add a large number of additional faces to the shadow volume, which can affect performance. It is therefore desireable to avoid using end-caps where possible.</p>
<p>End-caps are required when the camera is located within the shadow volume (meaning that the camera is shadowed by the node casting the shadow). Because of this, end-caps will automatically be added to a shadow volume when the camera passes into that shadow volume, and will automatically be removed when the camera passes back out of the shadow volume.</p>
<p>However, without end-caps, the shadow will also be cast across the back of the shadow-casting object itself, darkening the side of the object away from the light, which may or may not be visible from the camera, and may or may not appear as visually undesireable, depending on the lighting and color or texture applied to the node. This self-shadowing is more noticable on light-colored materials. In this situation, it may be desireable to include the end-caps at all times, regardless of whether the camera is inside the shadow of the node or not.</p>
<p>When this property is set to YES, the end-caps will automatically be added only when the camera is within the shadow volume, and will be removed when the camera moves out of the shadow volume. This provides optimal performance.</p>
<p>When this property is set to NO, end-caps will be included always. This is not as efficient, but avoids the issue of self-shadowing described above.</p>
<p>The initial value of this property is NO, indicating that end-caps will be included always, to avoid self-shadowing. If the visual effect of self-shadowing on your object is not significant, you can set the value of this property to YES to improve performance.</p>
<p>The value of this property can only be changed after the shadow volumes have been added.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first NO value of this property from any descendant shadow node, or will return YES if no shadow nodes are found in the descendants of this node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a216302555d47b0ab179cccc47aa342aa">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="aaf6148501d14c6d4dec9e418e3c6ddb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldShadowBackFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a shadow should be cast from the back faces of the mesh. </p>
<p>For most meshes, the front faces form the visible faces of the mesh, and the back faces are not rendered. In these typical situations, the value of this property should be set to NO so that a shadow will not be built from the back faces of the object.</p>
<p>However, there are situations, such as with 2D planar meshes that can be viewed from either side, where the back faces will be rendered.</p>
<p>With shadows, there is also the situation where a planar node can be used as a wall, with light coming from behind the wall. Since the back faces of the wall mesh are facing the light, the wall will not cast a shadow.</p>
<p>In these less-common situations, this property can be set to YES to cause a shadow to be cast by the back faces of the mesh.</p>
<p>For a two-sided planar mesh, you can set both the shouldShadowFrontFaces property and this property to YES to cause a shadow to be cast regardless of the orientation of the 2D planar mesh to the light or the camera.</p>
<p>The initial value of this property is NO, indicating that the shadow will not be cast from the back faces of the node.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first YES value of this property from any descendant shadow node, or will return NO if no shadow nodes are found in the descendants of this node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#aaf6148501d14c6d4dec9e418e3c6ddb7">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a7ea076319848bb9c70158ffed4610df4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldShadowFrontFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a shadow should be cast from the front faces of the mesh. </p>
<p>For most meshes, the front faces form the visible faces of the mesh, and it is these visible faces that will cast the shadow.</p>
<p>The initial value of this property is YES, indicating that the shadow will be cast from the front faces of the node.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first NO value of this property from any descendant shadow node, or will return YES if no shadow nodes are found in the descendants of this node. </p>

<p>Extends class <a class="el" href="interface_c_c3_node.html#a7ea076319848bb9c70158ffed4610df4">CC3Node</a>.</p>

</div>
</div>
<hr/>The documentation for this category was generated from the following file:<ul>
<li><a class="el" href="_c_c3_shadow_volumes_8h.html">CC3ShadowVolumes.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 19 2014 21:44:24 for Cocos3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
