<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Cocos3D: Cocos3D API reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-cocos3d.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">
	   <a href="http://cocos3d.org"><img src="http://cocos3d.org/images/cocos3d-Banner-55h.png" /></a>
	   <span id="projectnumber">v2.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="#pub-static-methods">Class Methods</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_c_c3_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CC3Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#import &lt;CC3Node.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3Node:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_node__inherit__graph.png" border="0" usemap="#_c_c3_node_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_node_inherit__map" id="_c_c3_node_inherit__map">
<area shape="rect" id="node13" href="interface_c_c3_bone.html" title="CC3Bone is the building block of skeletons that control the deformation of a skin mesh..." alt="" coords="955,31,1035,57"/><area shape="rect" id="node15" href="interface_c_c3_c_a_l_node.html" title="A CC3CALNode extracted from a file. " alt="" coords="941,81,1048,108"/><area shape="rect" id="node16" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D scene. " alt="" coords="947,132,1043,159"/><area shape="rect" id="node18" href="interface_c_c3_environment_node.html" title="CC3EnvironmentNode is an abstract superclass of a family of node classes that hold a texture that can..." alt="" coords="917,183,1073,209"/><area shape="rect" id="node20" href="interface_c_c3_light.html" title="CC3Light represents the light in the 3D scene. " alt="" coords="956,233,1033,260"/><area shape="rect" id="node22" href="interface_c_c3_light_tracker.html" title="Deprecated and functionality moved to CC3Node class. " alt="" coords="933,284,1056,311"/><area shape="rect" id="node23" href="interface_c_c3_local_content_node.html" title="CC3LocalContentNode is an abstract class that forms the basis for nodes that have local content to dr..." alt="" coords="915,335,1074,361"/><area shape="rect" id="node43" href="interface_c_c3_p_o_d_node.html" title="A CC3Node extracted from a POD file. " alt="" coords="940,385,1049,412"/><area shape="rect" id="node44" href="interface_c_c3_resource_node.html" title="A CC3ResourceNode is a CC3Node that that can be populated from a CC3NodesResource, and forms the root of the node structural assembly loaded from a resource file. " alt="" coords="926,436,1063,463"/><area shape="rect" id="node46" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. " alt="" coords="951,487,1038,513"/><area shape="rect" id="node48" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft&#45;body object that uses vertex skinning ..." alt="" coords="927,537,1062,564"/><area shape="rect" id="node49" href="interface_c_c3_targetting_node.html" title="Deprecated and functionality moved to CC3Node class. " alt="" coords="925,588,1065,615"/><area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="583,204,697,231"/><area shape="rect" id="node4" href="protocol_c_c3_cacheable-p.html" title="Defines the behaviour required for an object that can be held in a cache. " alt="" coords="333,183,461,209"/><area shape="rect" id="node5" href="protocol_c_c3_object-p.html" title="Extension to support Cocos3D functionality. " alt="" coords="150,233,253,260"/><area shape="rect" id="node12" href="protocol_c_c3_node_listener_protocol-p.html" title="This protocol defines the behaviour requirements for objects that wish to be notified about the basic..." alt="" coords="301,284,493,311"/><area shape="rect" id="node8" href="protocol_c_c_r_g_b_a_protocol-p.html" title="\&lt;CCRGBAProtocol\&gt;" alt="" coords="568,339,712,365"/><area shape="rect" id="node11" href="protocol_c_c3_node_transform_listener_protocol-p.html" title="This protocol defines the behaviour requirements for objects that wish to be notified whenever the tr..." alt="" coords="542,273,738,314"/><area shape="rect" id="node14" href="interface_c_c3_p_o_d_bone.html" title="A CC3Bone extracted from a POD file. " alt="" coords="1152,31,1261,57"/><area shape="rect" id="node17" href="interface_c_c3_p_o_d_camera.html" title="A CC3Camera whose content originates from POD resource data. " alt="" coords="1144,132,1269,159"/><area shape="rect" id="node19" href="interface_c_c3_light_probe.html" title="CC3LightProbe is a type of light that uses a texture to define the light intensity in any direction a..." alt="" coords="1150,183,1263,209"/><area shape="rect" id="node21" href="interface_c_c3_p_o_d_light.html" title="A CC3Light whose content originates from POD resource data. " alt="" coords="1153,233,1260,260"/><area shape="rect" id="node24" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. " alt="" coords="1150,335,1263,361"/><area shape="rect" id="node25" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D Cocos2D CCNode as part of the 3D scene. " alt="" coords="1402,31,1502,57"/><area shape="rect" id="node28" href="interface_c_c3_bitmap_label_node.html" title="CC3BitmapLabelNode displays a rectangular mesh displaying the text of a specified string..." alt="" coords="1375,81,1529,108"/><area shape="rect" id="node29" href="interface_c_c3_bounding_volume_display_node.html" title="CC3BoundingVolumeDisplayNode is a type of CC3MeshNode specialized for displaying the bounding volume ..." alt="" coords="1339,132,1565,159"/><area shape="rect" id="node30" href="interface_c_c3_box_node.html" title="CC3BoxNode is a type of CC3MeshNode that is specialized to display simple box or cube meshes..." alt="" coords="1400,183,1504,209"/><area shape="rect" id="node32" href="interface_c_c3_clip_space_node.html" title="CC3ClipSpaceNode simplifies the creation of a simple rectangular node that can be used in the clip&#45;sp..." alt="" coords="1381,233,1523,260"/><area shape="rect" id="node35" href="interface_c_c3_fog.html" title="CC3Fog is a mesh node that can render fog in the 3D scene. " alt="" coords="1416,284,1488,311"/><area shape="rect" id="node36" href="interface_c_c3_line_node.html" title="CC3LineNode is a type of CC3MeshNode that is specialized to display lines. " alt="" coords="1399,335,1505,361"/><area shape="rect" id="node37" href="interface_c_c3_particle_emitter.html" title="A CC3MeshNode that emits 3D particles. " alt="" coords="1384,385,1520,412"/><area shape="rect" id="node38" href="interface_c_c3_plane_node.html" title="CC3PlaneNode is a type of CC3MeshNode that is specialized to display planes and simple rectanglular m..." alt="" coords="1395,436,1509,463"/><area shape="rect" id="node39" href="interface_c_c3_p_o_d_mesh_node.html" title="A CC3MeshNode whose content originates from POD resource data. " alt="" coords="1381,487,1523,513"/><area shape="rect" id="node40" href="interface_c_c3_shadow_volume_mesh_node.html" title="The mesh node used to build a shadow volume. " alt="" coords="1349,537,1555,564"/><area shape="rect" id="node41" href="interface_c_c3_skin_mesh_node.html" title="CC3SkinMeshNode is a CC3MeshNode specialized to use vertex skinning to draw the contents of its mesh..." alt="" coords="1383,588,1521,615"/><area shape="rect" id="node42" href="interface_c_c3_sphere_node.html" title="CC3SphereNode is a type of CC3MeshNode that is specialized to display a simple sphere mesh..." alt="" coords="1390,639,1514,665"/><area shape="rect" id="node26" href="interface_c_c3_node_descriptor.html" title="CC3NodeDescriptor is a type of CC3Billboard specialized for attaching a descriptive text label to ano..." alt="" coords="1657,5,1799,32"/><area shape="rect" id="node27" href="interface_c_c3_particle_system_billboard.html" title="A CC3Billboard node customized to display and manage a Cocos2D 2D CCParticleSystem. " alt="" coords="1633,56,1823,83"/><area shape="rect" id="node31" href="interface_c_c3_touch_box.html" title="CC3TouchBox is a specialized node that creates an invisible box mesh that can be used to define a 3D ..." alt="" coords="1673,183,1783,209"/><area shape="rect" id="node33" href="interface_c_c3_backdrop.html" title="CC3Backdrop represents a simple full&#45;view static backdrop that is rendered in clip&#45;space. " alt="" coords="1675,233,1781,260"/><area shape="rect" id="node34" href="interface_c_c3_stencilled_shadow_painter_node.html" title="The mesh node used to paint the shadows cast by shadow volumes. " alt="" coords="1613,284,1843,311"/><area shape="rect" id="node45" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that can be loaded from a PVR POD resource file. " alt="" coords="1123,436,1290,463"/><area shape="rect" id="node47" href="interface_c_c3_world.html" title="CC3World" alt="" coords="1165,487,1249,513"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:aef0c0a5a05759248a193cd6158189c21"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aef0c0a5a05759248a193cd6158189c21">__deprecated</a></td></tr>
<tr class="separator:aef0c0a5a05759248a193cd6158189c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0a5a05759248a193cd6158189c21"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aef0c0a5a05759248a193cd6158189c21">__deprecated</a></td></tr>
<tr class="separator:aef0c0a5a05759248a193cd6158189c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0a5a05759248a193cd6158189c21"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aef0c0a5a05759248a193cd6158189c21">__deprecated</a></td></tr>
<tr class="separator:aef0c0a5a05759248a193cd6158189c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0a5a05759248a193cd6158189c21"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aef0c0a5a05759248a193cd6158189c21">__deprecated</a></td></tr>
<tr class="separator:aef0c0a5a05759248a193cd6158189c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0a5a05759248a193cd6158189c21"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aef0c0a5a05759248a193cd6158189c21">__deprecated</a></td></tr>
<tr class="separator:aef0c0a5a05759248a193cd6158189c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0a5a05759248a193cd6158189c21"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aef0c0a5a05759248a193cd6158189c21">__deprecated</a></td></tr>
<tr class="separator:aef0c0a5a05759248a193cd6158189c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0a5a05759248a193cd6158189c21"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aef0c0a5a05759248a193cd6158189c21">__deprecated</a></td></tr>
<tr class="separator:aef0c0a5a05759248a193cd6158189c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0a5a05759248a193cd6158189c21"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aef0c0a5a05759248a193cd6158189c21">__deprecated</a></td></tr>
<tr class="separator:aef0c0a5a05759248a193cd6158189c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0a5a05759248a193cd6158189c21"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aef0c0a5a05759248a193cd6158189c21">__deprecated</a></td></tr>
<tr class="separator:aef0c0a5a05759248a193cd6158189c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0a5a05759248a193cd6158189c21"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aef0c0a5a05759248a193cd6158189c21">__deprecated</a></td></tr>
<tr class="separator:aef0c0a5a05759248a193cd6158189c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8340abf8a444932c0c0ee933c5a901"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a4b8340abf8a444932c0c0ee933c5a901">__deprecated</a></td></tr>
<tr class="separator:a4b8340abf8a444932c0c0ee933c5a901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0a5a05759248a193cd6158189c21"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aef0c0a5a05759248a193cd6158189c21">__deprecated</a></td></tr>
<tr class="separator:aef0c0a5a05759248a193cd6158189c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14386e095b6fa995faf1544dd09c8b1d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a14386e095b6fa995faf1544dd09c8b1d">addAndLocalizeChild:</a></td></tr>
<tr class="separator:a14386e095b6fa995faf1544dd09c8b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3e8956694f49026dda1063b1b600ec"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a3b3e8956694f49026dda1063b1b600ec">addAnimation:asTrack:</a></td></tr>
<tr class="separator:a3b3e8956694f49026dda1063b1b600ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e4d1b3b8595f63ec865917af48ff9b"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a21e4d1b3b8595f63ec865917af48ff9b">addAnimationFrom:to:</a></td></tr>
<tr class="separator:a21e4d1b3b8595f63ec865917af48ff9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93d9482844e29574093f19bf2f6392e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ae93d9482844e29574093f19bf2f6392e">addAnimationFrom:to:asTrack:</a></td></tr>
<tr class="separator:ae93d9482844e29574093f19bf2f6392e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d42b62a93d1ae6235b937ed5578c78a"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a2d42b62a93d1ae6235b937ed5578c78a">addAnimationFrom:to:ofBaseTrack:</a></td></tr>
<tr class="separator:a2d42b62a93d1ae6235b937ed5578c78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac158a331cdd93e4831e840b276214cd7"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ac158a331cdd93e4831e840b276214cd7">addAnimationFrom:to:ofBaseTrack:asTrack:</a></td></tr>
<tr class="separator:ac158a331cdd93e4831e840b276214cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02897d92979bd80d4fb68aea28bce8a6"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a02897d92979bd80d4fb68aea28bce8a6">addAnimationFromCAFFile:</a></td></tr>
<tr class="separator:a02897d92979bd80d4fb68aea28bce8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4645becd4fa4ef6b54110639ea4fbb7"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aa4645becd4fa4ef6b54110639ea4fbb7">addAnimationFromCAFFile:asTrack:</a></td></tr>
<tr class="separator:aa4645becd4fa4ef6b54110639ea4fbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e1944c83847b04e983ecd23a35bd1c"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a17e1944c83847b04e983ecd23a35bd1c">addAnimationFromCAFFile:linkedToCSFFile:</a></td></tr>
<tr class="separator:a17e1944c83847b04e983ecd23a35bd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0703a78269e91018e02a40d12c4dae"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#adb0703a78269e91018e02a40d12c4dae">addAnimationFromCAFFile:linkedToCSFFile:asTrack:</a></td></tr>
<tr class="separator:adb0703a78269e91018e02a40d12c4dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b6ea59d53900883740c93cef95dbed"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a96b6ea59d53900883740c93cef95dbed">addAnimationFromFrame:toFrame:</a></td></tr>
<tr class="separator:a96b6ea59d53900883740c93cef95dbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24969f4a3211886acbe86ceae2d67d58"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a24969f4a3211886acbe86ceae2d67d58">addAnimationFromFrame:toFrame:asTrack:</a></td></tr>
<tr class="separator:a24969f4a3211886acbe86ceae2d67d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d08978a07a3312446c0c1a40f2d62f"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ad1d08978a07a3312446c0c1a40f2d62f">addAnimationFromFrame:toFrame:ofBaseTrack:</a></td></tr>
<tr class="separator:ad1d08978a07a3312446c0c1a40f2d62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab7f4e9c2421024c573f347e2a63e38"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#adab7f4e9c2421024c573f347e2a63e38">addAnimationFromFrame:toFrame:ofBaseTrack:asTrack:</a></td></tr>
<tr class="separator:adab7f4e9c2421024c573f347e2a63e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f5b7bc869d5271d4302b579afd4ec4"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ac8f5b7bc869d5271d4302b579afd4ec4">addAnimationFromPODFile:</a></td></tr>
<tr class="separator:ac8f5b7bc869d5271d4302b579afd4ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547de2cac17004697d1170b9949b3734"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a547de2cac17004697d1170b9949b3734">addAnimationFromPODFile:asTrack:</a></td></tr>
<tr class="separator:a547de2cac17004697d1170b9949b3734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44e38f9b8be4637541b180e16abbb9a"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab44e38f9b8be4637541b180e16abbb9a">addAnimationInResource:</a></td></tr>
<tr class="separator:ab44e38f9b8be4637541b180e16abbb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34de6856ed14b1c76cc8a1727e9db8e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab34de6856ed14b1c76cc8a1727e9db8e">addAnimationInResource:asTrack:</a></td></tr>
<tr class="separator:ab34de6856ed14b1c76cc8a1727e9db8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15392ebeef563410922d572ddeb8763"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ac15392ebeef563410922d572ddeb8763">addAnimationState:</a></td></tr>
<tr class="separator:ac15392ebeef563410922d572ddeb8763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e9f558c788f29f9107799cc6c1dde8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ae2e9f558c788f29f9107799cc6c1dde8">addAxesDirectionMarkers</a></td></tr>
<tr class="separator:ae2e9f558c788f29f9107799cc6c1dde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d0746d13937340c19e38b1c04c3476"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ac4d0746d13937340c19e38b1c04c3476">addChild:</a></td></tr>
<tr class="separator:ac4d0746d13937340c19e38b1c04c3476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c5fcce1fb86489deaf1d5fe04785cd"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ae1c5fcce1fb86489deaf1d5fe04785cd">addContentFromPODFile:</a></td></tr>
<tr class="separator:ae1c5fcce1fb86489deaf1d5fe04785cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865fedc54c8b53e50f3ebd1554c208fe"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a865fedc54c8b53e50f3ebd1554c208fe">addContentFromPODFile:withName:</a></td></tr>
<tr class="separator:a865fedc54c8b53e50f3ebd1554c208fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e75759d5923464b0e7a766e88bf910"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ac4e75759d5923464b0e7a766e88bf910">addContentFromPODResourceFile:</a></td></tr>
<tr class="separator:ac4e75759d5923464b0e7a766e88bf910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124b119dda19e0776892cb402fa330c6"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a124b119dda19e0776892cb402fa330c6">addContentFromPODResourceFile:withName:</a></td></tr>
<tr class="separator:a124b119dda19e0776892cb402fa330c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa930b2bc24563bfd1f635f8d833ba618"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aa930b2bc24563bfd1f635f8d833ba618">addDirectionMarker</a></td></tr>
<tr class="separator:aa930b2bc24563bfd1f635f8d833ba618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5b607ec466a3fa89e5943c6f242cb9"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a5a5b607ec466a3fa89e5943c6f242cb9">addDirectionMarkerColored:inDirection:</a></td></tr>
<tr class="separator:a5a5b607ec466a3fa89e5943c6f242cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3752cf2ecc791b495f3f5291312908b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab3752cf2ecc791b495f3f5291312908b">addShadowVolumes</a></td></tr>
<tr class="separator:ab3752cf2ecc791b495f3f5291312908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a26a75747b710ba9b8138c0ff9ddc4d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a2a26a75747b710ba9b8138c0ff9ddc4d">addShadowVolumesForLight:</a></td></tr>
<tr class="separator:a2a26a75747b710ba9b8138c0ff9ddc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5ba9a571646991c5d1904424e6851c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a0e5ba9a571646991c5d1904424e6851c">addTexture:</a></td></tr>
<tr class="separator:a0e5ba9a571646991c5d1904424e6851c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4fb12dbc22b247ce684f55f6ce7fec"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a4a4fb12dbc22b247ce684f55f6ce7fec">addTransformListener:</a></td></tr>
<tr class="separator:a4a4fb12dbc22b247ce684f55f6ce7fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b69b89f01d7c98c0303f1e03d976558"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a5b69b89f01d7c98c0303f1e03d976558">alignInvertedTextures</a></td></tr>
<tr class="separator:a5b69b89f01d7c98c0303f1e03d976558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba26fe792bf02227f68e7e22d3a56cb"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a6ba26fe792bf02227f68e7e22d3a56cb">alignTextures</a></td></tr>
<tr class="separator:a6ba26fe792bf02227f68e7e22d3a56cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac2ab3bb9afaeac8c9f10f15d192e77"><td class="memItemLeft" align="right" valign="top">(GLfloat)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#abac2ab3bb9afaeac8c9f10f15d192e77">animationBlendingWeightOnTrack:</a></td></tr>
<tr class="separator:abac2ab3bb9afaeac8c9f10f15d192e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2267197329bb9fc0e31c66242ab73a"><td class="memItemLeft" align="right" valign="top">(CCTime)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aeb2267197329bb9fc0e31c66242ab73a">animationTimeOnTrack:</a></td></tr>
<tr class="separator:aeb2267197329bb9fc0e31c66242ab73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0c8eb0c20c5eee0c4cc4384846ce08"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a5e0c8eb0c20c5eee0c4cc4384846ce08">appendStructureDescriptionTo:withIndent:</a></td></tr>
<tr class="separator:a5e0c8eb0c20c5eee0c4cc4384846ce08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb2fa07002acb921025124e3508a084"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a9fb2fa07002acb921025124e3508a084">applyEffectNamed:inPFXResourceFile:</a></td></tr>
<tr class="separator:a9fb2fa07002acb921025124e3508a084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40131e0542d562e8bd914d656ebdb469"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a40131e0542d562e8bd914d656ebdb469">applyEffectNamed:inPFXResourceNamed:</a></td></tr>
<tr class="separator:a40131e0542d562e8bd914d656ebdb469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d64a7b5358717a0440f418dd82813f9"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a9d64a7b5358717a0440f418dd82813f9">applyLocalTransformsTo:</a></td></tr>
<tr class="separator:a9d64a7b5358717a0440f418dd82813f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa0e16be670dfa52b72b1518444db8a"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a0fa0e16be670dfa52b72b1518444db8a">asBumpMapLightTrackingWrapper</a></td></tr>
<tr class="separator:a0fa0e16be670dfa52b72b1518444db8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b9ecbaf2729324c0ce5139307ef13a"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a11b9ecbaf2729324c0ce5139307ef13a">asCameraTrackingWrapper</a></td></tr>
<tr class="separator:a11b9ecbaf2729324c0ce5139307ef13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cba45f72c3638ec7e35a2060e2ba58e"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a9cba45f72c3638ec7e35a2060e2ba58e">asOrientingWrapper</a></td></tr>
<tr class="separator:a9cba45f72c3638ec7e35a2060e2ba58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21657a0ccdb8b8cba8d63497941f9044"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a21657a0ccdb8b8cba8d63497941f9044">asTrackingWrapper</a></td></tr>
<tr class="separator:a21657a0ccdb8b8cba8d63497941f9044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf3b104117af9ee7cfc8ed440bc5bbd"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#acaf3b104117af9ee7cfc8ed440bc5bbd">bindRestPose</a></td></tr>
<tr class="separator:acaf3b104117af9ee7cfc8ed440bc5bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f9922d1b734bcdca29d3b5f669c1ff"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_box.html">CC3Box</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab2f9922d1b734bcdca29d3b5f669c1ff">boundingBoxRelativeTo:</a></td></tr>
<tr class="separator:ab2f9922d1b734bcdca29d3b5f669c1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aa21cf629380b2cc24cb6196cdad63"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aa0aa21cf629380b2cc24cb6196cdad63">buildTransformMatrixWithVisitor:</a></td></tr>
<tr class="separator:aa0aa21cf629380b2cc24cb6196cdad63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65611a362386a198f5037c953c5a8f7e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a65611a362386a198f5037c953c5a8f7e">checkDrawingOrder</a></td></tr>
<tr class="separator:a65611a362386a198f5037c953c5a8f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3546f3c282b8321773cc6be505f07dc"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aa3546f3c282b8321773cc6be505f07dc">cleanupActions</a></td></tr>
<tr class="separator:aa3546f3c282b8321773cc6be505f07dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd27670c1e17cf6beb5dc1e0a39474ba"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#afd27670c1e17cf6beb5dc1e0a39474ba">closestNodeIntersectedByGlobalRay:</a></td></tr>
<tr class="separator:afd27670c1e17cf6beb5dc1e0a39474ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9d4fb6b2f6ecaf7ff37953fb7553e7"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a4f9d4fb6b2f6ecaf7ff37953fb7553e7">containsAnimationOnTrack:</a></td></tr>
<tr class="separator:a4f9d4fb6b2f6ecaf7ff37953fb7553e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bda04af22d4853e65cbb1b2a7be0097"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a7bda04af22d4853e65cbb1b2a7be0097">copy</a></td></tr>
<tr class="separator:a7bda04af22d4853e65cbb1b2a7be0097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0fbbf1cbbbf174ec68f2322856db97"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aec0fbbf1cbbbf174ec68f2322856db97">copyWithName:</a></td></tr>
<tr class="separator:aec0fbbf1cbbbf174ec68f2322856db97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26356a1eaf961c2b0cf37979f8a1239d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a26356a1eaf961c2b0cf37979f8a1239d">createBoundingVolume</a></td></tr>
<tr class="separator:a26356a1eaf961c2b0cf37979f8a1239d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e1a94a009c558a206669e4e75c9b60"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a68e1a94a009c558a206669e4e75c9b60">createBoundingVolumes</a></td></tr>
<tr class="separator:a68e1a94a009c558a206669e4e75c9b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1be5eb9f0e3e3f2513b5050e4d585f8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aa1be5eb9f0e3e3f2513b5050e4d585f8">createGLBuffers</a></td></tr>
<tr class="separator:aa1be5eb9f0e3e3f2513b5050e4d585f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2afa741047a45ad1bd94e55139ddf6e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ad2afa741047a45ad1bd94e55139ddf6e">createSkinnedBoundingVolumes</a></td></tr>
<tr class="separator:ad2afa741047a45ad1bd94e55139ddf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d01ee847077ef6faf2652a749e670b0"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node_bounding_volume.html">CC3NodeBoundingVolume</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a6d01ee847077ef6faf2652a749e670b0">defaultBoundingVolume</a></td></tr>
<tr class="separator:a6d01ee847077ef6faf2652a749e670b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dda125a64d3e29b4525cd1cf61c0bb"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a94dda125a64d3e29b4525cd1cf61c0bb">deleteBoundingVolumes</a></td></tr>
<tr class="separator:a94dda125a64d3e29b4525cd1cf61c0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0789463c8d3f49e650adbb3212353f2b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a0789463c8d3f49e650adbb3212353f2b">deleteGLBuffers</a></td></tr>
<tr class="separator:a0789463c8d3f49e650adbb3212353f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5477cf3d39958c394ab407b8d16b25"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a3b5477cf3d39958c394ab407b8d16b25">describeAnimationStateForFrames:</a></td></tr>
<tr class="separator:a3b5477cf3d39958c394ab407b8d16b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ec7e7de7d56c0d17630902f13831a8"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a98ec7e7de7d56c0d17630902f13831a8">describeAnimationStateForFrames:fromTime:toTime:</a></td></tr>
<tr class="separator:a98ec7e7de7d56c0d17630902f13831a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f0ce03fa1126a2e8bb61ab6431f6b6"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ac3f0ce03fa1126a2e8bb61ab6431f6b6">describeCurrentAnimationState</a></td></tr>
<tr class="separator:ac3f0ce03fa1126a2e8bb61ab6431f6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a7fd0b3ba129e8588e0871efe15469"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ad2a7fd0b3ba129e8588e0871efe15469">disableAllAnimation</a></td></tr>
<tr class="separator:ad2a7fd0b3ba129e8588e0871efe15469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a0ac82b384ce3cdae07a68df6ad171"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a67a0ac82b384ce3cdae07a68df6ad171">disableAllAnimationOnTrack:</a></td></tr>
<tr class="separator:a67a0ac82b384ce3cdae07a68df6ad171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab839c42ae523f62e9d02fbc3f838266d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab839c42ae523f62e9d02fbc3f838266d">disableAllLocationAnimation</a></td></tr>
<tr class="separator:ab839c42ae523f62e9d02fbc3f838266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a910f58010a508277db45be0e176779"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a0a910f58010a508277db45be0e176779">disableAllQuaternionAnimation</a></td></tr>
<tr class="separator:a0a910f58010a508277db45be0e176779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44421eb938cf7369306f119934e103f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab44421eb938cf7369306f119934e103f">disableAllScaleAnimation</a></td></tr>
<tr class="separator:ab44421eb938cf7369306f119934e103f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd6c649c5024ba5742a52bf08d17c5b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#abdd6c649c5024ba5742a52bf08d17c5b">disableAnimation</a></td></tr>
<tr class="separator:abdd6c649c5024ba5742a52bf08d17c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa686f4aca181d0d4691085be56d399bc"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aa686f4aca181d0d4691085be56d399bc">disableAnimationOnTrack:</a></td></tr>
<tr class="separator:aa686f4aca181d0d4691085be56d399bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd76f8e1fe604788ee674e8a59b8162"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#abfd76f8e1fe604788ee674e8a59b8162">disableLocationAnimation</a></td></tr>
<tr class="separator:abfd76f8e1fe604788ee674e8a59b8162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02afac56eee9ffa0c0ad9316fc2cc13"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ae02afac56eee9ffa0c0ad9316fc2cc13">disableQuaternionAnimation</a></td></tr>
<tr class="separator:ae02afac56eee9ffa0c0ad9316fc2cc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac503421e7b33e695cdf30ef4ac3206b6"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ac503421e7b33e695cdf30ef4ac3206b6">disableScaleAnimation</a></td></tr>
<tr class="separator:ac503421e7b33e695cdf30ef4ac3206b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cff3a70ea6e9e34d418432c0309d80"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a22cff3a70ea6e9e34d418432c0309d80">doesIntersectBoundingVolume:</a></td></tr>
<tr class="separator:a22cff3a70ea6e9e34d418432c0309d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313faba92d4638b21ad6d02ba7ca6e95"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a313faba92d4638b21ad6d02ba7ca6e95">doesIntersectFrustum:</a></td></tr>
<tr class="separator:a313faba92d4638b21ad6d02ba7ca6e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adead435b14721f581a192b1e76b72a57"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#adead435b14721f581a192b1e76b72a57">doesIntersectGlobalRay:</a></td></tr>
<tr class="separator:adead435b14721f581a192b1e76b72a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a35c89194bf1cebe32a437994811d5"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a78a35c89194bf1cebe32a437994811d5">doesIntersectNode:</a></td></tr>
<tr class="separator:a78a35c89194bf1cebe32a437994811d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55c938a9d4c2047ae3b8694da466e3a"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab55c938a9d4c2047ae3b8694da466e3a">doNotBufferVertexBitangents</a></td></tr>
<tr class="separator:ab55c938a9d4c2047ae3b8694da466e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7d6416509ce1b148a324fb1ec104f9"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a3c7d6416509ce1b148a324fb1ec104f9">doNotBufferVertexBoneIndices</a></td></tr>
<tr class="separator:a3c7d6416509ce1b148a324fb1ec104f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4c97b6f8287122ab7f1e8fdb756f57"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#afa4c97b6f8287122ab7f1e8fdb756f57">doNotBufferVertexBoneWeights</a></td></tr>
<tr class="separator:afa4c97b6f8287122ab7f1e8fdb756f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4073440a0b8f9c18533cbc5121649657"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a4073440a0b8f9c18533cbc5121649657">doNotBufferVertexColors</a></td></tr>
<tr class="separator:a4073440a0b8f9c18533cbc5121649657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fda733fd787be5d6573ec8d5508bbd"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ac4fda733fd787be5d6573ec8d5508bbd">doNotBufferVertexContent</a></td></tr>
<tr class="separator:ac4fda733fd787be5d6573ec8d5508bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17688b23c1dea97ed7b7419bf4d3b789"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a17688b23c1dea97ed7b7419bf4d3b789">doNotBufferVertexIndices</a></td></tr>
<tr class="separator:a17688b23c1dea97ed7b7419bf4d3b789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c776539f12809fbf268332920a7f21d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a1c776539f12809fbf268332920a7f21d">doNotBufferVertexLocations</a></td></tr>
<tr class="separator:a1c776539f12809fbf268332920a7f21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a1d834d261b862e7af1f7426c071d5"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#af3a1d834d261b862e7af1f7426c071d5">doNotBufferVertexNormals</a></td></tr>
<tr class="separator:af3a1d834d261b862e7af1f7426c071d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeb4f470fd90218ba3fd2f7186ec5b7"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#acfeb4f470fd90218ba3fd2f7186ec5b7">doNotBufferVertexPointSizes</a></td></tr>
<tr class="separator:acfeb4f470fd90218ba3fd2f7186ec5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317cb1eaaaf32e24e07d1a5bdfbd3492"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a317cb1eaaaf32e24e07d1a5bdfbd3492">doNotBufferVertexTangents</a></td></tr>
<tr class="separator:a317cb1eaaaf32e24e07d1a5bdfbd3492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388e8ab71dceb5b771695ce8785ac411"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a388e8ab71dceb5b771695ce8785ac411">doNotBufferVertexTextureCoordinates</a></td></tr>
<tr class="separator:a388e8ab71dceb5b771695ce8785ac411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883c0a80269bd598483d19480b8276ec"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a883c0a80269bd598483d19480b8276ec">drawWithVisitor:</a></td></tr>
<tr class="separator:a883c0a80269bd598483d19480b8276ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dd9586285a4d0f067ecd47da59bb6d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a34dd9586285a4d0f067ecd47da59bb6d">enableAllAnimation</a></td></tr>
<tr class="separator:a34dd9586285a4d0f067ecd47da59bb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69acc185333a63456a5f162b1204d0d6"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a69acc185333a63456a5f162b1204d0d6">enableAllAnimationOnTrack:</a></td></tr>
<tr class="separator:a69acc185333a63456a5f162b1204d0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fb074bec3c33d3bfa380524e77e62d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ac0fb074bec3c33d3bfa380524e77e62d">enableAllLocationAnimation</a></td></tr>
<tr class="separator:ac0fb074bec3c33d3bfa380524e77e62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae082fcef2f26523d0549e66ecd59ea"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a1ae082fcef2f26523d0549e66ecd59ea">enableAllQuaternionAnimation</a></td></tr>
<tr class="separator:a1ae082fcef2f26523d0549e66ecd59ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5637a04b6202d4d787d6165de26bf107"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a5637a04b6202d4d787d6165de26bf107">enableAllScaleAnimation</a></td></tr>
<tr class="separator:a5637a04b6202d4d787d6165de26bf107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cf45674854a31d378335fd7b281876"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aa8cf45674854a31d378335fd7b281876">enableAnimation</a></td></tr>
<tr class="separator:aa8cf45674854a31d378335fd7b281876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b09569f0076e3c300462ddfa8ad63bc"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a1b09569f0076e3c300462ddfa8ad63bc">enableAnimationOnTrack:</a></td></tr>
<tr class="separator:a1b09569f0076e3c300462ddfa8ad63bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd14c816b6b12361005eecdcaa8046fe"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#abd14c816b6b12361005eecdcaa8046fe">enableLocationAnimation</a></td></tr>
<tr class="separator:abd14c816b6b12361005eecdcaa8046fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5406dfb6a05193cbe0be912e7de361d8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a5406dfb6a05193cbe0be912e7de361d8">enableQuaternionAnimation</a></td></tr>
<tr class="separator:a5406dfb6a05193cbe0be912e7de361d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1061c71857ea80540734ec72c7e23775"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a1061c71857ea80540734ec72c7e23775">enableScaleAnimation</a></td></tr>
<tr class="separator:a1061c71857ea80540734ec72c7e23775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7870cccbb1985f474af3d6371c424864"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a7870cccbb1985f474af3d6371c424864">ensureRigidSkeleton</a></td></tr>
<tr class="separator:a7870cccbb1985f474af3d6371c424864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08324d2813c786fd2fafc8c44c21a0b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#af08324d2813c786fd2fafc8c44c21a0b">establishAnimationFrameAt:</a></td></tr>
<tr class="separator:af08324d2813c786fd2fafc8c44c21a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4daf4a21295df23d8d3f639db6ef9dd6"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a4daf4a21295df23d8d3f639db6ef9dd6">establishAnimationFrameAt:onTrack:</a></td></tr>
<tr class="separator:a4daf4a21295df23d8d3f639db6ef9dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cb65f70ddb6eaec978f886ceabb06a"><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a14cb65f70ddb6eaec978f886ceabb06a">flatten</a></td></tr>
<tr class="separator:a14cb65f70ddb6eaec978f886ceabb06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcad39de9f43a824ef4c53d65ac07c8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a6dcad39de9f43a824ef4c53d65ac07c8">flattenInto:</a></td></tr>
<tr class="separator:a6dcad39de9f43a824ef4c53d65ac07c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bfccfa645a61fe67d068c20217d66f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a18bfccfa645a61fe67d068c20217d66f">flipNormals</a></td></tr>
<tr class="separator:a18bfccfa645a61fe67d068c20217d66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5087537210ebcd64eaf0d49843b63b44"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a5087537210ebcd64eaf0d49843b63b44">flipTexturesHorizontally</a></td></tr>
<tr class="separator:a5087537210ebcd64eaf0d49843b63b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e7c986cb22b878ca15d86d111b1f12"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a78e7c986cb22b878ca15d86d111b1f12">flipTexturesVertically</a></td></tr>
<tr class="separator:a78e7c986cb22b878ca15d86d111b1f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d0d09d98d31516204e0e3ad8e227e2"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a61d0d09d98d31516204e0e3ad8e227e2">freezeAllInanimatesOnTrack:</a></td></tr>
<tr class="separator:a61d0d09d98d31516204e0e3ad8e227e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d611a8024784bc8a16f4a4a95699a13"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a7d611a8024784bc8a16f4a4a95699a13">freezeIfInanimateOnTrack:</a></td></tr>
<tr class="separator:a7d611a8024784bc8a16f4a4a95699a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074b619d6b1473f6a70e8aeb121ca234"><td class="memItemLeft" align="right" valign="top">(CCAction *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a074b619d6b1473f6a70e8aeb121ca234">getActionByTag:</a></td></tr>
<tr class="separator:a074b619d6b1473f6a70e8aeb121ca234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b9c12cfd93822e1c38fa862b962fbc"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node_animation.html">CC3NodeAnimation</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a29b9c12cfd93822e1c38fa862b962fbc">getAnimationOnTrack:</a></td></tr>
<tr class="separator:a29b9c12cfd93822e1c38fa862b962fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2044d57de11fedaafbf51d153eec363"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node_animation_state.html">CC3NodeAnimationState</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab2044d57de11fedaafbf51d153eec363">getAnimationStateOnTrack:</a></td></tr>
<tr class="separator:ab2044d57de11fedaafbf51d153eec363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad53c9ac68bd48cb9675a919b1507fb"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a0ad53c9ac68bd48cb9675a919b1507fb">getMeshNodeNamed:</a></td></tr>
<tr class="separator:a0ad53c9ac68bd48cb9675a919b1507fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cd132329b6a2a98cf1456f3fe58275"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a42cd132329b6a2a98cf1456f3fe58275">getNodeNamed:</a></td></tr>
<tr class="separator:a42cd132329b6a2a98cf1456f3fe58275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4927d3aca147fe0993ae4c29f6d9c1"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a8f4927d3aca147fe0993ae4c29f6d9c1">getNodeTagged:</a></td></tr>
<tr class="separator:a8f4927d3aca147fe0993ae4c29f6d9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe8ee8dc78ba7d6db86f48475c2dd48"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_shadow_volume_mesh_node.html">CC3ShadowVolumeMeshNode</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aabe8ee8dc78ba7d6db86f48475c2dd48">getShadowVolumeForLight:</a></td></tr>
<tr class="separator:aabe8ee8dc78ba7d6db86f48475c2dd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195ba5dba8708a36b093319bd58521d1"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a195ba5dba8708a36b093319bd58521d1">globalLocationOfGlobalRayIntesection:</a></td></tr>
<tr class="separator:a195ba5dba8708a36b093319bd58521d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38803f8979b66c35acb77bb51e084d0"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ae38803f8979b66c35acb77bb51e084d0">globalRotationMatrix</a></td></tr>
<tr class="separator:ae38803f8979b66c35acb77bb51e084d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3061a77b9f3bc1a77e1d41a732911f2b"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a3061a77b9f3bc1a77e1d41a732911f2b">hasShadowVolumes</a></td></tr>
<tr class="separator:a3061a77b9f3bc1a77e1d41a732911f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0723edbc79ce0b3518e11f35594ccd41"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a0723edbc79ce0b3518e11f35594ccd41">hasShadowVolumesForLight:</a></td></tr>
<tr class="separator:a0723edbc79ce0b3518e11f35594ccd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af601798fa0d66d6bdb962589d9773087"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#af601798fa0d66d6bdb962589d9773087">hide</a></td></tr>
<tr class="separator:af601798fa0d66d6bdb962589d9773087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966505787ca1b75d7f2401b7677f25bb"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a966505787ca1b75d7f2401b7677f25bb">isAnimationEnabledOnTrack:</a></td></tr>
<tr class="separator:a966505787ca1b75d7f2401b7677f25bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde494ed8885dc8873dfd104e1622394"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#afde494ed8885dc8873dfd104e1622394">isDescendantOf:</a></td></tr>
<tr class="separator:afde494ed8885dc8873dfd104e1622394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652b0691f722e172b87cd5a9c10647ee"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a652b0691f722e172b87cd5a9c10647ee">isShadowVisible</a></td></tr>
<tr class="separator:a652b0691f722e172b87cd5a9c10647ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970a4514c1af06c66382cef4b4135376"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a970a4514c1af06c66382cef4b4135376">linkToPODNodes:</a></td></tr>
<tr class="separator:a970a4514c1af06c66382cef4b4135376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac29283d3443c07a8e64bb4c87ec45f"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a1ac29283d3443c07a8e64bb4c87ec45f">locationOfGlobalRayIntesection:</a></td></tr>
<tr class="separator:a1ac29283d3443c07a8e64bb4c87ec45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994aee6e1428f7005f896611361a5d6f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a994aee6e1428f7005f896611361a5d6f">markAnimationDirty</a></td></tr>
<tr class="separator:a994aee6e1428f7005f896611361a5d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1086b8f97c7efeeaf49e7b3e842ebdd8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a1086b8f97c7efeeaf49e7b3e842ebdd8">markBoundingVolumeDirty</a></td></tr>
<tr class="separator:a1086b8f97c7efeeaf49e7b3e842ebdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe610fe825b7adc7c427df840a521712"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#abe610fe825b7adc7c427df840a521712">markTransformDirty</a></td></tr>
<tr class="separator:abe610fe825b7adc7c427df840a521712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05df079c40cdd3d2bb7661b14afeb0d9"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a>)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a05df079c40cdd3d2bb7661b14afeb0d9">nodePODStructAtIndex:fromPODResource:</a></td></tr>
<tr class="separator:a05df079c40cdd3d2bb7661b14afeb0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e69c96f4b6508528e82398d372e4bc"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_node_puncturing_visitor.html">CC3NodePuncturingVisitor</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ac1e69c96f4b6508528e82398d372e4bc">nodesIntersectedByGlobalRay:</a></td></tr>
<tr class="separator:ac1e69c96f4b6508528e82398d372e4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64f643344ead97b9f4cf56082d70d6c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aa64f643344ead97b9f4cf56082d70d6c">nodeWasDestroyed:</a></td></tr>
<tr class="separator:aa64f643344ead97b9f4cf56082d70d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3ff422c4cee814c5c3a9863f3f72a7"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ace3ff422c4cee814c5c3a9863f3f72a7">nodeWasTransformed:</a></td></tr>
<tr class="separator:ace3ff422c4cee814c5c3a9863f3f72a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a856eaeac4bb517a2b76c2124733ddc"><td class="memItemLeft" align="right" valign="top">(NSInteger)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a6a856eaeac4bb517a2b76c2124733ddc">numberOfRunningActions</a></td></tr>
<tr class="separator:a6a856eaeac4bb517a2b76c2124733ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e37f720209024c758ec4cd1a834c815"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a6e37f720209024c758ec4cd1a834c815">pauseAllActions</a></td></tr>
<tr class="separator:a6e37f720209024c758ec4cd1a834c815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e40a66f9647fc9a7ff01de3cc2645db"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a5e40a66f9647fc9a7ff01de3cc2645db">prewarmForShadowVolumes</a></td></tr>
<tr class="separator:a5e40a66f9647fc9a7ff01de3cc2645db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefaf0265e8b2f99e9ab38cef8694805c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aefaf0265e8b2f99e9ab38cef8694805c">reattachBonesFrom:</a></td></tr>
<tr class="separator:aefaf0265e8b2f99e9ab38cef8694805c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b9ca835a8707f654c348301144d5bd"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a12b9ca835a8707f654c348301144d5bd">releaseRedundantContent</a></td></tr>
<tr class="separator:a12b9ca835a8707f654c348301144d5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab638f5dbea673bc7b88dc311bf7ae470"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab638f5dbea673bc7b88dc311bf7ae470">remove</a></td></tr>
<tr class="separator:ab638f5dbea673bc7b88dc311bf7ae470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0532b78d1036a404f8dd6d87b97d4e87"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a0532b78d1036a404f8dd6d87b97d4e87">removeAllChildren</a></td></tr>
<tr class="separator:a0532b78d1036a404f8dd6d87b97d4e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae4e44bd04d192def8a432fe0bb397e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#abae4e44bd04d192def8a432fe0bb397e">removeAllDirectionMarkers</a></td></tr>
<tr class="separator:abae4e44bd04d192def8a432fe0bb397e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0301c693a7d708653ef5f216b4ff47ea"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a0301c693a7d708653ef5f216b4ff47ea">removeAllTransformListeners</a></td></tr>
<tr class="separator:a0301c693a7d708653ef5f216b4ff47ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdd8450a201128f4034d63f2eb1dee4"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#affdd8450a201128f4034d63f2eb1dee4">removeAnimation:</a></td></tr>
<tr class="separator:affdd8450a201128f4034d63f2eb1dee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab825fc724f9d83dac4876f077c50364e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab825fc724f9d83dac4876f077c50364e">removeAnimationState:</a></td></tr>
<tr class="separator:ab825fc724f9d83dac4876f077c50364e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ce0c5d88798d68ac35e306c93d4c40"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a77ce0c5d88798d68ac35e306c93d4c40">removeAnimationTrack:</a></td></tr>
<tr class="separator:a77ce0c5d88798d68ac35e306c93d4c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8f89a7edb29eb961336837f4cf3dd5"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aba8f89a7edb29eb961336837f4cf3dd5">removeChild:</a></td></tr>
<tr class="separator:aba8f89a7edb29eb961336837f4cf3dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b26864bdd4e165a33e9dc93b27e2ebd"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a4b26864bdd4e165a33e9dc93b27e2ebd">removeShaders</a></td></tr>
<tr class="separator:a4b26864bdd4e165a33e9dc93b27e2ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfe025f79b0e7ce367b5e2e43818aa3"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#abdfe025f79b0e7ce367b5e2e43818aa3">removeShadowVolumes</a></td></tr>
<tr class="separator:abdfe025f79b0e7ce367b5e2e43818aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d0af035ee74b21441ff1860a4094db"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a55d0af035ee74b21441ff1860a4094db">removeShadowVolumesForLight:</a></td></tr>
<tr class="separator:a55d0af035ee74b21441ff1860a4094db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08506fd072f51e411bb330f4767a26d7"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a08506fd072f51e411bb330f4767a26d7">removeTransformListener:</a></td></tr>
<tr class="separator:a08506fd072f51e411bb330f4767a26d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bbb4ec4f75df2db53169ccdd74011b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a49bbb4ec4f75df2db53169ccdd74011b">resumeAllActions</a></td></tr>
<tr class="separator:a49bbb4ec4f75df2db53169ccdd74011b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bccb6952665f28e3f7852acbfb2f68"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a04bccb6952665f28e3f7852acbfb2f68">retainVertexBitangents</a></td></tr>
<tr class="separator:a04bccb6952665f28e3f7852acbfb2f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacad82a5d895bb394f28a1a63943450e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aacad82a5d895bb394f28a1a63943450e">retainVertexBoneIndices</a></td></tr>
<tr class="separator:aacad82a5d895bb394f28a1a63943450e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93574c731d7af8c6cee90cdac1a3951b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a93574c731d7af8c6cee90cdac1a3951b">retainVertexBoneWeights</a></td></tr>
<tr class="separator:a93574c731d7af8c6cee90cdac1a3951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6580702191d386d7495c6801a016ce"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aae6580702191d386d7495c6801a016ce">retainVertexColors</a></td></tr>
<tr class="separator:aae6580702191d386d7495c6801a016ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d4afc9b9fff75fe8bf65ad14496b23"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a82d4afc9b9fff75fe8bf65ad14496b23">retainVertexContent</a></td></tr>
<tr class="separator:a82d4afc9b9fff75fe8bf65ad14496b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af476409b656940fe8fd6e348b5b8b2be"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#af476409b656940fe8fd6e348b5b8b2be">retainVertexIndices</a></td></tr>
<tr class="separator:af476409b656940fe8fd6e348b5b8b2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cdb8a721320e3b4aa237389eeb117a"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a99cdb8a721320e3b4aa237389eeb117a">retainVertexLocations</a></td></tr>
<tr class="separator:a99cdb8a721320e3b4aa237389eeb117a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dc7d2c118673a0690be00d450094ab"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a41dc7d2c118673a0690be00d450094ab">retainVertexNormals</a></td></tr>
<tr class="separator:a41dc7d2c118673a0690be00d450094ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cae4ff654855d167acbdf21ad9ea487"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a1cae4ff654855d167acbdf21ad9ea487">retainVertexPointSizes</a></td></tr>
<tr class="separator:a1cae4ff654855d167acbdf21ad9ea487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328df8f0c825def35671b0aa343edbc1"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a328df8f0c825def35671b0aa343edbc1">retainVertexTangents</a></td></tr>
<tr class="separator:a328df8f0c825def35671b0aa343edbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f757942e44ce601a9d72eedca5a1f2a"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a3f757942e44ce601a9d72eedca5a1f2a">retainVertexTextureCoordinates</a></td></tr>
<tr class="separator:a3f757942e44ce601a9d72eedca5a1f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31dc98fcd8cf5cfe08414ffd1d221e6"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ae31dc98fcd8cf5cfe08414ffd1d221e6">rotateBy:</a></td></tr>
<tr class="separator:ae31dc98fcd8cf5cfe08414ffd1d221e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84672c16d621066005bf26916e2103e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ae84672c16d621066005bf26916e2103e">rotateByAngle:aroundAxis:</a></td></tr>
<tr class="separator:ae84672c16d621066005bf26916e2103e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc504304b527c0475ead41b8ea8fa00c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#afc504304b527c0475ead41b8ea8fa00c">rotateByAngle:aroundAxis:atLocation:</a></td></tr>
<tr class="separator:afc504304b527c0475ead41b8ea8fa00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa60c56626c0ca8bd7d94af4aeaf8bed"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aaa60c56626c0ca8bd7d94af4aeaf8bed">rotateByQuaternion:</a></td></tr>
<tr class="separator:aaa60c56626c0ca8bd7d94af4aeaf8bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bc1389a0a31d1684f197ed50e24677"><td class="memItemLeft" align="right" valign="top">(CCAction *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a88bc1389a0a31d1684f197ed50e24677">runAction:</a></td></tr>
<tr class="separator:a88bc1389a0a31d1684f197ed50e24677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52947dbc390c443e3fec75c2ec139875"><td class="memItemLeft" align="right" valign="top">(CCAction *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a52947dbc390c443e3fec75c2ec139875">runAction:withTag:</a></td></tr>
<tr class="separator:a52947dbc390c443e3fec75c2ec139875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204e8eded1fcebad408b1a11dfdecdc7"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a204e8eded1fcebad408b1a11dfdecdc7">selectShaders</a></td></tr>
<tr class="separator:a204e8eded1fcebad408b1a11dfdecdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa083e04f6344b05eea661820086eeed7"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aa083e04f6344b05eea661820086eeed7">setAnimationBlendingWeight:onTrack:</a></td></tr>
<tr class="separator:aa083e04f6344b05eea661820086eeed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b87b6c17ec84530d378fa2d0a2d74d0"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a8b87b6c17ec84530d378fa2d0a2d74d0">setSkeletalBoundingVolume:</a></td></tr>
<tr class="separator:a8b87b6c17ec84530d378fa2d0a2d74d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d93096313f1fdb93e268bcc391910d5"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a4d93096313f1fdb93e268bcc391910d5">show</a></td></tr>
<tr class="separator:a4d93096313f1fdb93e268bcc391910d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5491e5b27a1c2c241cbc0389a1c25ed8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a5491e5b27a1c2c241cbc0389a1c25ed8">stopAction:</a></td></tr>
<tr class="separator:a5491e5b27a1c2c241cbc0389a1c25ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1734b48ce0028d269e7b3c83fdb404"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a7d1734b48ce0028d269e7b3c83fdb404">stopActionByTag:</a></td></tr>
<tr class="separator:a7d1734b48ce0028d269e7b3c83fdb404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b01f39758bd6f3f8e906b7a2fb0e6b3"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a6b01f39758bd6f3f8e906b7a2fb0e6b3">stopAllActions</a></td></tr>
<tr class="separator:a6b01f39758bd6f3f8e906b7a2fb0e6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82ef9ad2019facf5e9abce84ab60407"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab82ef9ad2019facf5e9abce84ab60407">touchDisableAll</a></td></tr>
<tr class="separator:ab82ef9ad2019facf5e9abce84ab60407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67c8b5f44c53322c4eebc9f5254cf61"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#aa67c8b5f44c53322c4eebc9f5254cf61">touchEnableAll</a></td></tr>
<tr class="separator:aa67c8b5f44c53322c4eebc9f5254cf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eedf769aba75fa6b0d51a5e330bcb7c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a0eedf769aba75fa6b0d51a5e330bcb7c">trackTargetWithVisitor:</a></td></tr>
<tr class="separator:a0eedf769aba75fa6b0d51a5e330bcb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422d97fc205cb37b3386424a19d7fa83"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a422d97fc205cb37b3386424a19d7fa83">transformAndDrawWithVisitor:</a></td></tr>
<tr class="separator:a422d97fc205cb37b3386424a19d7fa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac184ae5d67268b69539f89d90ac04676"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ac184ae5d67268b69539f89d90ac04676">translateBy:</a></td></tr>
<tr class="separator:ac184ae5d67268b69539f89d90ac04676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c74947cca4fdd39d89ea8cdf6e48dca"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a3c74947cca4fdd39d89ea8cdf6e48dca">updateAfterTransform:</a></td></tr>
<tr class="separator:a3c74947cca4fdd39d89ea8cdf6e48dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33607fc5db4c079ebfb42d9da5acbea"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ab33607fc5db4c079ebfb42d9da5acbea">updateBeforeTransform:</a></td></tr>
<tr class="separator:ab33607fc5db4c079ebfb42d9da5acbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd1682dc37bdbbd15763203bb897dfd"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#a6bd1682dc37bdbbd15763203bb897dfd">wasAdded</a></td></tr>
<tr class="separator:a6bd1682dc37bdbbd15763203bb897dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae728eca9485726ddd19641aa6750fc07"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_node.html#ae728eca9485726ddd19641aa6750fc07">wasRemoved</a></td></tr>
<tr class="separator:ae728eca9485726ddd19641aa6750fc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Instance Methods inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:a6048039af7b953470a6be1640f3f8fa8 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a6048039af7b953470a6be1640f3f8fa8">copyAsClass:</a></td></tr>
<tr class="separator:a6048039af7b953470a6be1640f3f8fa8 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba6f6333ec6b859b17394fa95a549f1 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aaba6f6333ec6b859b17394fa95a549f1">copyUserDataFrom:</a></td></tr>
<tr class="separator:aaba6f6333ec6b859b17394fa95a549f1 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3b74491add447b79ad63f7f9912b9e inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aff3b74491add447b79ad63f7f9912b9e">copyWithName:asClass:</a></td></tr>
<tr class="separator:aff3b74491add447b79ad63f7f9912b9e inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5698b73dad043a09dd57c19290c1dcf inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aa5698b73dad043a09dd57c19290c1dcf">copyWithZone:withName:</a></td></tr>
<tr class="separator:aa5698b73dad043a09dd57c19290c1dcf inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6788277bbfff67ed111f2392db9f685a inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a6788277bbfff67ed111f2392db9f685a">copyWithZone:withName:asClass:</a></td></tr>
<tr class="separator:a6788277bbfff67ed111f2392db9f685a inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c7dcbb20dd8712720519d0d0c2410b inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#ae9c7dcbb20dd8712720519d0d0c2410b">deriveNameFrom:</a></td></tr>
<tr class="separator:ae9c7dcbb20dd8712720519d0d0c2410b inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60ad034ddbb26e568589c5254c12bff inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aa60ad034ddbb26e568589c5254c12bff">deriveNameFrom:usingSuffix:</a></td></tr>
<tr class="separator:aa60ad034ddbb26e568589c5254c12bff inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84be89f3c9397c4247d406009137b5d inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#af84be89f3c9397c4247d406009137b5d">fullDescription</a></td></tr>
<tr class="separator:af84be89f3c9397c4247d406009137b5d inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51802b824fd430e3281e22574f1266ed inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a51802b824fd430e3281e22574f1266ed">init</a></td></tr>
<tr class="separator:a51802b824fd430e3281e22574f1266ed inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf728516905642fd71b913636fab13c0 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#adf728516905642fd71b913636fab13c0">initAtIndex:fromPODResource:</a></td></tr>
<tr class="separator:adf728516905642fd71b913636fab13c0 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096bc5294d2cc78dd979782504456569 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a096bc5294d2cc78dd979782504456569">initUserData</a></td></tr>
<tr class="separator:a096bc5294d2cc78dd979782504456569 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc220d9cffa20a01ecebefa44a44f354 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#afc220d9cffa20a01ecebefa44a44f354">initWithName:</a></td></tr>
<tr class="separator:afc220d9cffa20a01ecebefa44a44f354 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d154e055437d2e0ba9e707a69e3ec0 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#af7d154e055437d2e0ba9e707a69e3ec0">initWithTag:</a></td></tr>
<tr class="separator:af7d154e055437d2e0ba9e707a69e3ec0 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e0ab825fd6f3e9a703d28039c98886 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a36e0ab825fd6f3e9a703d28039c98886">initWithTag:withName:</a></td></tr>
<tr class="separator:a36e0ab825fd6f3e9a703d28039c98886 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30472ca8359ea9480479ed8301a93eb8 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a30472ca8359ea9480479ed8301a93eb8">nextTag</a></td></tr>
<tr class="separator:a30472ca8359ea9480479ed8301a93eb8 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b647607269d0c6bce0d69459d4b7dea inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a5b647607269d0c6bce0d69459d4b7dea">populateFrom:</a></td></tr>
<tr class="separator:a5b647607269d0c6bce0d69459d4b7dea inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Class Methods</h2></td></tr>
<tr class="memitem:abfe000a231f61220f6c716fedbcb9df9"><td class="memItemLeft" align="right" valign="top">(GLfloat)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#abfe000a231f61220f6c716fedbcb9df9">__deprecated</a></td></tr>
<tr class="separator:abfe000a231f61220f6c716fedbcb9df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca18dcafe9eb909c1828835372e5dc38"><td class="memItemLeft" align="right" valign="top">(CGFloat)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#aca18dcafe9eb909c1828835372e5dc38">descriptorFontSize</a></td></tr>
<tr class="separator:aca18dcafe9eb909c1828835372e5dc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9766013ea54fd0d093eb6c5eb622fb5"><td class="memItemLeft" align="right" valign="top">(ccColor4F)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#ad9766013ea54fd0d093eb6c5eb622fb5">directionMarkerColor</a></td></tr>
<tr class="separator:ad9766013ea54fd0d093eb6c5eb622fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d70878798bce4171f1d4350c44d8a5"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#ad6d70878798bce4171f1d4350c44d8a5">node</a></td></tr>
<tr class="separator:ad6d70878798bce4171f1d4350c44d8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047b778650783f9028e1c64921d5b459"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#a047b778650783f9028e1c64921d5b459">nodeAtIndex:fromPODResource:</a></td></tr>
<tr class="separator:a047b778650783f9028e1c64921d5b459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee98350cf8efb119effb2bb42537b420"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#aee98350cf8efb119effb2bb42537b420">nodeWithName:</a></td></tr>
<tr class="separator:aee98350cf8efb119effb2bb42537b420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a146da2a8401c683cc5cdd3524a577"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#a13a146da2a8401c683cc5cdd3524a577">nodeWithTag:</a></td></tr>
<tr class="separator:a13a146da2a8401c683cc5cdd3524a577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eec38a17f61714d1924669e556b530"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#ae7eec38a17f61714d1924669e556b530">nodeWithTag:withName:</a></td></tr>
<tr class="separator:ae7eec38a17f61714d1924669e556b530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca0220c5456f6a204665cadff58a780"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#acca0220c5456f6a204665cadff58a780">setDefaultScaleTolerance:</a></td></tr>
<tr class="separator:acca0220c5456f6a204665cadff58a780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4305b124b27d89d50b859f9ebff784"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#a9d4305b124b27d89d50b859f9ebff784">setDescriptorFontSize:</a></td></tr>
<tr class="separator:a9d4305b124b27d89d50b859f9ebff784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba164580d0895194fbf3a5b859ecb60"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#a4ba164580d0895194fbf3a5b859ecb60">setDirectionMarkerColor:</a></td></tr>
<tr class="separator:a4ba164580d0895194fbf3a5b859ecb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69fcaf11981b068bcdc8963639c7317"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#ae69fcaf11981b068bcdc8963639c7317">setWireframeBoxColor:</a></td></tr>
<tr class="separator:ae69fcaf11981b068bcdc8963639c7317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bebe8af43ea7f80e5a6d8c1a333c09"><td class="memItemLeft" align="right" valign="top">(ccColor4F)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_node.html#a95bebe8af43ea7f80e5a6d8c1a333c09">wireframeBoxColor</a></td></tr>
<tr class="separator:a95bebe8af43ea7f80e5a6d8c1a333c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Class Methods inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:a13ae00555f231e938fcfed31769b8fef inherit pub_static_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(GLint)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_identifiable.html#a13ae00555f231e938fcfed31769b8fef">instanceCount</a></td></tr>
<tr class="separator:a13ae00555f231e938fcfed31769b8fef inherit pub_static_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb2e642c739adb8e0a70f98cf1bfcde inherit pub_static_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_identifiable.html#a0eb2e642c739adb8e0a70f98cf1bfcde">resetTagAllocation</a></td></tr>
<tr class="separator:a0eb2e642c739adb8e0a70f98cf1bfcde inherit pub_static_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a9978b3e942066d848862f0ddf1c2879f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> sceneUpDirection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a9978b3e942066d848862f0ddf1c2879f">__deprecated</a></td></tr>
<tr class="separator:a9978b3e942066d848862f0ddf1c2879f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5810dbc871619ae3a25f16b9d87764b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> worldUpDirection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a5810dbc871619ae3a25f16b9d87764b1">__deprecated</a></td></tr>
<tr class="separator:a5810dbc871619ae3a25f16b9d87764b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768cba72501db26953306ee19d69aa4f"><td class="memItemLeft" align="right" valign="top">GLfloat scaleTolerance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a768cba72501db26953306ee19d69aa4f">__deprecated</a></td></tr>
<tr class="separator:a768cba72501db26953306ee19d69aa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c2203c5f79689baeafb6511fd7556a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_rotator_8h.html#afc5673e97432b6a4bee46ca01f979303">CC3TargettingConstraint</a> <br class="typebreak"/>
axisRestriction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a32c2203c5f79689baeafb6511fd7556a">__deprecated</a></td></tr>
<tr class="separator:a32c2203c5f79689baeafb6511fd7556a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee95ecb668094da8e79cfaaca03e256"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> globalLightLocation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a0ee95ecb668094da8e79cfaaca03e256">__deprecated</a></td></tr>
<tr class="separator:a0ee95ecb668094da8e79cfaaca03e256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e83ffc0f937a602d17ed5d1fac53393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a> *transformMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a8e83ffc0f937a602d17ed5d1fac53393">__deprecated</a></td></tr>
<tr class="separator:a8e83ffc0f937a602d17ed5d1fac53393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042b4d5c3f960c41590decd1fc896ed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a> *transformMatrixInverted&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a042b4d5c3f960c41590decd1fc896ed2">__deprecated</a></td></tr>
<tr class="separator:a042b4d5c3f960c41590decd1fc896ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacdbd6410fda6a2f98b0a2b19ffbd6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *dirtiestAncestor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#abacdbd6410fda6a2f98b0a2b19ffbd6b">__deprecated</a></td></tr>
<tr class="separator:abacdbd6410fda6a2f98b0a2b19ffbd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f823d6ebfe25a2b4cbdcedb8ec7d20e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a> <br class="typebreak"/>
*parentGlobalTransformMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a1f823d6ebfe25a2b4cbdcedb8ec7d20e">__deprecated</a></td></tr>
<tr class="separator:a1f823d6ebfe25a2b4cbdcedb8ec7d20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78489c6ba37567f1ca624293294b7a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a> *parentTransformMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ad78489c6ba37567f1ca624293294b7a7">__deprecated</a></td></tr>
<tr class="separator:ad78489c6ba37567f1ca624293294b7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908cd90a975e20fb20010ffe5c79ee23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_scene.html">CC3Scene</a> *world&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a908cd90a975e20fb20010ffe5c79ee23">__deprecated</a></td></tr>
<tr class="separator:a908cd90a975e20fb20010ffe5c79ee23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cf3478f3671dedb41a4a60ca8976a4"><td class="memItemLeft" align="right" valign="top">BOOL <br class="typebreak"/>
shouldCleanupActionsWhenRemoved&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab4cf3478f3671dedb41a4a60ca8976a4">__deprecated</a></td></tr>
<tr class="separator:ab4cf3478f3671dedb41a4a60ca8976a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8fac8bdff2bdd92a6df79f8afb48b4"><td class="memItemLeft" align="right" valign="top">BOOL shouldCleanupWhenRemoved&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a9f8fac8bdff2bdd92a6df79f8afb48b4">__deprecated</a></td></tr>
<tr class="separator:a9f8fac8bdff2bdd92a6df79f8afb48b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c93e6c1c60cf0757df9bd33cdc09fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_camera.html">CC3Camera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6c93e6c1c60cf0757df9bd33cdc09fbb">activeCamera</a></td></tr>
<tr class="separator:a6c93e6c1c60cf0757df9bd33cdc09fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fc1dcd7533a6d9f29564116ab7d3fe"><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a87fc1dcd7533a6d9f29564116ab7d3fe">ambientColor</a></td></tr>
<tr class="separator:a87fc1dcd7533a6d9f29564116ab7d3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5373d56dc052aecd0f81ba4107982b7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_animation.html">CC3NodeAnimation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a5373d56dc052aecd0f81ba4107982b7c">animation</a></td></tr>
<tr class="separator:a5373d56dc052aecd0f81ba4107982b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a691668927439a11ce912193faf2d46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_animation_state.html">CC3NodeAnimationState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6a691668927439a11ce912193faf2d46">animationState</a></td></tr>
<tr class="separator:a6a691668927439a11ce912193faf2d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98fb62a333ea1cc0fdbe4d401c0e2aa"><td class="memItemLeft" align="right" valign="top">ccBlendFunc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af98fb62a333ea1cc0fdbe4d401c0e2aa">blendFunc</a></td></tr>
<tr class="separator:af98fb62a333ea1cc0fdbe4d401c0e2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707ebf00f2c8d22fc99b53cd9503678c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_box.html">CC3Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a707ebf00f2c8d22fc99b53cd9503678c">boundingBox</a></td></tr>
<tr class="separator:a707ebf00f2c8d22fc99b53cd9503678c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68af664d6e99946dad0a3d90462ea744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_bounding_volume.html">CC3NodeBoundingVolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a68af664d6e99946dad0a3d90462ea744">boundingVolume</a></td></tr>
<tr class="separator:a68af664d6e99946dad0a3d90462ea744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7733dc8471757b6109d86e7fb688cbf7"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a7733dc8471757b6109d86e7fb688cbf7">boundingVolumePadding</a></td></tr>
<tr class="separator:a7733dc8471757b6109d86e7fb688cbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73616444ed3fc114a8ad59e6be9babee"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a73616444ed3fc114a8ad59e6be9babee">cameraDistanceProduct</a></td></tr>
<tr class="separator:a73616444ed3fc114a8ad59e6be9babee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac165afbc71dec4bbcd1cfae54c52ffe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ac165afbc71dec4bbcd1cfae54c52ffe8">centerOfGeometry</a></td></tr>
<tr class="separator:ac165afbc71dec4bbcd1cfae54c52ffe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710e83cae07a116b0f068a57f78a245b"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a710e83cae07a116b0f068a57f78a245b">children</a></td></tr>
<tr class="separator:a710e83cae07a116b0f068a57f78a245b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad829a1f147dd9be0b2f6289385682de5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_c_c2_extensions_8h.html#a9ee2c61886665ba64b5de7be1a1bf83d">CCColorRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ad829a1f147dd9be0b2f6289385682de5">color</a></td></tr>
<tr class="separator:ad829a1f147dd9be0b2f6289385682de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daa5b2b6ffe4a8e369551e8342c1359"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6daa5b2b6ffe4a8e369551e8342c1359">containsAnimation</a></td></tr>
<tr class="separator:a6daa5b2b6ffe4a8e369551e8342c1359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b6459ed926cf832f3c3c736da55f9f"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab1b6459ed926cf832f3c3c736da55f9f">decalOffsetFactor</a></td></tr>
<tr class="separator:ab1b6459ed926cf832f3c3c736da55f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e8694bf6bf60f3f73a201dd6ac2fcb"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a08e8694bf6bf60f3f73a201dd6ac2fcb">decalOffsetUnits</a></td></tr>
<tr class="separator:a08e8694bf6bf60f3f73a201dd6ac2fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5a7a014ef8c5297a0d2a5a74442316"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a8b5a7a014ef8c5297a0d2a5a74442316">depthFunction</a></td></tr>
<tr class="separator:a8b5a7a014ef8c5297a0d2a5a74442316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dedd671475792c90a14ba94f867d6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_descriptor.html">CC3NodeDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae7dedd671475792c90a14ba94f867d6d">descriptorNode</a></td></tr>
<tr class="separator:ae7dedd671475792c90a14ba94f867d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb07b8079bf75af208434b5360cc58b"><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a0bb07b8079bf75af208434b5360cc58b">diffuseColor</a></td></tr>
<tr class="separator:a0bb07b8079bf75af208434b5360cc58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2209e5b3cde94de7cee8a32cb50970c"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af2209e5b3cde94de7cee8a32cb50970c">directionMarkers</a></td></tr>
<tr class="separator:af2209e5b3cde94de7cee8a32cb50970c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821370544c7d36e7cbb742988b936102"><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a821370544c7d36e7cbb742988b936102">emissionColor</a></td></tr>
<tr class="separator:a821370544c7d36e7cbb742988b936102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93791d6535584f5f2a01132eb600d051"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a93791d6535584f5f2a01132eb600d051">expectsVerticallyFlippedTextures</a></td></tr>
<tr class="separator:a93791d6535584f5f2a01132eb600d051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace91e6e8d7aa2448ecf0e05b69358099"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ace91e6e8d7aa2448ecf0e05b69358099">forwardDirection</a></td></tr>
<tr class="separator:ace91e6e8d7aa2448ecf0e05b69358099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5908c5348fefc150081fc467bf3160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_box.html">CC3Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a2f5908c5348fefc150081fc467bf3160">globalBoundingBox</a></td></tr>
<tr class="separator:a2f5908c5348fefc150081fc467bf3160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc22d73847310f1201968c6f40921200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#acc22d73847310f1201968c6f40921200">globalCenterOfGeometry</a></td></tr>
<tr class="separator:acc22d73847310f1201968c6f40921200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530c7446c691efd97f83804c4251a644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a530c7446c691efd97f83804c4251a644">globalForwardDirection</a></td></tr>
<tr class="separator:a530c7446c691efd97f83804c4251a644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168499724355b3e405d770e3e6176974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a168499724355b3e405d770e3e6176974">globalHomogeneousPosition</a></td></tr>
<tr class="separator:a168499724355b3e405d770e3e6176974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526c2c85371de43cc7f1ddabb8874bb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a526c2c85371de43cc7f1ddabb8874bb2">globalLightPosition</a></td></tr>
<tr class="separator:a526c2c85371de43cc7f1ddabb8874bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ca6732d1834fb1ad348a190f810121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ad0ca6732d1834fb1ad348a190f810121">globalLocation</a></td></tr>
<tr class="separator:ad0ca6732d1834fb1ad348a190f810121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6333466c83a1709f7a1cb7e5d15daddd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6333466c83a1709f7a1cb7e5d15daddd">globalRightDirection</a></td></tr>
<tr class="separator:a6333466c83a1709f7a1cb7e5d15daddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3a431575f6e933f31ba2a8d9fa54e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a4b3a431575f6e933f31ba2a8d9fa54e0">globalRotation</a></td></tr>
<tr class="separator:a4b3a431575f6e933f31ba2a8d9fa54e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e0823f5a3988cbd52c2bc566a5f492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a14e0823f5a3988cbd52c2bc566a5f492">globalScale</a></td></tr>
<tr class="separator:a14e0823f5a3988cbd52c2bc566a5f492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ebf7b4acebdbe4d109d7ae71318196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a92ebf7b4acebdbe4d109d7ae71318196">globalTransformMatrix</a></td></tr>
<tr class="separator:a92ebf7b4acebdbe4d109d7ae71318196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca936278e62c47c93bf0fd6eec86500c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aca936278e62c47c93bf0fd6eec86500c">globalTransformMatrixInverted</a></td></tr>
<tr class="separator:aca936278e62c47c93bf0fd6eec86500c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97970afde522625afa1c5be2b520827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae97970afde522625afa1c5be2b520827">globalUpDirection</a></td></tr>
<tr class="separator:ae97970afde522625afa1c5be2b520827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae984cc3ad8b86f4a031fa569d7745161"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae984cc3ad8b86f4a031fa569d7745161">hasLocalContent</a></td></tr>
<tr class="separator:ae984cc3ad8b86f4a031fa569d7745161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dc69f8df858e108e70fc9f6258a347"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab7dc69f8df858e108e70fc9f6258a347">hasSoftBodyContent</a></td></tr>
<tr class="separator:ab7dc69f8df858e108e70fc9f6258a347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a36b58203368ce77f3c7ab8803a568"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a67a36b58203368ce77f3c7ab8803a568">hasTarget</a></td></tr>
<tr class="separator:a67a36b58203368ce77f3c7ab8803a568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3066628bf8e7d7ec14ed8a13670371c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ad3066628bf8e7d7ec14ed8a13670371c">isAnimationEnabled</a></td></tr>
<tr class="separator:ad3066628bf8e7d7ec14ed8a13670371c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a798d71f952da9502d312719c88f3f"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a58a798d71f952da9502d312719c88f3f">isBasePODNode</a></td></tr>
<tr class="separator:a58a798d71f952da9502d312719c88f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfa79dcdf72a6f16eaafc208978d50b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a8cfa79dcdf72a6f16eaafc208978d50b">isBillboard</a></td></tr>
<tr class="separator:a8cfa79dcdf72a6f16eaafc208978d50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3386cb5bc0372362bafc80abdfef7633"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3386cb5bc0372362bafc80abdfef7633">isCamera</a></td></tr>
<tr class="separator:a3386cb5bc0372362bafc80abdfef7633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0217b56f3fb45b2e9fd83f3d7b15a2"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aef0217b56f3fb45b2e9fd83f3d7b15a2">isLight</a></td></tr>
<tr class="separator:aef0217b56f3fb45b2e9fd83f3d7b15a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa487c243f8dca5ec2c90d3000f2a696"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#afa487c243f8dca5ec2c90d3000f2a696">isLightProbe</a></td></tr>
<tr class="separator:afa487c243f8dca5ec2c90d3000f2a696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1667ad6733f7883a474fde3cb52de98a"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a1667ad6733f7883a474fde3cb52de98a">isMeshNode</a></td></tr>
<tr class="separator:a1667ad6733f7883a474fde3cb52de98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac178e6f33f03b599753ac1692bcf3dce"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ac178e6f33f03b599753ac1692bcf3dce">isOpaque</a></td></tr>
<tr class="separator:ac178e6f33f03b599753ac1692bcf3dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239f148f08d434791a2cb52420c20698"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a239f148f08d434791a2cb52420c20698">isRunning</a></td></tr>
<tr class="separator:a239f148f08d434791a2cb52420c20698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a95e1d8511ab08e4683290d1369448c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3a95e1d8511ab08e4683290d1369448c">isScene</a></td></tr>
<tr class="separator:a3a95e1d8511ab08e4683290d1369448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243087849ddd0878811a3fd2d9be85e3"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a243087849ddd0878811a3fd2d9be85e3">isShadowVolume</a></td></tr>
<tr class="separator:a243087849ddd0878811a3fd2d9be85e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82daff61037ecddfdb9591119ba0fbc9"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a82daff61037ecddfdb9591119ba0fbc9">isTouchable</a></td></tr>
<tr class="separator:a82daff61037ecddfdb9591119ba0fbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2abc9c2a605d725b949853f836bf54"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#acb2abc9c2a605d725b949853f836bf54">isTrackingForBumpMapping</a></td></tr>
<tr class="separator:acb2abc9c2a605d725b949853f836bf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ed8acc0f14fb7a9abf24d706873b83"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ac2ed8acc0f14fb7a9abf24d706873b83">isTransformDirty</a></td></tr>
<tr class="separator:ac2ed8acc0f14fb7a9abf24d706873b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277e1309c2aa9c2c4dc313497c1ce7e2"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a277e1309c2aa9c2c4dc313497c1ce7e2">isTransformRigid</a></td></tr>
<tr class="separator:a277e1309c2aa9c2c4dc313497c1ce7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9e3b759aaa56641df88a70e1ec07dc"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#afd9e3b759aaa56641df88a70e1ec07dc">isUniformlyScaledGlobally</a></td></tr>
<tr class="separator:afd9e3b759aaa56641df88a70e1ec07dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212fe1cdd0af61fb5fbbe74be761d876"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a212fe1cdd0af61fb5fbbe74be761d876">isUniformlyScaledLocally</a></td></tr>
<tr class="separator:a212fe1cdd0af61fb5fbbe74be761d876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1660e02d6c940fcaebb5ff9651592fb2"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a1660e02d6c940fcaebb5ff9651592fb2">lineSmoothingHint</a></td></tr>
<tr class="separator:a1660e02d6c940fcaebb5ff9651592fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb75ab6c0cd40a98c819d7fbd9f15561"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#acb75ab6c0cd40a98c819d7fbd9f15561">lineWidth</a></td></tr>
<tr class="separator:acb75ab6c0cd40a98c819d7fbd9f15561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c75563f8cd56b1f2d4b0e4d9fc0f2eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a7c75563f8cd56b1f2d4b0e4d9fc0f2eb">localTransformMatrix</a></td></tr>
<tr class="separator:a7c75563f8cd56b1f2d4b0e4d9fc0f2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd02187b1ee7884b9d0d8a19e413ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a4fd02187b1ee7884b9d0d8a19e413ae9">location</a></td></tr>
<tr class="separator:a4fd02187b1ee7884b9d0d8a19e413ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f80cf856a152e5c5a9f08efe15b0b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_node_8h.html#a4bed21b96ced6e7ff2d912800ab99bba">CC3NormalScaling</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a49f80cf856a152e5c5a9f08efe15b0b1">normalScalingMethod</a></td></tr>
<tr class="separator:a49f80cf856a152e5c5a9f08efe15b0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1226f19a687ba9fbac6960200bee550"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_c_c2_extensions_8h.html#aa13d5a16c4c3791576122915480e1772">CCOpacity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af1226f19a687ba9fbac6960200bee550">opacity</a></td></tr>
<tr class="separator:af1226f19a687ba9fbac6960200bee550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dd9e9f066613896e47b377a086b0e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a09dd9e9f066613896e47b377a086b0e9">parent</a></td></tr>
<tr class="separator:a09dd9e9f066613896e47b377a086b0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968396edac85926dcd809809220f0489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_performance_statistics.html">CC3PerformanceStatistics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a968396edac85926dcd809809220f0489">performanceStatistics</a></td></tr>
<tr class="separator:a968396edac85926dcd809809220f0489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef24a4c8bb91a62df21ed8b6d61c8a26"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aef24a4c8bb91a62df21ed8b6d61c8a26">podContentIndex</a></td></tr>
<tr class="separator:aef24a4c8bb91a62df21ed8b6d61c8a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e4fb1452c2513d6484be740d5fa9b8"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a63e4fb1452c2513d6484be740d5fa9b8">podParentIndex</a></td></tr>
<tr class="separator:a63e4fb1452c2513d6484be740d5fa9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7390275cb13c5705dc152fecaf2c27f6"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a7390275cb13c5705dc152fecaf2c27f6">podTargetIndex</a></td></tr>
<tr class="separator:a7390275cb13c5705dc152fecaf2c27f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b45149a327a4c6968b4ddf6c3a569b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a9b45149a327a4c6968b4ddf6c3a569b8">projectedLocation</a></td></tr>
<tr class="separator:a9b45149a327a4c6968b4ddf6c3a569b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2860d65aa974fe26a45d9d2d6cb286"><td class="memItemLeft" align="right" valign="top">CGPoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a8d2860d65aa974fe26a45d9d2d6cb286">projectedPosition</a></td></tr>
<tr class="separator:a8d2860d65aa974fe26a45d9d2d6cb286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427a097ebb4cafacc71a22257291aeaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector4.html">CC3Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a427a097ebb4cafacc71a22257291aeaa">quaternion</a></td></tr>
<tr class="separator:a427a097ebb4cafacc71a22257291aeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1f03343c83fe05834a5e1a0549428d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6c1f03343c83fe05834a5e1a0549428d">referenceUpDirection</a></td></tr>
<tr class="separator:a6c1f03343c83fe05834a5e1a0549428d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcc2bf770c060f53226e219d87f91c3"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a1fcc2bf770c060f53226e219d87f91c3">reflectivity</a></td></tr>
<tr class="separator:a1fcc2bf770c060f53226e219d87f91c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f63bb8813dfec78f294e108c090a30"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a30f63bb8813dfec78f294e108c090a30">renderStreamGroupMarker</a></td></tr>
<tr class="separator:a30f63bb8813dfec78f294e108c090a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3408ccc2fcaa4d7140170807cbf28c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae3408ccc2fcaa4d7140170807cbf28c1">rightDirection</a></td></tr>
<tr class="separator:ae3408ccc2fcaa4d7140170807cbf28c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c1dc69cd157d76184a077803d57df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a78c1dc69cd157d76184a077803d57df9">rootAncestor</a></td></tr>
<tr class="separator:a78c1dc69cd157d76184a077803d57df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bf4400c59a1c7dbe3040e32de5c2c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a40bf4400c59a1c7dbe3040e32de5c2c5">rotation</a></td></tr>
<tr class="separator:a40bf4400c59a1c7dbe3040e32de5c2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df49fd1ba5f759e58cf941e6f6c5192"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a7df49fd1ba5f759e58cf941e6f6c5192">rotationAngle</a></td></tr>
<tr class="separator:a7df49fd1ba5f759e58cf941e6f6c5192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5011c1eb664c356e4a3a37f04d36b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#abe5011c1eb664c356e4a3a37f04d36b3">rotationAxis</a></td></tr>
<tr class="separator:abe5011c1eb664c356e4a3a37f04d36b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c5d6f12425298dec18c02c18972c0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_rotator.html">CC3Rotator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a86c5d6f12425298dec18c02c18972c0f">rotator</a></td></tr>
<tr class="separator:a86c5d6f12425298dec18c02c18972c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3046c4ba3c92d526869f704243db5207"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3046c4ba3c92d526869f704243db5207">scale</a></td></tr>
<tr class="separator:a3046c4ba3c92d526869f704243db5207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9196fcfe8adf00c77fd292d0b22760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_scene.html">CC3Scene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a2a9196fcfe8adf00c77fd292d0b22760">scene</a></td></tr>
<tr class="separator:a2a9196fcfe8adf00c77fd292d0b22760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0866f372eeeb442df83d022f725de856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_shader_context.html">CC3ShaderContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a0866f372eeeb442df83d022f725de856">shaderContext</a></td></tr>
<tr class="separator:a0866f372eeeb442df83d022f725de856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff71f9e4bbe542f4b79dee2d8f9311cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_shader_program.html">CC3ShaderProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aff71f9e4bbe542f4b79dee2d8f9311cd">shaderProgram</a></td></tr>
<tr class="separator:aff71f9e4bbe542f4b79dee2d8f9311cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8ba79801408f832114cf0015d6d709"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a9c8ba79801408f832114cf0015d6d709">shadowExpansionLimitFactor</a></td></tr>
<tr class="separator:a9c8ba79801408f832114cf0015d6d709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf664f8d955af2cca08a225854c06aa"><td class="memItemLeft" align="right" valign="top">GLushort&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a4cf664f8d955af2cca08a225854c06aa">shadowLagCount</a></td></tr>
<tr class="separator:a4cf664f8d955af2cca08a225854c06aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e5c7fd0e89e322cdba3830a7aa01e6"><td class="memItemLeft" align="right" valign="top">GLushort&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a48e5c7fd0e89e322cdba3830a7aa01e6">shadowLagFactor</a></td></tr>
<tr class="separator:a48e5c7fd0e89e322cdba3830a7aa01e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c68a1ac21d067436344c5710acdcfd"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a86c68a1ac21d067436344c5710acdcfd">shadowOffsetFactor</a></td></tr>
<tr class="separator:a86c68a1ac21d067436344c5710acdcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c702551a8be555cef1f68a1d71c59e"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a11c702551a8be555cef1f68a1d71c59e">shadowOffsetUnits</a></td></tr>
<tr class="separator:a11c702551a8be555cef1f68a1d71c59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26210b7713c538378d2042733a112e1"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab26210b7713c538378d2042733a112e1">shadowVolumes</a></td></tr>
<tr class="separator:ab26210b7713c538378d2042733a112e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22c2849e08e0f698bfa7c14a864a3ab"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab22c2849e08e0f698bfa7c14a864a3ab">shadowVolumeVertexOffsetFactor</a></td></tr>
<tr class="separator:ab22c2849e08e0f698bfa7c14a864a3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e668a4c0befa6bfb3d93cb3a7fc9aaa"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6e668a4c0befa6bfb3d93cb3a7fc9aaa">shininess</a></td></tr>
<tr class="separator:a6e668a4c0befa6bfb3d93cb3a7fc9aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216302555d47b0ab179cccc47aa342aa"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a216302555d47b0ab179cccc47aa342aa">shouldAddShadowVolumeEndCapsOnlyWhenNeeded</a></td></tr>
<tr class="separator:a216302555d47b0ab179cccc47aa342aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09d8bfdfd1a67eb94f108a984197dd8"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aa09d8bfdfd1a67eb94f108a984197dd8">shouldAllowTouchableWhenInvisible</a></td></tr>
<tr class="separator:aa09d8bfdfd1a67eb94f108a984197dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa942701fc9f9ad9186b045ae82418a6"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aaa942701fc9f9ad9186b045ae82418a6">shouldApplyOpacityAndColorToMeshContent</a></td></tr>
<tr class="separator:aaa942701fc9f9ad9186b045ae82418a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452f578797e63d9a8fabd8e3fdb7d772"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a452f578797e63d9a8fabd8e3fdb7d772">shouldAutoremoveWhenEmpty</a></td></tr>
<tr class="separator:a452f578797e63d9a8fabd8e3fdb7d772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bbe60ca8c2e956a07d749c2446effc"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aa8bbe60ca8c2e956a07d749c2446effc">shouldAutotargetCamera</a></td></tr>
<tr class="separator:aa8bbe60ca8c2e956a07d749c2446effc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4f9242f26e4c65ceea0ff5e60778df"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a4e4f9242f26e4c65ceea0ff5e60778df">shouldBlendAtFullOpacity</a></td></tr>
<tr class="separator:a4e4f9242f26e4c65ceea0ff5e60778df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171357c7c12e1234776f4dd6d578d798"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a171357c7c12e1234776f4dd6d578d798">shouldCacheFaces</a></td></tr>
<tr class="separator:a171357c7c12e1234776f4dd6d578d798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a90c32dfff7b406f94cbc61594388cc"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a1a90c32dfff7b406f94cbc61594388cc">shouldCastShadows</a></td></tr>
<tr class="separator:a1a90c32dfff7b406f94cbc61594388cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0405e1cf9dfcc80a09cf4fe39282844f"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a0405e1cf9dfcc80a09cf4fe39282844f">shouldCastShadowsWhenInvisible</a></td></tr>
<tr class="separator:a0405e1cf9dfcc80a09cf4fe39282844f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a02ef76817887e925c9dc04c0e9826e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a0a02ef76817887e925c9dc04c0e9826e">shouldCullBackFaces</a></td></tr>
<tr class="separator:a0a02ef76817887e925c9dc04c0e9826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890865bb4d5cf77011e4e3de7f3d1e17"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a890865bb4d5cf77011e4e3de7f3d1e17">shouldCullFrontFaces</a></td></tr>
<tr class="separator:a890865bb4d5cf77011e4e3de7f3d1e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a30412b0a1de08a1baae7db25d0790"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a26a30412b0a1de08a1baae7db25d0790">shouldDisableDepthMask</a></td></tr>
<tr class="separator:a26a30412b0a1de08a1baae7db25d0790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14b782b005ee61d7c12a66669100a1d"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae14b782b005ee61d7c12a66669100a1d">shouldDisableDepthTest</a></td></tr>
<tr class="separator:ae14b782b005ee61d7c12a66669100a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae40f4920a3c8e23a7fe0088a44e2735"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aae40f4920a3c8e23a7fe0088a44e2735">shouldDrawAllBoundingVolumes</a></td></tr>
<tr class="separator:aae40f4920a3c8e23a7fe0088a44e2735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4262f42e7d2a599cf5cdf2d7a2edb6c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae4262f42e7d2a599cf5cdf2d7a2edb6c">shouldDrawAllDescriptors</a></td></tr>
<tr class="separator:ae4262f42e7d2a599cf5cdf2d7a2edb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcb4583de836b376bd11880c67d7598"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a5fcb4583de836b376bd11880c67d7598">shouldDrawAllLocalContentWireframeBoxes</a></td></tr>
<tr class="separator:a5fcb4583de836b376bd11880c67d7598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791e5a2fb4e409d23125af2e9fc3b9a0"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a791e5a2fb4e409d23125af2e9fc3b9a0">shouldDrawAllWireframeBoxes</a></td></tr>
<tr class="separator:a791e5a2fb4e409d23125af2e9fc3b9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f442144f6dcc33c987e09002109363"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a52f442144f6dcc33c987e09002109363">shouldDrawBoundingVolume</a></td></tr>
<tr class="separator:a52f442144f6dcc33c987e09002109363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98878a97ed2aeaa6cd809cd9596e91b4"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a98878a97ed2aeaa6cd809cd9596e91b4">shouldDrawDescriptor</a></td></tr>
<tr class="separator:a98878a97ed2aeaa6cd809cd9596e91b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fa71718772224c8d18bbea3056c0df"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a60fa71718772224c8d18bbea3056c0df">shouldDrawInClipSpace</a></td></tr>
<tr class="separator:a60fa71718772224c8d18bbea3056c0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6296e007b77e700dc737c733454dfa16"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6296e007b77e700dc737c733454dfa16">shouldDrawWireframeBox</a></td></tr>
<tr class="separator:a6296e007b77e700dc737c733454dfa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748cf91fcd056313bd242ef769a5b595"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a748cf91fcd056313bd242ef769a5b595">shouldIgnoreRayIntersection</a></td></tr>
<tr class="separator:a748cf91fcd056313bd242ef769a5b595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6833d96291530bec5cdcdc62fc7dad43"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6833d96291530bec5cdcdc62fc7dad43">shouldInheritTouchability</a></td></tr>
<tr class="separator:a6833d96291530bec5cdcdc62fc7dad43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841ebcfb2bd23fdcb9e9a88859dedf27"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a841ebcfb2bd23fdcb9e9a88859dedf27">shouldLogIntersectionMisses</a></td></tr>
<tr class="separator:a841ebcfb2bd23fdcb9e9a88859dedf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a2175dc4b412f1c82fbbbaf2462cd1"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a23a2175dc4b412f1c82fbbbaf2462cd1">shouldLogIntersections</a></td></tr>
<tr class="separator:a23a2175dc4b412f1c82fbbbaf2462cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6148501d14c6d4dec9e418e3c6ddb7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aaf6148501d14c6d4dec9e418e3c6ddb7">shouldShadowBackFaces</a></td></tr>
<tr class="separator:aaf6148501d14c6d4dec9e418e3c6ddb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea076319848bb9c70158ffed4610df4"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a7ea076319848bb9c70158ffed4610df4">shouldShadowFrontFaces</a></td></tr>
<tr class="separator:a7ea076319848bb9c70158ffed4610df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece9d9e7bb707235daa70aaca94bc83d"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aece9d9e7bb707235daa70aaca94bc83d">shouldSmoothLines</a></td></tr>
<tr class="separator:aece9d9e7bb707235daa70aaca94bc83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ce18b52a92a681ae6f3e8d1a6e93a3"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a57ce18b52a92a681ae6f3e8d1a6e93a3">shouldStopActionsWhenRemoved</a></td></tr>
<tr class="separator:a57ce18b52a92a681ae6f3e8d1a6e93a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af790e290503df860c57147e3e10ab914"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af790e290503df860c57147e3e10ab914">shouldTrackTarget</a></td></tr>
<tr class="separator:af790e290503df860c57147e3e10ab914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899c01b0e0a806669d7827112a275ddc"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a899c01b0e0a806669d7827112a275ddc">shouldUseClockwiseFrontFaceWinding</a></td></tr>
<tr class="separator:a899c01b0e0a806669d7827112a275ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17442122bf69cf1f949c241cb229fe3"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab17442122bf69cf1f949c241cb229fe3">shouldUseFixedBoundingVolume</a></td></tr>
<tr class="separator:ab17442122bf69cf1f949c241cb229fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbea6e6582b701b52b7a64d37ce6aa6"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3cbea6e6582b701b52b7a64d37ce6aa6">shouldUseLighting</a></td></tr>
<tr class="separator:a3cbea6e6582b701b52b7a64d37ce6aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18b13f1a27bbeccfd9c620016bf4c60"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ac18b13f1a27bbeccfd9c620016bf4c60">shouldUseLightProbes</a></td></tr>
<tr class="separator:ac18b13f1a27bbeccfd9c620016bf4c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf527d032102ac1750699662c0c753d"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#adcf527d032102ac1750699662c0c753d">shouldUseSmoothShading</a></td></tr>
<tr class="separator:adcf527d032102ac1750699662c0c753d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c4ff343a0bf2fd2d9df6423dcc16c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a91c4ff343a0bf2fd2d9df6423dcc16c1">skeletalScale</a></td></tr>
<tr class="separator:a91c4ff343a0bf2fd2d9df6423dcc16c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33241811980bc3c100a576de8349c99b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_soft_body_node.html">CC3SoftBodyNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a33241811980bc3c100a576de8349c99b">softBodyNode</a></td></tr>
<tr class="separator:a33241811980bc3c100a576de8349c99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ec9c3ae66471ffdc3eec5612cf4b4e"><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a12ec9c3ae66471ffdc3eec5612cf4b4e">specularColor</a></td></tr>
<tr class="separator:a12ec9c3ae66471ffdc3eec5612cf4b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f64f9bff8e82bd227b87368bdd6ae5"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af4f64f9bff8e82bd227b87368bdd6ae5">structureDescription</a></td></tr>
<tr class="separator:af4f64f9bff8e82bd227b87368bdd6ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4146d1cc85c17d2ee04215b49098f57e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a4146d1cc85c17d2ee04215b49098f57e">target</a></td></tr>
<tr class="separator:a4146d1cc85c17d2ee04215b49098f57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80feb12e8d0a98ec8b18e3738544ab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aa80feb12e8d0a98ec8b18e3738544ab2">targetLocation</a></td></tr>
<tr class="separator:aa80feb12e8d0a98ec8b18e3738544ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fef617a4c42b761f557678cd1bf63ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_rotator_8h.html#afc5673e97432b6a4bee46ca01f979303">CC3TargettingConstraint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3fef617a4c42b761f557678cd1bf63ac">targettingConstraint</a></td></tr>
<tr class="separator:a3fef617a4c42b761f557678cd1bf63ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d1b274a380d13313b614b01b2a76ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a66d1b274a380d13313b614b01b2a76ad">texture</a></td></tr>
<tr class="separator:a66d1b274a380d13313b614b01b2a76ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18700eb982dbcff8acbf70ce0f97b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aa18700eb982dbcff8acbf70ce0f97b6c">touchableNode</a></td></tr>
<tr class="separator:aa18700eb982dbcff8acbf70ce0f97b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9737fdedb894debfc209a6e471c02a"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3e9737fdedb894debfc209a6e471c02a">touchEnabled</a></td></tr>
<tr class="separator:a3e9737fdedb894debfc209a6e471c02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e15c0ce82e6a3b021f2c2e3b3447b4"><td class="memItemLeft" align="right" valign="top">NSSet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a09e15c0ce82e6a3b021f2c2e3b3447b4">transformListeners</a></td></tr>
<tr class="separator:a09e15c0ce82e6a3b021f2c2e3b3447b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112d11012a4d25e53e1cf431ea5c8469"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a112d11012a4d25e53e1cf431ea5c8469">uniformScale</a></td></tr>
<tr class="separator:a112d11012a4d25e53e1cf431ea5c8469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2ea592784c931aa1c78e02f5de5ed5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a7d2ea592784c931aa1c78e02f5de5ed5">upDirection</a></td></tr>
<tr class="separator:a7d2ea592784c931aa1c78e02f5de5ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d92d79ffd98917bdcce43917eb87d5"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab8d92d79ffd98917bdcce43917eb87d5">visible</a></td></tr>
<tr class="separator:ab8d92d79ffd98917bdcce43917eb87d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad12e8a7b4202e8cd152c64a31b70aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_wireframe_bounding_box_node.html">CC3WireframeBoundingBoxNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a9ad12e8a7b4202e8cd152c64a31b70aa">wireframeBoxNode</a></td></tr>
<tr class="separator:a9ad12e8a7b4202e8cd152c64a31b70aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb29f8d02c53f72f48d45c673d33ce4"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#acbb29f8d02c53f72f48d45c673d33ce4">zOrder</a></td></tr>
<tr class="separator:acbb29f8d02c53f72f48d45c673d33ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('properties_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:af603104494fba5d4791f720823528f9d inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSObject *sharedUserData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#af603104494fba5d4791f720823528f9d">__deprecated</a></td></tr>
<tr class="separator:af603104494fba5d4791f720823528f9d inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cccaa59a3f724bff77683237e271b6 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#ac8cccaa59a3f724bff77683237e271b6">name</a></td></tr>
<tr class="separator:ac8cccaa59a3f724bff77683237e271b6 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deeaefbf8e9fdc758bace96cb88b716 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a2deeaefbf8e9fdc758bace96cb88b716">nameSuffix</a></td></tr>
<tr class="separator:a2deeaefbf8e9fdc758bace96cb88b716 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93489bf1874209effdcb78761e7e3480 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a93489bf1874209effdcb78761e7e3480">podIndex</a></td></tr>
<tr class="separator:a93489bf1874209effdcb78761e7e3480 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65202edca1a66ef060b5b0411cb547c3 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a65202edca1a66ef060b5b0411cb547c3">shouldIncludeInDeepCopy</a></td></tr>
<tr class="separator:a65202edca1a66ef060b5b0411cb547c3 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe2d1079602a9b93e1803b5d8aefdcc inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a4fe2d1079602a9b93e1803b5d8aefdcc">tag</a></td></tr>
<tr class="separator:a4fe2d1079602a9b93e1803b5d8aefdcc inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82555dcf853eeb9fcdcc5fae1c1fcd5c inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a82555dcf853eeb9fcdcc5fae1c1fcd5c">userData</a></td></tr>
<tr class="separator:a82555dcf853eeb9fcdcc5fae1c1fcd5c inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_protocol_c_c3_cacheable-p"><td colspan="2" onclick="javascript:toggleInherit('properties_protocol_c_c3_cacheable-p')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="protocol_c_c3_cacheable-p.html">&lt;CC3Cacheable&gt;</a></td></tr>
<tr class="memitem:af3f0574df825aa03a7b7646918212512 inherit properties_protocol_c_c3_cacheable-p"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_c_c3_cacheable-p.html#af3f0574df825aa03a7b7646918212512">name</a></td></tr>
<tr class="separator:af3f0574df825aa03a7b7646918212512 inherit properties_protocol_c_c3_cacheable-p"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D scene, including visible mesh...">CC3Node</a> and its subclasses form the basis of all 3D artifacts in the 3D scene, including visible meshes, structures, cameras, lights, resources, and the 3D scene itself. </p>
<p>Nodes can be moved, rotated and scaled. Rotation can be specified via Euler angles, quaternions, rotation axis and angle, or changes to any of these properties.</p>
<p>In addition to programmatically rotating a node using the rotation quaternion, rotationAxis, and rotationAngle properties, or one of the rotateBy...: methods, you can set a node to point towards a particular direction, location. You can even point a node towards another target node, and have it track that node, so that it always points towards the target node, as either the node, or the target node move around.</p>
<p>For more on targetting the node in a direction, or to track a target node, see the notes of the following properties and methods:</p>
<ul>
<li>target</li>
<li>targetLocation</li>
<li>shouldTrackTarget</li>
<li>targettingConstraint</li>
<li>shouldAutotargetCamera</li>
<li>isTrackingForBumpMapping</li>
</ul>
<p>Nodes can be assembled in a structural hierarchy of parents and children, using the addChild: method. Transformations that are applied to a node are also applied to its descendant nodes. Typically, the root of a structural node hierarchy is an instance of <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>.</p>
<p>When creating a structural hierarchy of nodes, it is often useful to wrap one node in another node in order to orient the node of interest in a particular direction, or provide an offset location in order to allow the node of interest to visually anchored at a location other than its origin. To easily wrap a node in another node, use the following methods:</p>
<ul>
<li>asOrientingWrapper</li>
<li>asTrackingWrapper</li>
<li>asCameraTrackingWrapper</li>
<li>asBumpMapLightTrackingWrapper</li>
</ul>
<p>Each node is automatically touched at two distinct times during animation frame handling. First, the updateBeforeTransform: and updateAfterTransform: methods are each invoked during scheduled model state updating, before and after the transformation matrix of the node is rebuilt, respectively. You should override udpateBeforeTransform: method to make any changes to the node, or its child nodes.</p>
<p>You should override updateAfterTransform: only if you need to make use of the global properties of the node or its child nodes, such as globalLocation, globalRotation, or globalScale. These properties are valid only after the globalTransformMatrix has been calculated, and are therefore not valid within the updateBeforeTransform: method. However, if you make any changes to the transform properties (location, rotation, scale) of a node within the updateAfterTransform: method, you must invoke the updateTransformMatrices method on that node in order to have the changes applied to the node's globalTransformMatrix.</p>
<p>Note that you do NOT need to invoke the updateTransformMatrices method for any changes made in the updateBeforeTransform: method, since those changes will automatically be applied to the globalTransformMatrix.</p>
<p>The second place a node is touched is the transformAndDrawWithVisitor: method, which is automaticaly invoked during each frame rendering cycle. You should have no need to override this method.</p>
<p>To maximize throughput, the operations of updating model state should be kept separate from the operations of frame rendering, and the two should not be mixed. Subclasses should respect this design pattern when overriding behaviour. Drawing operations should not be included in state updating, and vice versa. Since OpenGL is a hardware-accelerated state-machine pipeline, this separation allows frame-drawing operations to be performed by the GPU at the same time that state update operations for the next frame are being handled by the CPU, and on some systems, permits frame drawing and model updating to be perfomed on separate threads.</p>
<p>CC3Nodes support the Cocos2D CCAction class hierarchy. Nodes can be translated, rotated, and scaled in three dimensions, or made to point towards a direction (for cameras and lights), all under control of Cocos2D CCActions. As with other CCActions, these actions can be combined into action sequences or repeating actions, or modified with Cocos2D ease actions. See the class <a class="el" href="interface_c_c3_action_transform_to.html" title="CC3ActionTransformTo is an abstract subclass of CC3ActionTransformVector that is the parent of subcla...">CC3ActionTransformTo</a> and its subclasses for actions that operate on CC3Nodes.</p>
<p>When populating your scene, you can easily create hordes of similar nodes using the copy and copyWithName: methods. Those methods effect deep copies to allow each copy to be manipulated independently, but will share underlying mesh data for efficient memory use. See the notes at the copy method for more details about copying nodes.</p>
<p>You can animate this class with animation data held in a subclass of <a class="el" href="interface_c_c3_node_animation.html" title="A CC3NodeAnimation manages the animation of a node. ">CC3NodeAnimation</a>. To animate this node using animation data, set the animation property to an instance of a subclass of the abstract <a class="el" href="interface_c_c3_node_animation.html" title="A CC3NodeAnimation manages the animation of a node. ">CC3NodeAnimation</a> class, populated with animation content, and then create an instance of a <a class="el" href="interface_c_c3_action_animate.html" title="CC3ActionAnimate animates a single track of animation on a CC3Node and its descendants. ">CC3ActionAnimate</a> action, and run it on this node.</p>
<p>Nodes can respond to iOS touch events. The property touchEnabled can be set to YES to allow a node to be selected by a touch event. If the shouldInheritTouchability property is also set to YES, then this touchable capability can also be inherited from a parent node. Selection of nodes based on touch events is handled by <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>. The nodeSelected:byTouchEvent:at: callback method of your customized <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> will be invoked to indicate which node has been touched.</p>
<p>With complex scenes, the drawing of objects that are not within view of the camera will consume GPU resources unnecessarily, and potentially degrading app performance. We can avoid drawing objects that are not within view of the camera by assigning a bounding volume to each mesh node. Once assigned, the bounding volume is automatically checked to see if it intersects the camera's frustum before the mesh node is drawn. If the mesh node's bounding volume intersects the camera frustum, the node will be drawn. If the bounding volume does not intersect the camera's frustum, the node will not be visible to the camera, and the node will not be drawn. Bounding volumes can also be used for collision detection between nodes.</p>
<p>You can create bounding volumes automatically for most rigid (non-skinned) objects by invoking the createBoundingVolumes on a node. This will create bounding volumes for all decendant rigid mesh nodes of that node. Invoking the method on your scene will create bounding volumes for all rigid mesh nodes in the scene.</p>
<p>Bounding volumes are not automatically created for skinned meshes that modify vertices using bones. Because the vertices can be moved arbitrarily by the bones, you must create and assign bounding volumes to skinned mesh nodes yourself, by determining the extent of the bounding volume you need, and creating a bounding volume that matches it.</p>
<p>Checking bounding volumes involves a small computation cost. For objects that you know will be in front of the camera at all times, you can skip creating a bounding volume for that node, letting it be drawn on each frame.</p>
<p>You can cause a wireframe box to be drawn around the node and all its descendants by setting the shouldDrawWireframeBox property to YES. This can be particularly useful during development to locate the boundaries of a node, or to locate a node that is not drawing properly. You can set the default color of this wireframe using the class-side defaultWireframeBoxColor property.</p>
<p>You can also cause the name of the node to be displayed where the node is by setting the shouldDrawDescriptor property to YES. This is also useful for locating a node when debugging rendering problems. </p>
</div><h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="abfe000a231f61220f6c716fedbcb9df9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (GLfloat) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000149">Deprecated:</a></b></dt><dd>This property is no longer needed, since the rigidity of a node transform is now tracked by the globalTransformMatrix itself. This property will always return zero. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="aef0c0a5a05759248a193cd6158189c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000154">Deprecated:</a></b></dt><dd>Renamed to removeShaders. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="aef0c0a5a05759248a193cd6158189c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000153">Deprecated:</a></b></dt><dd>Renamed to selectShaders. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="aef0c0a5a05759248a193cd6158189c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000155">Deprecated:</a></b></dt><dd>Renamed to releaseRedundantContent. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="aef0c0a5a05759248a193cd6158189c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000156">Deprecated:</a></b></dt><dd>Renamed to retainVertexBoneWeights. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="aef0c0a5a05759248a193cd6158189c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000157">Deprecated:</a></b></dt><dd>Renamed to retainVertexBoneIndices. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="aef0c0a5a05759248a193cd6158189c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000158">Deprecated:</a></b></dt><dd>Renamed to doNotBufferVertexBoneWeights. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="aef0c0a5a05759248a193cd6158189c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><ul>
<li></li>
</ul>
</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000159">Deprecated:</a></b></dt><dd>Renamed to doNotBufferVertexBoneIndices. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="aef0c0a5a05759248a193cd6158189c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000163">Deprecated:</a></b></dt><dd>Renamed to markBoundingVolumeDirty. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="aef0c0a5a05759248a193cd6158189c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000166">Deprecated:</a></b></dt><dd>No longer needed. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="aef0c0a5a05759248a193cd6158189c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000167">Deprecated:</a></b></dt><dd>No longer needed. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="a4b8340abf8a444932c0c0ee933c5a901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000172">Deprecated:</a></b></dt><dd>No longer used. Always returns nil. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="aef0c0a5a05759248a193cd6158189c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000176">Deprecated:</a></b></dt><dd>Renamed to cleanupActions. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_scene.html#a7e1a016e6d07e0a5ce1dfdd41a0a6e42">CC3Scene</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#acc1d05fd85149ccbbd94d2784e44b280">CC3MeshNode</a>, <a class="el" href="interface_c_c3_mesh_node.html#a279b97e2ee06b5e7f290871df7f91b41">CC3MeshNode</a>, <a class="el" href="interface_c_c3_world.html#aaa6dfbf9f445d3e2221ceb91884ca695">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>, and <a class="el" href="interface_c_c3_world.html#addc46a4bc1f4f1964eef2aa7f559e8bc">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="a14386e095b6fa995faf1544dd09c8b1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addAndLocalizeChild: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td>
          <td class="paramname"><em>aNode</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified node as a direct child node to this node, and localizes the child node's location, rotation, and scale properties to this node. </p>
<p>This has the effect of leaving the global location, rotation and scale of the child node as they were, but re-homing the node to this parent. Visually, the node appears to stay in place, but will now move with the new parent, not with the old parent.</p>
<p>For instance, you might have an apple object whose overall intended global size and orientation you know, but you want that object to be added to a bowl, so that when you move the bowl, the apple moves with it. The bowl has likely been rotated and scaled, and raised onto a table, and you don't want your known apple to be transformed by the table and bowl when you add the apple to the bowl, You can use this method on the bowl object to add the apple, and reverse the table and bowl transforms for the apple, so that the apple will appear with its current size and orientation.</p>
<p>To do this, this method finds the appropriate location, rotation, and scale properties for the child node that will result in the globalLocation, globalRotation and globalScale properties remaining the same after it has been added to this parent node.</p>
<p>The child node is removed from its existing parent.</p>
<p>This method makes use of the transformMatrices of this node and the node being added. To ensure that both matrices are each up to date, this method invokes updateTransformMatrix method on both this node and the node being added. You can therefore invoke this method without having to consider whether the globalTransformMatrix has been calculated already.</p>
<p>This method changes the transform properties of the node being added. If you are invoking this method from the updateBeforeTransform: of the node being added, this node, or any ancestor node (including your <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>), the globalTransformMatrix of the node being added (and its descendant nodes) will automatically be updated. However, if you are invoking this method from the updateAfterTransform: method, you should invoke the updateTransformMatrices method on the node being added after this method is finished, to ensure that the transform matrices are udpated. </p>

</div>
</div>
<a class="anchor" id="a3b3e8956694f49026dda1063b1b600ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addAnimation: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_animation.html">CC3NodeAnimation</a> *)&#160;</td>
          <td class="paramname"><em>animation</em></td>
        </tr>
        <tr>
          <td class="paramkey">asTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified animation as the specified animation track. </p>
<p>A node may contain only one animation per animation track. If an animation already exists on the specified track, it is replaced with the specified animation.</p>
<p>To animate this node, use this method to add one or more instances of a subclass of the abstract <a class="el" href="interface_c_c3_node_animation.html" title="A CC3NodeAnimation manages the animation of a node. ">CC3NodeAnimation</a> class, populated with animation content, and then create an instance of a <a class="el" href="interface_c_c3_action_animate.html" title="CC3ActionAnimate animates a single track of animation on a CC3Node and its descendants. ">CC3ActionAnimate</a> action for each track, and selectively run them on this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a3b3e8956694f49026dda1063b1b600ec">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a21e4d1b3b8595f63ec865917af48ff9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) addAnimationFrom: </td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>startTime</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>endTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Many animated characters require the animation of multiple distinct movements. </p>
<p>For example, a bird character might have distinct flapping, landing, and pecking movements. A human character might have distinct running, crouching and shooting movements.</p>
<p>It is often useful to provide all of these movements as one long animation, and to play the animation segments for specific movements as required by the application. Our human character might run for a while, then crouch, take a few shots, and then start running again, all under control of the application, by extracting and playing the animation segment for each movement, in turn, from the single long animation that contains all the movements.</p>
<p>To support this behaviour, you can load the entire long animation into one track of animation, and then use this method to create a separate animation track that contains only the animation for a single movement. You can then animate only that movement, or repeat only that movement in a loop (such as running or flying), or blend that movement with other animation tracks to allow your human character to run and shoot at the same time, or smoothly transition your bird from the flapping movement to the landing movement.</p>
<p>This method creates and adds a new animation track that plays only a segment of the existing animation in track zero, which is the default track used during animation loading. A new animation track ID is assigned, the new animation is added to this node on that animation track, and the track ID is returned.</p>
<p>The start and end times of the animation segment are defined by startTime and endTime, each of which are specified as a fraction of the total animation contained in the base animation track. Each of startTime and endTime must therefore be between zero and one.</p>
<p>For example, if you wish to create a new animation track that plays the middle third of an existing animation track, you would pass 0.3333 and 0.6667 as the startTime and endTime parameters, respectively.</p>
<p>This method is automatically propagated to all descendant nodes, so you only need to invoke this method on a single ancestor node (eg- the root node of your character). </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a21e4d1b3b8595f63ec865917af48ff9b">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ae93d9482844e29574093f19bf2f6392e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addAnimationFrom: </td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>startTime</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>endTime</em></td>
        </tr>
        <tr>
          <td class="paramkey">asTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Many animated characters require the animation of multiple distinct movements. </p>
<p>For example, a bird character might have distinct flapping, landing, and pecking movements. A human character might have distinct running, crouching and shooting movements.</p>
<p>It is often useful to provide all of these movements as one long animation, and to play the animation segments for specific movements as required by the application. Our human character might run for a while, then crouch, take a few shots, and then start running again, all under control of the application, by extracting and playing the animation segment for each movement, in turn, from the single long animation that contains all the movements.</p>
<p>To support this behaviour, you can load the entire long animation into one track of animation, and then use this method to create a separate animation track that contains only the animation for a single movement. You can then animate only that movement, or repeat only that movement in a loop (such as running or flying), or blend that movement with other animation tracks to allow your human character to run and shoot at the same time, or smoothly transition your bird from the flapping movement to the landing movement.</p>
<p>This method creates and adds a new animation track that plays only a segment of the existing animation in track zero, which is the default track used during animation loading. The new animation is added to this node on the animation track specified by trackID.</p>
<p>The start and end times of the animation segment are defined by startTime and endTime, each of which are specified as a fraction of the total animation contained in the base animation track. Each of startTime and endTime must therefore be between zero and one.</p>
<p>For example, if you wish to create a new animation track that plays the middle third of an existing animation track, you would pass 0.3333 and 0.6667 as the startTime and endTime parameters, respectively.</p>
<p>This method is automatically propagated to all descendant nodes, so you only need to invoke this method on a single ancestor node (eg- the root node of your character). </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ae93d9482844e29574093f19bf2f6392e">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a2d42b62a93d1ae6235b937ed5578c78a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) addAnimationFrom: </td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>startTime</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>endTime</em></td>
        </tr>
        <tr>
          <td class="paramkey">ofBaseTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>baseTrackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Many animated characters require the animation of multiple distinct movements. </p>
<p>For example, a bird character might have distinct flapping, landing, and pecking movements. A human character might have distinct running, crouching and shooting movements.</p>
<p>It is often useful to provide all of these movements as one long animation, and to play the animation segments for specific movements as required by the application. Our human character might run for a while, then crouch, take a few shots, and then start running again, all under control of the application, by extracting and playing the animation segment for each movement, in turn, from the single long animation that contains all the movements.</p>
<p>To support this behaviour, you can load the entire long animation into one track of animation, and then use this method to create a separate animation track that contains only the animation for a single movement. You can then animate only that movement, or repeat only that movement in a loop (such as running or flying), or blend that movement with other animation tracks to allow your human character to run and shoot at the same time, or smoothly transition your bird from the flapping movement to the landing movement.</p>
<p>This method creates and adds a new animation track that plays only a segment of the existing animation track specified by baseTrackID. A new animation track ID is assigned, the new animation is added to this node on that animation track, and the track ID is returned.</p>
<p>The start and end times of the animation segment are defined by startTime and endTime, each of which are specified as a fraction of the total animation contained in the base animation track. Each of startTime and endTime must therefore be between zero and one.</p>
<p>For example, if you wish to create a new animation track that plays the middle third of an existing animation track, you would pass 0.3333 and 0.6667 as the startTime and endTime parameters, respectively.</p>
<p>This method is automatically propagated to all descendant nodes, so you only need to invoke this method on a single ancestor node (eg- the root node of your character). </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a2d42b62a93d1ae6235b937ed5578c78a">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ac158a331cdd93e4831e840b276214cd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addAnimationFrom: </td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>startTime</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>endTime</em></td>
        </tr>
        <tr>
          <td class="paramkey">ofBaseTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>baseTrackID</em></td>
        </tr>
        <tr>
          <td class="paramkey">asTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Many animated characters require the animation of multiple distinct movements. </p>
<p>For example, a bird character might have distinct flapping, landing, and pecking movements. A human character might have distinct running, crouching and shooting movements.</p>
<p>It is often useful to provide all of these movements as one long animation, and to play the animation segments for specific movements as required by the application. Our human character might run for a while, then crouch, take a few shots, and then start running again, all under control of the application, by extracting and playing the animation segment for each movement, in turn, from the single long animation that contains all the movements.</p>
<p>To support this behaviour, you can load the entire long animation into one track of animation, and then use this method to create a separate animation track that contains only the animation for a single movement. You can then animate only that movement, or repeat only that movement in a loop (such as running or flying), or blend that movement with other animation tracks to allow your human character to run and shoot at the same time, or smoothly transition your bird from the flapping movement to the landing movement.</p>
<p>This method creates and adds a new animation track that plays only a segment of the existing animation track specified by baseTrackID. The new animation is added to this node on the animation track specified by trackID.</p>
<p>The start and end times of the animation segment are defined by startTime and endTime, each of which are specified as a fraction of the total animation contained in the base animation track. Each of startTime and endTime must therefore be between zero and one.</p>
<p>For example, if you wish to create a new animation track that plays the middle third of an existing animation track, you would pass 0.3333 and 0.6667 as the startTime and endTime parameters, respectively.</p>
<p>This method is automatically propagated to all descendant nodes, so you only need to invoke this method on a single ancestor node (eg- the root node of your character). </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ac158a331cdd93e4831e840b276214cd7">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a02897d92979bd80d4fb68aea28bce8a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) addAnimationFromCAFFile: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>cafFilePath</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the animation contained in the specified CAF file to this node and all its descendants. </p>
<p>The animation is added in a new track, whose ID is returned from this method.</p>
<p>If the specified CAF file has already been loaded, it is retrieved from the resource cache. If the CAF file has not been loaded, it will be loaded and placed in the resource cache. However, the adding of the animation will fail, because the CAF file requires linking to an associated CSF file. Only use this method if you know that the CAF file has already been loaded and linked to a CSF file. If you are not sure, use the addAnimationFromCAFFile:linkedToCSFFile: method instead. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_c_a_f_animation_08.html#a02897d92979bd80d4fb68aea28bce8a6">CC3Node(CAFAnimation)</a>.</p>

</div>
</div>
<a class="anchor" id="aa4645becd4fa4ef6b54110639ea4fbb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="category_c_c3_node_07_c_a_f_animation_08.html#a02897d92979bd80d4fb68aea28bce8a6">addAnimationFromCAFFile:</a> </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>cafFilePath</em></td>
        </tr>
        <tr>
          <td class="paramkey">asTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the animation contained in the specified CAF file to this node and all its descendants. </p>
<p>The animation is added as the specified track.</p>
<p>If the specified CAF file has already been loaded, it is retrieved from the resource cache. If the CAF file has not been loaded, it will be loaded and placed in the resource cache. However, the adding of the animation will fail, because the CAF file requires linking to an associated CSF file. Only use this method if you know that the CAF file has already been loaded and linked to a CSF file. If you are not sure, use the addAnimationFromCAFFile:linkedToCSFFile:asTrack: method instead. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_c_a_f_animation_08.html#aa4645becd4fa4ef6b54110639ea4fbb7">CC3Node(CAFAnimation)</a>.</p>

</div>
</div>
<a class="anchor" id="a17e1944c83847b04e983ecd23a35bd1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) <a class="el" href="category_c_c3_node_07_c_a_f_animation_08.html#a02897d92979bd80d4fb68aea28bce8a6">addAnimationFromCAFFile:</a> </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>cafFilePath</em></td>
        </tr>
        <tr>
          <td class="paramkey">linkedToCSFFile:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>csfFilePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the animation contained in the specified CAF file to this node and all its descendants. </p>
<p>The animation is added in a new track, whose ID is returned from this method.</p>
<p>If the specified CAF file has already been loaded, it is retrieved from the resource cache. If the CAF file has not been loaded, it will be loaded from the specified CAF file, placed in the resource cache, and linked to the CSF resource loaded from the specified CSF file.</p>
<p>Similarly, if the CSF resource is required in order for it to be linked to a newly-loaded CAF file, and it has already been loaded, it is retrieved from the resource cache. If the CSF resource has not been loaded, it will be loaded from the specified CSF file and placed in the resource cache. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_c_a_f_animation_08.html#a17e1944c83847b04e983ecd23a35bd1c">CC3Node(CAFAnimation)</a>.</p>

</div>
</div>
<a class="anchor" id="adb0703a78269e91018e02a40d12c4dae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="category_c_c3_node_07_c_a_f_animation_08.html#a02897d92979bd80d4fb68aea28bce8a6">addAnimationFromCAFFile:</a> </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>cafFilePath</em></td>
        </tr>
        <tr>
          <td class="paramkey">linkedToCSFFile:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>csfFilePath</em></td>
        </tr>
        <tr>
          <td class="paramkey">asTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the animation contained in the specified CAF file, which is linked to the specified CSF file, to this node and all its descendants. </p>
<p>The animation is added as the specified track.</p>
<p>If the specified CAF file has already been loaded, it is retrieved from the resource cache. If the CAF file has not been loaded, it will be loaded from the specified CAF file, placed in the resource cache, and linked to the CSF resource loaded from the specified CSF file.</p>
<p>Similarly, if the CSF resource is required in order for it to be linked to a newly-loaded CAF file, and it has already been loaded, it is retrieved from the resource cache. If the CSF resource has not been loaded, it will be loaded from the specified CSF file and placed in the resource cache. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_c_a_f_animation_08.html#adb0703a78269e91018e02a40d12c4dae">CC3Node(CAFAnimation)</a>.</p>

</div>
</div>
<a class="anchor" id="a96b6ea59d53900883740c93cef95dbed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) addAnimationFromFrame: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>startFrameIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">toFrame:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>endFrameIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Many animated characters require the animation of multiple distinct movements. </p>
<p>For example, a bird character might have distinct flapping, landing, and pecking movements. A human character might have distinct running, crouching and shooting movements.</p>
<p>It is often useful to provide all of these movements as one long animation, and to play the animation segments for specific movements as required by the application. Our human character might run for a while, then crouch, take a few shots, and then start running again, all under control of the application, by extracting and playing the animation segment for each movement, in turn, from the single long animation that contains all the movements.</p>
<p>To support this behaviour, you can load the entire long animation into one track of animation, and then use this method to create a separate animation track that contains only the animation for a single movement. You can then animate only that movement, or repeat only that movement in a loop (such as running or flying), or blend that movement with other animation tracks to allow your human character to run and shoot at the same time, or smoothly transition your bird from the flapping movement to the landing movement.</p>
<p>This method creates and adds a new animation track that plays only a segment of the existing animation in track zero, which is the default track used during animation loading. A new animation track ID is assigned, the new animation is added to this node on that animation track, and the track ID is returned.</p>
<p>The start and end frames of the animation segment are defined by startFrameIndex and endFrameIndex, each of which identify a frame in the base animation track, inclusively. Frame indexing is zero-based, so the first frame is identified as frame index zero.</p>
<p>For example, if you wish to create a new animation track that plays frames 10 through 20, inclusively, of an existing animation track, you would pass 10 and 20 as the startFrameIndex and endFrameIndex parameters, respectively.</p>
<p>This method is automatically propagated to all descendant nodes, so you only need to invoke this method on a single ancestor node (eg- the root node of your character). </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a96b6ea59d53900883740c93cef95dbed">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a24969f4a3211886acbe86ceae2d67d58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addAnimationFromFrame: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>startFrameIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">toFrame:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>endFrameIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">asTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Many animated characters require the animation of multiple distinct movements. </p>
<p>For example, a bird character might have distinct flapping, landing, and pecking movements. A human character might have distinct running, crouching and shooting movements.</p>
<p>It is often useful to provide all of these movements as one long animation, and to play the animation segments for specific movements as required by the application. Our human character might run for a while, then crouch, take a few shots, and then start running again, all under control of the application, by extracting and playing the animation segment for each movement, in turn, from the single long animation that contains all the movements.</p>
<p>To support this behaviour, you can load the entire long animation into one track of animation, and then use this method to create a separate animation track that contains only the animation for a single movement. You can then animate only that movement, or repeat only that movement in a loop (such as running or flying), or blend that movement with other animation tracks to allow your human character to run and shoot at the same time, or smoothly transition your bird from the flapping movement to the landing movement.</p>
<p>This method creates and adds a new animation track that plays only a segment of the existing animation in track zero, which is the default track used during animation loading. The new animation is added to this node on the animation track specified by trackID.</p>
<p>The start and end frames of the animation segment are defined by startFrameIndex and endFrameIndex, each of which identify a frame in the base animation track, inclusively. Frame indexing is zero-based, so the first frame is identified as frame index zero.</p>
<p>For example, if you wish to create a new animation track that plays frames 10 through 20, inclusively, of an existing animation track, you would pass 10 and 20 as the startFrameIndex and endFrameIndex parameters, respectively.</p>
<p>This method is automatically propagated to all descendant nodes, so you only need to invoke this method on a single ancestor node (eg- the root node of your character). </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a24969f4a3211886acbe86ceae2d67d58">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ad1d08978a07a3312446c0c1a40f2d62f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) addAnimationFromFrame: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>startFrameIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">toFrame:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>endFrameIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">ofBaseTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>baseTrackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Many animated characters require the animation of multiple distinct movements. </p>
<p>For example, a bird character might have distinct flapping, landing, and pecking movements. A human character might have distinct running, crouching and shooting movements.</p>
<p>It is often useful to provide all of these movements as one long animation, and to play the animation segments for specific movements as required by the application. Our human character might run for a while, then crouch, take a few shots, and then start running again, all under control of the application, by extracting and playing the animation segment for each movement, in turn, from the single long animation that contains all the movements.</p>
<p>To support this behaviour, you can load the entire long animation into one track of animation, and then use this method to create a separate animation track that contains only the animation for a single movement. You can then animate only that movement, or repeat only that movement in a loop (such as running or flying), or blend that movement with other animation tracks to allow your human character to run and shoot at the same time, or smoothly transition your bird from the flapping movement to the landing movement.</p>
<p>This method creates and adds a new animation track that plays only a segment of the existing animation track specified by baseTrackID. A new animation track ID is assigned, the new animation is added to this node on that animation track, and the track ID is returned.</p>
<p>The start and end frames of the animation segment are defined by startFrameIndex and endFrameIndex, each of which identify a frame in the base animation track, inclusively. Frame indexing is zero-based, so the first frame is identified as frame index zero.</p>
<p>For example, if you wish to create a new animation track that plays frames 10 through 20, inclusively, of an existing animation track, you would pass 10 and 20 as the startFrameIndex and endFrameIndex parameters, respectively.</p>
<p>This method is automatically propagated to all descendant nodes, so you only need to invoke this method on a single ancestor node (eg- the root node of your character). </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ad1d08978a07a3312446c0c1a40f2d62f">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="adab7f4e9c2421024c573f347e2a63e38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addAnimationFromFrame: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>startFrameIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">toFrame:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>endFrameIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">ofBaseTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>baseTrackID</em></td>
        </tr>
        <tr>
          <td class="paramkey">asTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Many animated characters require the animation of multiple distinct movements. </p>
<p>For example, a bird character might have distinct flapping, landing, and pecking movements. A human character might have distinct running, crouching and shooting movements.</p>
<p>It is often useful to provide all of these movements as one long animation, and to play the animation segments for specific movements as required by the application. Our human character might run for a while, then crouch, take a few shots, and then start running again, all under control of the application, by extracting and playing the animation segment for each movement, in turn, from the single long animation that contains all the movements.</p>
<p>To support this behaviour, you can load the entire long animation into one track of animation, and then use this method to create a separate animation track that contains only the animation for a single movement. You can then animate only that movement, or repeat only that movement in a loop (such as running or flying), or blend that movement with other animation tracks to allow your human character to run and shoot at the same time, or smoothly transition your bird from the flapping movement to the landing movement.</p>
<p>This method creates and adds a new animation track that plays only a segment of the existing animation track specified by baseTrackID. The new animation is added to this node on the animation track specified by trackID.</p>
<p>The start and end frames of the animation segment are defined by startFrameIndex and endFrameIndex, each of which identify a frame in the base animation track, inclusively. Frame indexing is zero-based, so the first frame is identified as frame index zero.</p>
<p>For example, if you wish to create a new animation track that plays frames 10 through 20, inclusively, of an existing animation track, you would pass 10 and 20 as the startFrameIndex and endFrameIndex parameters, respectively.</p>
<p>This method is automatically propagated to all descendant nodes, so you only need to invoke this method on a single ancestor node (eg- the root node of your character). </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#adab7f4e9c2421024c573f347e2a63e38">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ac8f5b7bc869d5271d4302b579afd4ec4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) addAnimationFromPODFile: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>podFilePath</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the animation contained in the specified POD file to this node and all its descendants. </p>
<p>The animation is added in a new track, whose ID is returned from this method.</p>
<p>If the specified POD file has already been loaded, it is retrieved from the resource cache. If the POD file has not been loaded, it will be loaded and placed in the resource cache. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_o_d_animation_08.html#ac8f5b7bc869d5271d4302b579afd4ec4">CC3Node(PODAnimation)</a>.</p>

</div>
</div>
<a class="anchor" id="a547de2cac17004697d1170b9949b3734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="category_c_c3_node_07_p_o_d_animation_08.html#ac8f5b7bc869d5271d4302b579afd4ec4">addAnimationFromPODFile:</a> </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>podFilePath</em></td>
        </tr>
        <tr>
          <td class="paramkey">asTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the animation contained in the specified POD file to this node and all its descendants. </p>
<p>The animation is added as the specified track.</p>
<p>If the specified POD file has already been loaded, it is retrieved from the resource cache. If the POD file has not been loaded, it will be loaded and placed in the resource cache. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_o_d_animation_08.html#a547de2cac17004697d1170b9949b3734">CC3Node(PODAnimation)</a>.</p>

</div>
</div>
<a class="anchor" id="ab44e38f9b8be4637541b180e16abbb9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) addAnimationInResource: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_nodes_resource.html">CC3NodesResource</a> *)&#160;</td>
          <td class="paramname"><em>rez</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the animation contained in the nodes in the specified nodes resource to this node and all its descendants. </p>
<p>The animation is added in a new track, whose ID is returned from this method.</p>
<p>The getNodeMatching: method of the specified resource is used to match each node in this hierarchy to the corresponding node in the specified resource. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_c_c3_nodes_resource_08.html#ab44e38f9b8be4637541b180e16abbb9a">CC3Node(CC3NodesResource)</a>.</p>

</div>
</div>
<a class="anchor" id="ab34de6856ed14b1c76cc8a1727e9db8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="category_c_c3_node_07_c_c3_nodes_resource_08.html#ab44e38f9b8be4637541b180e16abbb9a">addAnimationInResource:</a> </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_nodes_resource.html">CC3NodesResource</a> *)&#160;</td>
          <td class="paramname"><em>rez</em></td>
        </tr>
        <tr>
          <td class="paramkey">asTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the animation contained in the nodes in the specified nodes resource to this node and all its descendants. </p>
<p>The animation is added as the specified track.</p>
<p>The getNodeMatching: method of the specified resource is used to match each node in this hierarchy to the corresponding node in the specified resource. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_c_c3_nodes_resource_08.html#ab34de6856ed14b1c76cc8a1727e9db8e">CC3Node(CC3NodesResource)</a>.</p>

</div>
</div>
<a class="anchor" id="ac15392ebeef563410922d572ddeb8763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addAnimationState: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_animation_state.html">CC3NodeAnimationState</a> *)&#160;</td>
          <td class="paramname"><em>animationState</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified animation state wrapper, containing animation and track information. </p>
<p>A node may contain only one animation per animation track. If an animation already exists for the track represented in the specified animation state, it is replaced with the animation in the specified animation state.</p>
<p>Typically, to add animation to a node, the application would use the addAnimation:asTrack: method, rather than this method. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ac15392ebeef563410922d572ddeb8763">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ae2e9f558c788f29f9107799cc6c1dde8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addAxesDirectionMarkers </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds three visble direction marker lines, indicating the direction of the X, Y &amp; Z axes, in the local coordinate system of this node. </p>
<p>The lines extend from the origin of this node to a location somewhat outside the node in the direction of each of the X, Y &amp; Z axes.</p>
<p>The lines are color-coded red, green and blue for the X, Y &amp; Z axes, respectively, as an easy (RGB &lt;=&gt; XYZ) mnemonic.</p>
<p>When using this method on a node that does not have an effective bounding box, such as a light or camera, a length will be automatically calculated as a fraction of the scene size. You can also set the <a class="el" href="interface_c_c3_direction_marker_node.html#a4698ad35187473aa348cde562d535c04" title="Returns the minimum length of a direction marker line, expressed in the global coordinate system...">directionMarkerMinimumLength (CC3DirectionMarkerNode)</a> class-side property to establish a minimum length for the axis markers.</p>
<p>See the addDirectionMarkerColored:inDirection: method for more info. </p>

</div>
</div>
<a class="anchor" id="ac4d0746d13937340c19e38b1c04c3476"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addChild: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td>
          <td class="paramname"><em>aNode</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified node as a direct child node to this node. </p>
<p>The child node is automatically removed from its existing parent.</p>
<p>It is safe to invoke this method more than once for the same child node. This method does nothing if the child already has this node as its parent.</p>
<p>If you are invoking this method from the updateBeforeTransform: of the node being added, this node, or any ancestor node (including your <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>), the globalTransformMatrix of the node being added (and its descendant nodes) will automatically be updated. However, if you are invoking this method from the updateAfterTransform: method, you should invoke the updateTransformMatrices method on the node being added after this method is finished, to ensure that the transform matrices are udpated.</p>
<p>If this method is being invoked from a background thread (ie- not the main rendering thread) AND this node is already part of a scene, this operation will automatically be deferred and queued onto the main operation queue, to be performed on teh main rendering thread prior to the next rendeirng cycle. This is to ensure that the node is not added while the scene is being rendered, to avoid race conditions.</p>
<p>In this situation, subsequent code executed on the background thread should not rely on the specified node, or any of its descendants, having been added to the receiver or the scene. For example, invoking this method on the background thread, followed by getNodeNamed: to the receiver (or any of its ancestors), will almost certainly return nil, because this method will have been deferred to the main thread, and will, almost certainly, not have been run by the time the subsequent getNodeNamed: method is run on the background thread. </p>

</div>
</div>
<a class="anchor" id="ae1c5fcce1fb86489deaf1d5fe04785cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addContentFromPODFile: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aFilepath</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates an instance of <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that can be loaded from a PVR POD resource file. ">CC3PODResourceNode</a>, loads it from the POD file at the specified path, and adds the <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that can be loaded from a PVR POD resource file. ">CC3PODResourceNode</a> instance as a child node to this <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance. </p>
<p>The specified file path may be either an absolute path, or a path relative to the application resource directory. If the file is located directly in the application resources directory, the specified file path can simply be the name of the file.</p>
<p>The name of the resource node will be that of the file.</p>
<p>If this method is being invoked from a background thread (ie- not the main rendering thread) AND this node is already part of a scene, this operation will automatically be deferred and queued onto the main operation queue, to be performed on teh main rendering thread prior to the next rendeirng cycle. This is to ensure that the node is not added while the scene is being rendered, to avoid race conditions.</p>
<p>In this situation, subsequent code executed on the background thread should not rely on the specified node, or any of its descendants, having been added to the receiver or the scene. For example, invoking this method on the background thread, followed by getNodeNamed: to the receiver (or any of its ancestors), will almost certainly return nil, because this method will have been deferred to the main thread, and will, almost certainly, not have been run by the time the subsequent getNodeNamed: method is run on the background thread. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_rez_08.html#ae1c5fcce1fb86489deaf1d5fe04785cd">CC3Node(PVRPODRez)</a>.</p>

</div>
</div>
<a class="anchor" id="a865fedc54c8b53e50f3ebd1554c208fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_rez_08.html#ae1c5fcce1fb86489deaf1d5fe04785cd">addContentFromPODFile:</a> </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aFilepath</em></td>
        </tr>
        <tr>
          <td class="paramkey">withName:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates an instance of <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that can be loaded from a PVR POD resource file. ">CC3PODResourceNode</a> with the specified name, loads it from the POD file at the specified path, and adds the <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that can be loaded from a PVR POD resource file. ">CC3PODResourceNode</a> instance as a child node to this <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance. </p>
<p>The specified file path may be either an absolute path, or a path relative to the application resource directory. If the file is located directly in the application resources directory, the specified file path can simply be the name of the file.</p>
<p>If this method is being invoked from a background thread (ie- not the main rendering thread) AND this node is already part of a scene, this operation will automatically be deferred and queued onto the main operation queue, to be performed on teh main rendering thread prior to the next rendeirng cycle. This is to ensure that the node is not added while the scene is being rendered, to avoid race conditions.</p>
<p>In this situation, subsequent code executed on the background thread should not rely on the specified node, or any of its descendants, having been added to the receiver or the scene. For example, invoking this method on the background thread, followed by getNodeNamed: to the receiver (or any of its ancestors), will almost certainly return nil, because this method will have been deferred to the main thread, and will, almost certainly, not have been run by the time the subsequent getNodeNamed: method is run on the background thread. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_rez_08.html#a865fedc54c8b53e50f3ebd1554c208fe">CC3Node(PVRPODRez)</a>.</p>

</div>
</div>
<a class="anchor" id="ac4e75759d5923464b0e7a766e88bf910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addContentFromPODResourceFile: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use the addContentFromPODFile: method instead, which supports both absolute file paths and file paths that are relative to the resources directory. </dd></dl>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_rez_08.html#ac4e75759d5923464b0e7a766e88bf910">CC3Node(PVRPODRez)</a>.</p>

</div>
</div>
<a class="anchor" id="a124b119dda19e0776892cb402fa330c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_rez_08.html#ac4e75759d5923464b0e7a766e88bf910">addContentFromPODResourceFile:</a> </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aRezPath</em></td>
        </tr>
        <tr>
          <td class="paramkey">withName:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>__deprecated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Use the addContentFromPODFile:withName: method instead, which supports both absolute file paths and file paths that are relative to the resources directory. </dd></dl>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_rez_08.html#a124b119dda19e0776892cb402fa330c6">CC3Node(PVRPODRez)</a>.</p>

</div>
</div>
<a class="anchor" id="aa930b2bc24563bfd1f635f8d833ba618"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addDirectionMarker </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a visble line, drawn in the color indicated by the directionMarkerColor class-side property, from the origin of this node to a location somewhat outside the node in the direction of the forwardDirection property, in the node's local coordinate system, and in the direction of the globalForwardDirection property, in the global coordinate system of the scene. </p>
<p>When using this method on a node that does not have an effective bounding box, such as a light or camera, a length will be automatically calculated as a fraction of the scene size. You can also set the <a class="el" href="interface_c_c3_direction_marker_node.html#a4698ad35187473aa348cde562d535c04" title="Returns the minimum length of a direction marker line, expressed in the global coordinate system...">directionMarkerMinimumLength (CC3DirectionMarkerNode)</a> class-side property to establish a minimum length for the axis markers.</p>
<p>See the addDirectionMarkerColored:inDirection: method for more info. </p>

</div>
</div>
<a class="anchor" id="a5a5b607ec466a3fa89e5943c6f242cb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addDirectionMarkerColored: </td>
          <td></td>
          <td class="paramtype">(ccColor4F)&#160;</td>
          <td class="paramname"><em>aColor</em></td>
        </tr>
        <tr>
          <td class="paramkey">inDirection:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>aDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a visble line, drawn in the specified color, from the origin of this node to a location somewhat outside the node in the specified direction. </p>
<p>The extent that the line will protrude from this node is proportional to the size of this node, as determined by the <a class="el" href="interface_c_c3_direction_marker_node.html" title="CC3DirectionMarkerNode is a type of CC3LineNode specialized for drawing a line from the origin of its...">CC3DirectionMarkerNode</a> class-side directionMarkerScale property.</p>
<p>The line is drawn by creating and adding a <a class="el" href="interface_c_c3_direction_marker_node.html" title="CC3DirectionMarkerNode is a type of CC3LineNode specialized for drawing a line from the origin of its...">CC3DirectionMarkerNode</a> as a child node to this node. The length of the child node is set from the boundingBox property of this node, so that the line protrudes somewhat from this node.</p>
<p>When using this method on a node that does not have an effective bounding box, such as a light or camera, a length will be automatically calculated as a fraction of the scene size. You can also set the <a class="el" href="interface_c_c3_direction_marker_node.html#a4698ad35187473aa348cde562d535c04" title="Returns the minimum length of a direction marker line, expressed in the global coordinate system...">directionMarkerMinimumLength (CC3DirectionMarkerNode)</a> class-side property to establish a minimum length for the axis markers.</p>
<p>You can add more than one direction marker, and assign different colors to each.</p>
<p>This feature can be useful during development in helping to determine the rotational orientation of a 3D structural node.</p>
<p>By default, the child line node is not touchable, even if this node is touchable. If, for some reason you want the wireframe to be touchable, you can retrieve the direction marker nodes via the directionMarkers property, and set the touchEnabled property to YES. </p>

</div>
</div>
<a class="anchor" id="ab3752cf2ecc791b495f3f5291312908b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addShadowVolumes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each light currently in the scene, adds a shadow volume to each descendant node that contains a mesh. </p>
<p>This method is a convenience method that invokes the addShadowVolumesForLight: on this node for each existing light in the scene. See the notes for the addShadowVolumesForLight: method for detailed information about adding shadow volumes to nodes.</p>
<p>It is safe to invoke this method more than once with the same, or a different light. Only one shadow volume will be added to any mesh node for a particular light. The mesh node implementation checks to see if a shadow volume has been added already, and will not add a second shadow volume for the same light.</p>
<p>This method requires access to the lights in the scene, and will only be effective when invoked after:</p>
<ul>
<li>The node has been added to the scene.</li>
<li>The lights that are to cast shadows have been added to the scene. Invoking this method before adding this node, its descendants, and the lights, to the scene will have no effect. </li>
</ul>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#ab3752cf2ecc791b495f3f5291312908b">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a2a26a75747b710ba9b8138c0ff9ddc4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addShadowVolumesForLight: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_light.html">CC3Light</a> *)&#160;</td>
          <td class="paramname"><em>aLight</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a shadow volume to each descendant node that contains a mesh, for the specified light. </p>
<p>By using this method, you can control which lights cast shadows for each mesh node in your scene.</p>
<p>A shadow volume is a special child mesh node added to each descendant mesh node. The effect is to have each descendant mesh cast a shadow from the specified light. Invoking this method on the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> will cause all meshes in the scene to cast shadows from the specified light.</p>
<p>These shadow volume meshes are invisible, but are used to populate a stencil buffer that keeps track of where a shadow volume mesh intersects a visible object mesh. This stencil is used to paint the shadows onto the scene.</p>
<p>The shadow volume created by this method will only have effect if the visible property of both the node and the light are set to YES (ie- turning off a light also turns off any shadows it is casting).</p>
<p>Shadow volumes use a stencil buffer to determine the areas that require shading. The stencil buffer must be allocated within the EAGLView when the view is created and initialized. On the iOS, the sencil buffer is combined with the depth buffer. You create a stencil buffer by passing the value GL_DEPTH24_STENCIL8 as the depth format argument in the CCGLView method viewWithFrame:pixelFormat:depthFormat:preserveBackbuffer:sharegroup:multiSampling:numberOfSamples:.</p>
<p>It is safe to invoke this method more than once with the same, or a different light. Only one shadow volume will be added to any mesh node for a particular light. Each mesh node checks to see if a shadow volume has been added already, and will not add a second shadow volume for the same light.</p>
<p>To ensure that all objects behind each shadow-casting mesh node are shadowed, each shadow volume mesh extends to infinity. As a result, when a shadow volum is added using this method, the hasInfiniteDepthOfField property of the active camera is automatically set to YES, so that the shadow volume is not clipped by the far clipping plane of the camera's frustum.</p>
<p>If you know that you will never require end-caps, and want a finite camera frustum, you can set the hasInfiniteDepthOfField of the active camera back to NO. See the notes for the shouldAddShadowVolumeEndCapsOnlyWhenNeeded property for more info on the use of shadow volume end caps.</p>
<p>Shadows are inherently dynamic, and change as the shadow-casting node and light move relative to one another. For this reason, this method causes all meshes with a shadow volume to retain vertex location and index data (and for skinned meshes vertex weight and matrix index data).</p>
<p>If you know that the mesh nodes and light are fixed, after the first update to the scene, you can save memory by retrieving the vertex locations, indices, weights and matrix indices vertex arrays, set the shouldReleaseRedundantContent property on each to YES, and invoke the releaseRedundantContent method on each.</p>
<p>The internal management of shadow volumes requires intense access to the faces of the mesh that is casting the shadow. For this reason, when a shadow volume is added to a mesh node, the shouldCacheFaces property of that node is automatically set to YES, to improve the performance of shadow volume calculations. If you prefer to preserve memory instead, you can explicitly set this property back to NO.</p>
<p>This method will affect only the current descendant mesh nodes. Descendants added after this method is invoked will not automatically cast shadows. When dynamically adding a descendant node, invoke this method to have the new node cast a shadow from the specified light.</p>
<p>When a light is removed from the scene, the shadow volume for that light will automatically be removed from each mesh node. However, when a light is added, shadow volumes will not automatically be created for that light. When dyamically adding a light, you should invoke this method, or the addShadowVolumes method, to create a shadow volume for that light. </p>

<p>Implemented in <a class="el" href="interface_c_c3_billboard.html#a8dad38914c24ebb92b37dced6edeaf47">CC3Billboard</a>.</p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a2a26a75747b710ba9b8138c0ff9ddc4d">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a0e5ba9a571646991c5d1904424e6851c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addTexture: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *)&#160;</td>
          <td class="paramname"><em>aTexture</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method for adding a texture covering all descendant mesh nodes. </p>
<p>Invoking this method invokes the same method on all descendant mesh nodes. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a75487bc521c8b3e5abf844258a3237e8">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a4a4fb12dbc22b247ce684f55f6ce7fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) addTransformListener: </td>
          <td></td>
          <td class="paramtype">(id&lt; <a class="el" href="protocol_c_c3_node_transform_listener_protocol-p.html">CC3NodeTransformListenerProtocol</a> &gt;)&#160;</td>
          <td class="paramname"><em>aListener</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates that the specified listener object wishes to be notified whenever the transform of this node has changed. </p>
<p>This occurs when one of the transform properties (location, rotation &amp; scale) of this node, or any of its structural ancestor nodes has changed.</p>
<p>The listener will be sent the nodeWasTransformed: notification message whenever the globalTransformMatrix of this node is recalculated, or is set directly.</p>
<p>Once added by this method, the newly added listener is immediately sent the nodeWasTransformed: notification message, so that the listener is aware of this node's current transform state. This is necessary in case this node will not be transformed in the near future,</p>
<p>It is safe to invoke this method more than once for the same listener, or with a nil listener. In either case, this method simply ignores the request.</p>
<p>Transform listeners are weakly referenced. Each listener should know who it has subscribed to, and must remove itself as a listener (using the removeTransformListener: method) when appropriate, such as when being deallocated.</p>
<p>For the same reason, transform listeners are not automatically copied when a node is copied. If you copy a node and want its listeners to also listen to the copied node, you must deliberately add them to the new node. </p>

</div>
</div>
<a class="anchor" id="a5b69b89f01d7c98c0303f1e03d976558"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) alignInvertedTextures </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000161">Deprecated:</a></b></dt><dd>The alignment performed by this method is now performed automatically whenever a texture or material is attached to a mesh node. If you do need to manually align a mesh to a texture, use the expectsVerticallyFlippedTextures property to indicate whether the texture mesh is aligned with vertically-flipped texture prior to setting the texture or material into your mesh nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ba26fe792bf02227f68e7e22d3a56cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) alignTextures </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000160">Deprecated:</a></b></dt><dd>The alignment performed by this method is now performed automatically whenever a texture or material is attached to a mesh node. If you do need to manually align a mesh to a texture, use the expectsVerticallyFlippedTextures property to indicate whether the texture mesh is aligned with vertically-flipped texture prior to setting the texture or material into your mesh nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="abac2ab3bb9afaeac8c9f10f15d192e77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) animationBlendingWeightOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the animation blending weight for the animation on the specified track. </p>
<p>If this node does not contain animation, returns the blending weight from the first descendant node that contains animation and has a non-zero blending weight. Returns zero if no descendant nodes contain animation, or all descendant blending weights are zero. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#abac2ab3bb9afaeac8c9f10f15d192e77">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="aeb2267197329bb9fc0e31c66242ab73a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (CCTime) animationTimeOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current elapsed animation time for the animation on the specified track, as a value between zero and one. </p>
<p>If this node does not contain animation, returns the animation time from the first descendant node that contains animation and has a non-zero animation time. Returns zero if no descendant nodes contain animation, or all descendant animation times are zero. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#aeb2267197329bb9fc0e31c66242ab73a">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a5e0c8eb0c20c5eee0c4cc4384846ce08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) appendStructureDescriptionTo: </td>
          <td></td>
          <td class="paramtype">(NSMutableString *)&#160;</td>
          <td class="paramname"><em>desc</em></td>
        </tr>
        <tr>
          <td class="paramkey">withIndent:</td>
          <td></td>
          <td class="paramtype">(NSUInteger)&#160;</td>
          <td class="paramname"><em>indentLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the description of this node to the specified mutable string, on a new line and indented the specified number of levels. </p>
<p>Returns the specified mutable string, as a convenience. </p>

</div>
</div>
<a class="anchor" id="a9fb2fa07002acb921025124e3508a084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) applyEffectNamed: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>effectName</em></td>
        </tr>
        <tr>
          <td class="paramkey">inPFXResourceFile:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>filePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the PFX effect with the specified name, found in the <a class="el" href="interface_c_c3_p_f_x_resource.html" title="CC3PFXResource is a CC3Resource that wraps a PVR PFX data structure loaded from a file...">CC3PFXResource</a> loaded from the specfied file, to all descendant mesh nodes. </p>
<p>Sets the shader program to that defined by the retrieved PFX effect, and sets the textures of the material in each mesh node to those defined by the retrieved PFX effect</p>
<p>Raises an assertion error if the PFX resource file could not be loaded, or if that PFX resource does not contain an effect with the specified effect name. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_f_x_effects_08.html#a9fb2fa07002acb921025124e3508a084">CC3Node(PFXEffects)</a>.</p>

</div>
</div>
<a class="anchor" id="a40131e0542d562e8bd914d656ebdb469"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) applyEffectNamed: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>effectName</em></td>
        </tr>
        <tr>
          <td class="paramkey">inPFXResourceNamed:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>rezName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the PFX effect with the specified name, found in the cached <a class="el" href="interface_c_c3_p_f_x_resource.html" title="CC3PFXResource is a CC3Resource that wraps a PVR PFX data structure loaded from a file...">CC3PFXResource</a> with the specifed name, to all descendant mesh nodes. </p>
<p>Sets the shader program to that defined by the retrieved PFX effect, and sets the textures of the material in each mesh node to those defined by the retrieved PFX effect</p>
<p>Raises an assertion error if a PFX resource with the specified name cannot be found in the PFX resource cache, or if that PFX resource does not contain an effect with the specified effect name. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_f_x_effects_08.html#a40131e0542d562e8bd914d656ebdb469">CC3Node(PFXEffects)</a>.</p>

</div>
</div>
<a class="anchor" id="a9d64a7b5358717a0440f418dd82813f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) applyLocalTransformsTo: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a> *)&#160;</td>
          <td class="paramname"><em>matrix</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template method that applies the local location, rotation, and scale properties to the specified matrix. </p>
<p>Subclasses may override to enhance or modify this behaviour.</p>
<p>This method makes no assumptions about the current contents of the specified matrix, and does not replace any of that content through population. Instead, the local tranforms of this node will be applied to the current state of the matrix to transform it accordingly.</p>
<p>This method is invoked automatically to populate the globalTransformMatrix, which is used to transform this node for rendering. You can also invoke this method to apply the transform properties of this node to any other matrix, for other calculations. </p>

</div>
</div>
<a class="anchor" id="a0fa0e16be670dfa52b72b1518444db8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>*) asBumpMapLightTrackingWrapper </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps this node in a new autoreleased instance of <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D scene, including visible mesh...">CC3Node</a>, and returns the new wrapper node. </p>
<p>This node appears as the lone child node of the returned node.</p>
<p>This method uses the asTrackingWrapper method to create a wrapper that automatically tracks the target once it has been assigned.</p>
<p>The isTrackingForBumpMapping of the returned wrapper is set to YES, so that if the target that is assigned is a <a class="el" href="interface_c_c3_light.html" title="CC3Light represents the light in the 3D scene. ">CC3Light</a>, the wrapper will update the globalLightPosition of the wrapped node from the tracked location of the light, instead of rotating to face the light. This allows the normals embedded in any bump-mapped texture on the wrapped node to interact with the direction of the light source to create per-pixel luminosity that appears realistic </p>

</div>
</div>
<a class="anchor" id="a11b9ecbaf2729324c0ce5139307ef13a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>*) asCameraTrackingWrapper </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps this node in a new autoreleased instance of <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D scene, including visible mesh...">CC3Node</a>, and returns the new wrapper node. </p>
<p>This node appears as the lone child node of the returned node.</p>
<p>This method uses the asOrientingWrapper method to create the wrapper. The shouldAutotargetCamera property of the returned wrapper node is set to YES so that the wrapper will automatically locate and track the active camera. When using this method, you do not need to set the camera as the target of the wrapper, as it is located and assigned automatically. See the notes of the shouldAutotargetCamera property for more info. </p>

</div>
</div>
<a class="anchor" id="a9cba45f72c3638ec7e35a2060e2ba58e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>*) asOrientingWrapper </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps this node in a new autoreleased instance of <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D scene, including visible mesh...">CC3Node</a>, and returns the new wrapper node. </p>
<p>This node appears as the lone child node of the returned node.</p>
<p>This is a convenience method that is useful when a rotational or locational offset needs to be assigned to a node.</p>
<p>For instance, for nodes that point towards a specific target or location, to change the side of the node that is facing that target node, you can use this method to create a wrapper node, and then assign an offset rotation to the this node, so that it is rotated by a fixed amount relative to the wrapper node. You can then assign the target or target location to the wrapper, which will rotate to point its forwardDirection towards the target, carrying this node along with it. The result will be that the desired side of this node will point towards the target.</p>
<p>As another example, to offset the origin of a node (the point associated with its location, and around which the node pivots when rotated you can use this method to create a wrapper node, and then assign an offset location to this node, so that it is offset by a fixed amount relative to the wrapper node. You can then rotate or locate the wrapper node, which will carry this node along with it. The result will be that the desired point in this node will be located at the origin of rotation and location operations.</p>
<p>The shouldAutoremoveWhenEmpty property of the returned wrapper node is set to YES, so the wrapper node will automatically disappear when this node is removed from the node structural hierarchy.</p>
<p>The returned wrapper node will have the name "&lt;this node name&gt;-OW". </p>

</div>
</div>
<a class="anchor" id="a21657a0ccdb8b8cba8d63497941f9044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>*) asTrackingWrapper </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps this node in a new autoreleased instance of <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D scene, including visible mesh...">CC3Node</a>, and returns the new wrapper node. </p>
<p>This node appears as the lone child node of the returned node.</p>
<p>This method uses the asOrientingWrapper method to create the wrapper. The shouldTrackTarget property of the returned wrapper node is set to YES so that the wrapper will automatically track the target after it has been assigned. </p>

</div>
</div>
<a class="anchor" id="acaf3b104117af9ee7cfc8ed440bc5bbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) bindRestPose </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the rest pose of any skeletons contained within the descendants of this node. </p>
<p>This method must be invoked after the initial locations and rotations of each bone in the skeletons are set.</p>
<p>These initial bone orientations are those that align with the native structure of the vertices in the mesh, and collectively are known as the rest pose of the skeleton. Changes to the transform properties of the individual bone nodes, relative to the rest pose, will deform the mesh from its natural structure.</p>
<p>The bone transforms must be calculated locally from the perspective of the <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a> that contains a skeleton and skin mesh. This method should only be invoked on the <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a> or a structural ancestor of that node,</p>
<p>This implementation simply passes this invocation along to the children of this node. Subclasses contained in the soft-body node will add additional functionality. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_skinning_08.html#acaf3b104117af9ee7cfc8ed440bc5bbd">CC3Node(Skinning)</a>.</p>

</div>
</div>
<a class="anchor" id="ab2f9922d1b734bcdca29d3b5f669c1ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_box.html">CC3Box</a>) boundingBoxRelativeTo: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td>
          <td class="paramname"><em>ancestor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest axis-aligned bounding box that surrounds any local content of this node, plus all descendants of this node. </p>
<p>The returned bounding box is specified in the coordinate system of the specified node, or in the global coordinate system of the 3D scene if the ancestor is nil.</p>
<p>Returns kCC3BoxNull if this node has no local content or descendants.</p>
<p>Since the bounding box of a node can change based on the locations, rotations, or scales of any descendant node, this property is measured dynamically on each access, by traversing all descendant nodes. This is a computationally expensive method. </p>

</div>
</div>
<a class="anchor" id="aa0aa21cf629380b2cc24cb6196cdad63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) buildTransformMatrixWithVisitor: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000171">Deprecated:</a></b></dt><dd>No longer needed. Does nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a65611a362386a198f5037c953c5a8f7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) checkDrawingOrder </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the child nodes of this node are in the correct drawing order relative to other nodes. </p>
<p>This implementation forwards this request to all descendants. Those descendants with local content to draw will check their positions in the drawing sequence by passing this notification up the ancestor chain to the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>.</p>
<p>By default, nodes are automatically repositioned on each drawing frame to optimize the drawing order, so you should usually have no need to use this method.</p>
<p>However, in order to eliminate the overhead of checking each node during each drawing frame, you can disable this automatic behaviour by setting the allowSequenceUpdates property of specific drawing sequencers to NO.</p>
<p>In that case, if you modify the properties of a node or its content, such as mesh or material opacity, and your <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> drawing sequencer uses that criteria to sort nodes, you can invoke this method to force the node to be repositioned in the correct drawing order.</p>
<p>You don't need to invoke this method when initially setting the properties. You only need to invoke this method if you modify the properties after the node has been added to the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>, either by itself, or as part of a node assembly. </p>

<p>Implemented in <a class="el" href="interface_c_c3_local_content_node.html#ac8968cbf06cb1242f9dbbbaae139477f">CC3LocalContentNode</a>.</p>

</div>
</div>
<a class="anchor" id="aa3546f3c282b8321773cc6be505f07dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) cleanupActions </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops all running CCActions for this node and all descendant nodes. </p>
<p>Effectively invokes stopAllActions on this node and all descendant nodes. </p>

</div>
</div>
<a class="anchor" id="afd27670c1e17cf6beb5dc1e0a39474ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>*) closestNodeIntersectedByGlobalRay: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_ray.html">CC3Ray</a>)&#160;</td>
          <td class="paramname"><em>aRay</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects the descendant nodes that are intersected (punctured) by the specified ray, and returns the node whose global puncture location is closest to the startLocation of the ray, or returns nil if the ray punctures no nodes. </p>
<p>This node is included in the test.</p>
<p>The ray must be specified in global coordinates.</p>
<p>The result will not include any node that does not have a bounding volume, or whose shouldIgnoreRayIntersection property is set to YES.</p>
<p>This method also excludes invisible nodes and nodes where the ray starts inside the bounding volume of the node. To gain finer control over this behaviour, instead of using this method, create an instance of <a class="el" href="interface_c_c3_node_puncturing_visitor.html" title="CC3NodePuncturingVisitor is a CC3NodeVisitor that is used to collect nodes that are punctured (inters...">CC3NodePuncturingVisitor</a>, adjust its settings, and invoke the visit: method on the visitor, with this node as the arguement.</p>
<p>Also, to avoid creating a new visitor for each visit, you can create a single instance of <a class="el" href="interface_c_c3_node_puncturing_visitor.html" title="CC3NodePuncturingVisitor is a CC3NodeVisitor that is used to collect nodes that are punctured (inters...">CC3NodePuncturingVisitor</a>, cache it, and invoke the visit: method repeatedly, with or without changing the ray between invocations.</p>
<p>This implementation simply invokes the nodesIntersectedByGlobalRay: method, and reads the value of the closestPuncturedNode from the <a class="el" href="interface_c_c3_node_puncturing_visitor.html" title="CC3NodePuncturingVisitor is a CC3NodeVisitor that is used to collect nodes that are punctured (inters...">CC3NodePuncturingVisitor</a> returned by that method. See the notes of the nodesIntersectedByGlobalRay: method for more info. </p>

</div>
</div>
<a class="anchor" id="a4f9d4fb6b2f6ecaf7ff37953fb7553e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) containsAnimationOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether this node, or any of its descendants, contains animation on the specified animation track. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a4f9d4fb6b2f6ecaf7ff37953fb7553e7">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a7bda04af22d4853e65cbb1b2a7be0097"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) copy </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a newly allocated (retained) copy of this instance. </p>
<p>The new copy will have the same name as this node, but will have a unique tag.</p>
<p>The copying operation effects a deep copy. For any content that is held by reference (eg- objects), and subject to future modification, a copy is created, so that both this instance and the other instance can be treated independently. This includes child nodes, of which copies are created.</p>
<p>The following rules are applied when copying a node:</p>
<ul>
<li>The tag property is not copied. The tag is property is assigned and automatically generated unique tag value.</li>
<li>The copy will initially have no parent. It will automatically be set when this node is added as a child to a parent node.</li>
<li>Copies are created of all child nodes, using the copy method of each child. The child nodes of the new node will therefore have the same names as the child nodes of the original node.</li>
<li>Mesh data is copied by reference, not by value. Child nodes that support mesh data will assign it by reference when that child is copied. Mesh data is shared between both the original mesh node and copy node.</li>
</ul>
<p>Subclasses that extend content should honour the deep copy design pattern, making exceptions only for content that is both large and not subject to modifications, such as mesh data.</p>
<p>This method may often be used to duplicate a node many times, to create large number of similar instances to populate a game. To help you verify that you are correctly releasing and deallocating all these copies, you can use the instanceCount class method to get a current count of the total number of instances of all subclasses of <a class="el" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances...">CC3Identifiable</a>, When reviewing that number, remember that nodes are only one type of <a class="el" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances...">CC3Identifiable</a>, and other subclasses, such as materials, will contribute to this count. </p>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#ac177c497bf19de1f8208eb375edfef37">CC3Identifiable</a>.</p>

</div>
</div>
<a class="anchor" id="aec0fbbf1cbbbf174ec68f2322856db97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) copyWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aName</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a newly allocated (retained) copy of this instance. </p>
<p>The new copy will have its name set to the specified name, and will have a unique tag.</p>
<p>The copying operation effects a deep copy. See the notes at the copy method for more details about copying nodes. </p>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a2fc25bb52f8f0815c0985e02aeac0e35">CC3Identifiable</a>.</p>

</div>
</div>
<a class="anchor" id="a26356a1eaf961c2b0cf37979f8a1239d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) createBoundingVolume </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this node has no bounding volume, sets the boundingVolume property to the value returned by the defaultBoundingVolume property. </p>
<p>The automatic creation of a bounding volume relies on having the vertex locations in memory. Therefore, on mesh nodes, make sure that you invoke this method before invoking the releaseRedundantContent method, otherwise a bounding volume will not be created.</p>
<p>It is safe to invoke this method more than once. Each node that creates a bounding volume will do so only if it does not already have a bounding volume. </p>

</div>
</div>
<a class="anchor" id="a68e1a94a009c558a206669e4e75c9b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) createBoundingVolumes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the createBoundingVolume method to set the boundingVolume property to the value returned by the defaultBoundingVolume property, and then propagates this same method to all descendant nodes, to create bounding volumes for all all descendant nodes, as defined by the defaultBoundingVolume property of each descendant. </p>
<p>The automatic creation of a bounding volume relies on having the vertex locations in memory. Therefore, make sure that you invoke this method before invoking the releaseRedundantContent method, otherwise a bounding volume will not be created.</p>
<p>This method does not automatically create a bounding volume for skinned mesh node descendants. To do so, you must also invoke the createSkinnedBoundingVolumes method. See the notes of that method for an explanation.</p>
<p>It is safe to invoke this method more than once. Each node that creates a bounding volume will do so only if it does not already have a bounding volume. </p>

</div>
</div>
<a class="anchor" id="aa1be5eb9f0e3e3f2513b5050e4d585f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) createGLBuffers </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates OpenGL ES buffers to be used by the GL engine hardware. </p>
<p>Default behaviour is to invoke the same method on all child nodes. Subclasses that can make use of hardware buffering, notably mesh subclasses, will override and bind their data to GL hardware buffers.</p>
<p>Invoking this method is optional and is not performed automatically. If an application does not wish to use hardware buffering for some nodes, it can do so by avoiding the invocation of this method on those nodes. Typically, however, an applicaiton will simply invoke this method once during initialization of highest-level ancestor node (ususally a subclass of <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>). </p>

</div>
</div>
<a class="anchor" id="ad2afa741047a45ad1bd94e55139ddf6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) createSkinnedBoundingVolumes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the createBoundingVolume method on any skinned mesh node descendants. </p>
<p>Skinned mesh nodes are designed to move vertices under the control of external bone nodes. Because of this, the vertices might move well beyond the bounds of a static bounding volume created from the rest pose of the skinned mesh node. For this reason, bounding volumes are not generally automatically created for skinned mesh nodes by the createBoundingVolumes method, and the bounding volumes of skinned mesh nodes are typically created by the app, by determining the maximal extent that the vertices will move, and manually assigning a larger bounding volume to cover that full extent.</p>
<p>However, if you know that the vertices of the skinned mesh nodes descendants of this node will not move beyond the static bounding volume defined by the vertices in their rest poses, you can invoke this method to have bounding volumes created automatically from the rest poses of each descendant skinned mesh nodes. This method will not affect the bounding volumes of any non-skinned descendant nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_skinning_08.html#ad2afa741047a45ad1bd94e55139ddf6e">CC3Node(Skinning)</a>.</p>

</div>
</div>
<a class="anchor" id="a6d01ee847077ef6faf2652a749e670b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node_bounding_volume.html">CC3NodeBoundingVolume</a>*) defaultBoundingVolume </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an allocated, initialized, autorelease instance of the default bounding volume to be used by this node. </p>
<p>This method is invoked automatically by the createBoundingVolume method to populate the boundingVolume property.</p>
<p>Structural nodes do not generally require a bounding volume, and this implementation simply returns nil. Subclasses with drawable content, including all mesh nodes, will override this property to provide a suitable bounding volume. </p>

</div>
</div>
<a class="anchor" id="a94dda125a64d3e29b4525cd1cf61c0bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) deleteBoundingVolumes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the bounding volume of this node and all descendant nodes, by setting the boundingVolume property of this node and all descendant nodes to nil. </p>

</div>
</div>
<a class="anchor" id="a0789463c8d3f49e650adbb3212353f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) deleteGLBuffers </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes any OpenGL buffers that were created by any descendant nodes via a prior invocation of createGLBuffers. </p>
<p>If the descendant nodes also retained the vertex content locally, drawing will then revert to distinct GL draw calls, passing data through the GL API on each call, rather than via the bound buffers.</p>
<p>If a descendant node did not retain the vertex content locally, then after this method is invoked, no vertex content will be available for the node, and the node will no longer be drawn. For this reason, great care should be taken when using this method in combination with releasing the local copy of the vertex content.</p>
<p>To delete the GL buffers of a particular node without deleting those of any descendant nodes, use this method on the mesh node's mesh, instead of on the mesh node itself.</p>
<p>The local copy of the vertex content in main memory can be released via the releaseRedundantContent method. To retain the local copy of the vertex content for any particular node, invoke one or more of the retainVertex... family of methods. See the notes of the releaseRedundantContent for more info regarding retaining and releasing the local copy of the vertex content in app memory. </p>

</div>
</div>
<a class="anchor" id="a3b5477cf3d39958c394ab407b8d16b25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) describeAnimationStateForFrames: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>frameCount</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a description of the state at each of frameCount animation frames over the entire animation. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a3b5477cf3d39958c394ab407b8d16b25">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a98ec7e7de7d56c0d17630902f13831a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) <a class="el" href="category_c_c3_node_07_animation_08.html#a3b5477cf3d39958c394ab407b8d16b25">describeAnimationStateForFrames:</a> </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>frameCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromTime:</td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>startTime</em></td>
        </tr>
        <tr>
          <td class="paramkey">toTime:</td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>endTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a description of the state at each of frameCount animation frames between the specified start and end times, which should each be in the range between zero and one. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a98ec7e7de7d56c0d17630902f13831a8">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ac3f0ce03fa1126a2e8bb61ab6431f6b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) describeCurrentAnimationState </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a description of the current animation state, including time and animated location, quaternion and scale. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ac3f0ce03fa1126a2e8bb61ab6431f6b6">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="aca18dcafe9eb909c1828835372e5dc38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (CGFloat) descriptorFontSize </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the font size that will be used when drawing the descriptor text when the shouldDrawDescriptor property is set to YES on any node. </p>
<p>The initial value of this class-side property is 14.0. </p>

</div>
</div>
<a class="anchor" id="ad9766013ea54fd0d093eb6c5eb622fb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (ccColor4F) directionMarkerColor </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the color that direction marker lines will be drawn in when created using the addDirectionMarker method. </p>
<p>Setting this property to kCCC4FBlackTransparent will cause the color of any new direction marker lines to be set to the value of the color property of the node instead.</p>
<p>The initial value of this class property is kCCC4FRed. </p>

</div>
</div>
<a class="anchor" id="ad2a7fd0b3ba129e8588e0871efe15469"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disableAllAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables all animation tracks of this node, and all descendant nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ad2a7fd0b3ba129e8588e0871efe15469">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a67a0ac82b384ce3cdae07a68df6ad171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disableAllAnimationOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the animation on the specified track of this node, and all descendant nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a67a0ac82b384ce3cdae07a68df6ad171">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ab839c42ae523f62e9d02fbc3f838266d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disableAllLocationAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the animation of the location property, without affecting the animation of the other properties, on this node and all descendant nodes. </p>
<p>This method works together with the enable/disableAnimation methods. For the location property to be animated, both location animation and node animation must be enabled. Both are enabled by default. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ab839c42ae523f62e9d02fbc3f838266d">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a0a910f58010a508277db45be0e176779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disableAllQuaternionAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the animation of the quaternion property, without affecting the animation of the other properties, on this node and all descendant nodes. </p>
<p>This method works together with the enable/disableAnimation methods. For the quaternion property to be animated, both quaternion animation and node animation must be enabled. Both are enabled by default. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a0a910f58010a508277db45be0e176779">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ab44421eb938cf7369306f119934e103f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disableAllScaleAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the animation of the scale property, without affecting the animation of the other properties, on this node and all descendant nodes. </p>
<p>This method works together with the enable/disableAnimation methods. For the scale property to be animated, both scale animation and node animation must be enabled. Both are enabled by default. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ab44421eb938cf7369306f119934e103f">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="abdd6c649c5024ba5742a52bf08d17c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disableAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the animation on all animation tracks of this node. </p>
<p>This will not disable animation of child nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#abdd6c649c5024ba5742a52bf08d17c5b">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="aa686f4aca181d0d4691085be56d399bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disableAnimationOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the animation on the specified track of this node. </p>
<p>This will not disable animation of child nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#aa686f4aca181d0d4691085be56d399bc">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="abfd76f8e1fe604788ee674e8a59b8162"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disableLocationAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the animation of the location property, without affecting the animation of the other properties. </p>
<p>This method works together with the enable/disableAnimation methods. For the location property to be animated, both location animation and node animation must be enabled. Both are enabled by default.</p>
<p>This will not affect the animation of the location property of child nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#abfd76f8e1fe604788ee674e8a59b8162">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ae02afac56eee9ffa0c0ad9316fc2cc13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disableQuaternionAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the animation of the quaternion property, without affecting the animation of the other properties. </p>
<p>This method works together with the enable/disableAnimation methods. For the quaternion property to be animated, both quaternion animation and node animation must be enabled. Both are enabled by default.</p>
<p>This will not affect the animation of the quaternion property of child nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ae02afac56eee9ffa0c0ad9316fc2cc13">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ac503421e7b33e695cdf30ef4ac3206b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disableScaleAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the animation of the scale property, without affecting the animation of the other properties. </p>
<p>This method works together with the enable/disableAnimation methods. For the scale property to be animated, both scale animation and node animation must be enabled. Both are enabled by default.</p>
<p>This will not affect the animation of the scale property of child nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ac503421e7b33e695cdf30ef4ac3206b6">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a22cff3a70ea6e9e34d418432c0309d80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doesIntersectBoundingVolume: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_bounding_volume.html">CC3BoundingVolume</a> *)&#160;</td>
          <td class="paramname"><em>otherBoundingVolume</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the bounding volume of this node intersects the given bounding volume. </p>
<p>This check does not include checking children, only the local content.</p>
<p>This capability can be used for detecting collisions between nodes, or to indicate whether an object is located in a particular volume of space, for example, the frustum of the camera.</p>
<p>This implementation delegates to this node's boundingVolume. Nodes without a bounding volume will not intersect any other bounding volume. With that design in mind, if either the bounding volume of this node, or the otherBoundingVolume is nil, this method returns NO </p>

</div>
</div>
<a class="anchor" id="a313faba92d4638b21ad6d02ba7ca6e95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doesIntersectFrustum: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_frustum.html">CC3Frustum</a> *)&#160;</td>
          <td class="paramname"><em>aFrustum</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the content of this node intersects the specified frustum. </p>
<p>This method is invoked automatically during the drawing operations of each frame to determine whether this node does not intersect the camera frustum, should be culled from the visible nodes and not drawn. A return value of YES will cause the node to be drawn, a return value of NO will cause the node to be culled and not drawn.</p>
<p>If this node has a bounding volume, returns whether the bounding volume of this node intersects the specified camera frustum, by invoking the doesIntersectBoundingVolume: method of this node.</p>
<p>Returns YES always if the specified frustum is nil, or if this node does not have a bounding volume. Nodes without a bounding volume will always be drawn.</p>
<p>Culling nodes that are not visible to the camera is an important performance enhancement. The node should strive to be as accurate as possible in returning whether it intersects the camera's frustum. Incorrectly returning YES will cause wasted processing within the GL engine. Incorrectly returning NO will cause a node that should at least be partially visible to not be drawn. </p>

</div>
</div>
<a class="anchor" id="adead435b14721f581a192b1e76b72a57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doesIntersectGlobalRay: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_ray.html">CC3Ray</a>)&#160;</td>
          <td class="paramname"><em>aRay</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this node is intersected (punctured) by the specified ray, which is specified in the global coordinate system. </p>
<p>This implementation delegates to this node's boundingVolume. If this node has no bounding volume, this method returns NO. </p>

</div>
</div>
<a class="anchor" id="a78a35c89194bf1cebe32a437994811d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) doesIntersectNode: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td>
          <td class="paramname"><em>otherNode</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the bounding volume of this node intersects the bounding volume of the specified node. </p>
<p>This check does not include checking descendants of either node, only the direct bounding volumes.</p>
<p>This capability can be used for detecting collisions between nodes.</p>
<p>This implementation invokes the doesIntersectBoundingVolume: method of this node, passing the bounding volume of the other node. For an intersection to occur, both nodes must each have a bounding volume. Nodes without a bounding volume will not intersect any other bounding volume. Correspondingly, if either of the nodes do not have a bounding volume, this method returns NO </p>

</div>
</div>
<a class="anchor" id="ab55c938a9d4c2047ae3b8694da466e3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexBitangents </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bitangent content of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex normals will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexNormals method. </p>

</div>
</div>
<a class="anchor" id="a3c7d6416509ce1b148a324fb1ec104f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexBoneIndices </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bone index content of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex bone indices will not be buffered to a GL VBO. Any other vertex content, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexBoneIndices method. </p>

</div>
</div>
<a class="anchor" id="afa4c97b6f8287122ab7f1e8fdb756f57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexBoneWeights </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bone weight content of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex bone weights will not be buffered to a GL VBO. Any other vertex content, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexBoneWeights method. </p>

</div>
</div>
<a class="anchor" id="a4073440a0b8f9c18533cbc5121649657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexColors </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex color content of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex colors will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexColors method. </p>

</div>
</div>
<a class="anchor" id="ac4fda733fd787be5d6573ec8d5508bbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexContent </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause all vertex content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>This method does NOT stop vertex index data from being buffered. If you meshes use vertex indices, and you don't want them buffered, use the doNotBufferVertexIndices method as well.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexContent method. </p>

</div>
</div>
<a class="anchor" id="a17688b23c1dea97ed7b7419bf4d3b789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexIndices </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex index content of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex indices will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexColors method. </p>

</div>
</div>
<a class="anchor" id="a1c776539f12809fbf268332920a7f21d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexLocations </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex location content of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex locations will not be buffered to a GL VBO. Any other vertex data, such as normals, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexLocations method. </p>

</div>
</div>
<a class="anchor" id="af3a1d834d261b862e7af1f7426c071d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexNormals </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex normal content of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex normals will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexNormals method. </p>

</div>
</div>
<a class="anchor" id="acfeb4f470fd90218ba3fd2f7186ec5b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexPointSizes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex point size content to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex point sizes will not be buffered to a GL VBO. Any other vertex content, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexPointSizes method. </p>

<p>Implemented in <a class="el" href="interface_c_c3_point_particle_emitter.html#a42ea51c0f10e51a29b23c2f9b999024a">CC3PointParticleEmitter</a>.</p>

</div>
</div>
<a class="anchor" id="a317cb1eaaaf32e24e07d1a5bdfbd3492"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexTangents </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex tangent content of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex normals will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexNormals method. </p>

</div>
</div>
<a class="anchor" id="a388e8ab71dceb5b771695ce8785ac411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) doNotBufferVertexTextureCoordinates </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex texture coordinate content of this node and all descendant nodes, for all texture units used by those nodes, to be skipped when createGLBuffers is invoked. </p>
<p>The vertex content is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex texture coordinates will not be buffered to a GL VBO. Any other vertex content, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex content to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexTextureCoordinates method. </p>

</div>
</div>
<a class="anchor" id="a883c0a80269bd598483d19480b8276ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) drawWithVisitor: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws the content of this node to the GL engine. </p>
<p>The specified visitor encapsulates the frustum of the currently active camera, and certain drawing options.</p>
<p>As described in the class documentation, in keeping with best practices, drawing and frame rendering should be kept separate from updating the model state. Therefore, when overriding this method in a subclass (or any of the template methods invoked by this method), do not update any model state. This method should perform only frame rendering operations.</p>
<p>This method is invoked automatically as part of the drawing operations initiated by the transformAndDrawWithVisitor: method. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a8a15c4a11e9d1075a623105fe81b96f9">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a34dd9586285a4d0f067ecd47da59bb6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) enableAllAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables all animation tracks of this node, and all descendant nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a34dd9586285a4d0f067ecd47da59bb6d">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a69acc185333a63456a5f162b1204d0d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) enableAllAnimationOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the animation on the specified track of this node, and all descendant nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a69acc185333a63456a5f162b1204d0d6">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ac0fb074bec3c33d3bfa380524e77e62d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) enableAllLocationAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the animation of the location property, without affecting the animation of the other properties, on this node and all descendant nodes. </p>
<p>This method works together with the enable/disableAnimation methods. For the location property to be animated, both location animation and node animation must be enabled. Both are enabled by default. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ac0fb074bec3c33d3bfa380524e77e62d">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a1ae082fcef2f26523d0549e66ecd59ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) enableAllQuaternionAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the animation of the quaternion property, without affecting the animation of the other properties, on this node and all descendant nodes. </p>
<p>This method works together with the enable/disableAnimation methods. For the quaternion property to be animated, both quaternion animation and node animation must be enabled. Both are enabled by default. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a1ae082fcef2f26523d0549e66ecd59ea">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a5637a04b6202d4d787d6165de26bf107"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) enableAllScaleAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the animation of the scale property, without affecting the animation of the other properties, on this node and all descendant nodes. </p>
<p>This method works together with the enable/disableAnimation methods. For the scale property to be animated, both scale animation and node animation must be enabled. Both are enabled by default. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a5637a04b6202d4d787d6165de26bf107">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="aa8cf45674854a31d378335fd7b281876"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) enableAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the animation on all animation tracks of this node. </p>
<p>This will not enable animation of child nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#aa8cf45674854a31d378335fd7b281876">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a1b09569f0076e3c300462ddfa8ad63bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) enableAnimationOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the animation on the specified track of this node. </p>
<p>This will not enable animation of child nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a1b09569f0076e3c300462ddfa8ad63bc">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="abd14c816b6b12361005eecdcaa8046fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) enableLocationAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the animation of the location property, without affecting the animation of the other properties. </p>
<p>This method works together with the enable/disableAnimation methods. For the location property to be animated, both location animation and node animation must be enabled. Both are enabled by default.</p>
<p>This will not affect the animation of the location property of child nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#abd14c816b6b12361005eecdcaa8046fe">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a5406dfb6a05193cbe0be912e7de361d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) enableQuaternionAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the animation of the quaternion property, without affecting the animation of the other properties. </p>
<p>This method works together with the enable/disableAnimation methods. For the quaternion property to be animated, both quaternion animation and node animation must be enabled. Both are enabled by default.</p>
<p>This will not affect the animation of the quaternion property of child nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a5406dfb6a05193cbe0be912e7de361d8">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a1061c71857ea80540734ec72c7e23775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) enableScaleAnimation </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the animation of the scale property, without affecting the animation of the other properties. </p>
<p>This method works together with the enable/disableAnimation methods. For the scale property to be animated, both scale animation and node animation must be enabled. Both are enabled by default.</p>
<p>This will not affect the animation of the scale property of child nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a1061c71857ea80540734ec72c7e23775">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a7870cccbb1985f474af3d6371c424864"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) ensureRigidSkeleton </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures the skeletal structures controlling any descendant skinned mesh nodes are composed of bones that undergo only rigid transforms, relative to their nearest ancestor soft-body node. </p>
<p>Typically, you invoke this method on the resource node, soft-body node, or other ancestor node that contains the animated skinned character model.</p>
<p>When the bones in a skeleton contain only rigid transforms, the vertices in the skinned mesh node can be transformed within a shader using rotations and transforms only, instead of requiring a full transform matrix. This allows for many more bones to be transferred to the shader program during a single GL draw call, which increases performance in many larger meshes.</p>
<p>Consequently, invoking this method affects the choice of shader that will be selected automatically for descendant skinned mesh nodes.</p>
<p>You must invoke this method in order to have such a shader automatically selected for each skinned mesh node, even if you know that all bones contain, and are animated by, only unit scales. Otherwise, automatic shader selection will select a shader that transforms vertices using bone transform matrices, instead. Alternately, if you know all bones contain, and are animated by, only unit scales, you can manually assign the appropriate shader program, and in that case, you do not need to invoke this method.</p>
<p>For each descendant bone node, this method sets the uniformScale property to 1.0, and invokes the disableScaleAnimation method to ensure that no changes will be made to the scale property during animation. You should invoke this method after all animation tracks have been added to the bone nodes, or anytime a new animation track is added.</p>
<p>After this method has been invoked, the hasRigidSkeleton properties of all descendant skinned mesh nodes will return YES. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_skinning_08.html#a7870cccbb1985f474af3d6371c424864">CC3Node(Skinning)</a>.</p>

</div>
</div>
<a class="anchor" id="af08324d2813c786fd2fafc8c44c21a0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) establishAnimationFrameAt: </td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>Replaced with establishAnimationFrameAt:onTrack:. </dd></dl>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#af08324d2813c786fd2fafc8c44c21a0b">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a4daf4a21295df23d8d3f639db6ef9dd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) <a class="el" href="category_c_c3_node_07_animation_08.html#af08324d2813c786fd2fafc8c44c21a0b">establishAnimationFrameAt:</a> </td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>t</em></td>
        </tr>
        <tr>
          <td class="paramkey">onTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the location, quaternion and scale properties on the animation state wrapper associated with the animation on the specified track, based on the animation frame located at the specified time, which should be a value between zero and one, with zero indicating the first animation frame, and one indicating the last animation frame. </p>
<p>Only those transform properties for which there is animation content will be changed.</p>
<p>This method is usually invoked automatically from an active <a class="el" href="interface_c_c3_action_animate.html" title="CC3ActionAnimate animates a single track of animation on a CC3Node and its descendants. ">CC3ActionAnimate</a> action during each update cycle. Once all animation tracks have been updated accordingly, the node automatically blends the weighted animation from each track to determine the corresponding values of the location, quaternion and scale properties of this node.</p>
<p>This implementation delegates to the <a class="el" href="interface_c_c3_node_animation_state.html" title="CC3NodeAnimationState holds the state associated with the animation of a single node on a single trac...">CC3NodeAnimationState</a> instance that is managing the animation for the specified track, then passes this notification along to child nodes to align them with the same animation time. Linear interpolation of the frame content may be performed, based on the number of frames and the specified time.</p>
<p>If disableAnimation or disableAllAnimation has been invoked on this node, it will be excluded from animation, and this method will not have any affect on this node. However, this method will be propagated to child nodes.</p>
<p>This method is invoked automatically from an instance of <a class="el" href="interface_c_c3_action_animate.html" title="CC3ActionAnimate animates a single track of animation on a CC3Node and its descendants. ">CC3ActionAnimate</a> that is animating this node. Usually, the application never needs to invoke this method directly. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a4daf4a21295df23d8d3f639db6ef9dd6">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a14cb65f70ddb6eaec978f886ceabb06a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray*) flatten </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an autoreleased array containing this node and all its descendants. </p>
<p>This is done by invoking flattenInto: with a newly-created array, and returning the array. </p>

</div>
</div>
<a class="anchor" id="a6dcad39de9f43a824ef4c53d65ac07c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) flattenInto: </td>
          <td></td>
          <td class="paramtype">(NSMutableArray *)&#160;</td>
          <td class="paramname"><em>anArray</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds this node to the specified array, and then invokes this method on each child node. </p>
<p>The effect is to populate the array with this node and all its descendants. </p>

</div>
</div>
<a class="anchor" id="a18bfccfa645a61fe67d068c20217d66f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) flipNormals </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the direction of all of the normals in the meshes of all descendant nodes. </p>

</div>
</div>
<a class="anchor" id="a5087537210ebcd64eaf0d49843b63b44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) flipTexturesHorizontally </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that flips the texture coordinate mapping horizontally for all texture units on all descendant mesh nodes. </p>
<p>This has the effect of flipping the textures vertically on the model. and can be useful for creating interesting effects, or mirror images. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a2f5e5549ae1874d27762b8b339f0f47e">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a78e7c986cb22b878ca15d86d111b1f12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) flipTexturesVertically </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that flips the texture coordinate mapping vertically for all texture units on all descendant mesh nodes. </p>
<p>This has the effect of flipping the textures vertically on the model. and can be useful for creating interesting effects, or mirror images. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a44f9ef13af949b8731a95593d68b3fce">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a61d0d09d98d31516204e0e3ad8e227e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) freezeAllInanimatesOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the freezeIfInanimateOnTrack: method on this node and all descendant nodes, to freeze each node that does not contain animation on the specified track, to its current location, rotation, and scale, whenever animation is playing on the specified track. </p>
<p>Invoking this method can be useful if any descendant nodes are not animated, and you want to ensure that when animation is playing on the specified track, that those nodes will be forced to their current location, quaternion, and scale values.</p>
<p>It is safe to invoke this method more than once. Each time it is invoked, any inanimate descendant nodes will be frozen to the location, quaternion, and scale values at the time this method is invoked, whenever animation is playing on the specified track. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a61d0d09d98d31516204e0e3ad8e227e2">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a7d611a8024784bc8a16f4a4a95699a13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) freezeIfInanimateOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this node does not currently contain animation on the specified track, the animation on that track is set to an instance of <a class="el" href="interface_c_c3_frozen_node_animation.html" title="A concrete CC3NodeAnimation that holds animation a single, frozen animation frame. ">CC3FrozenNodeAnimation</a>, populated from the current location, quaternion, and scale properties of this node, to effectively freeze this node to its current location, rotation, and scale, throughout the animation of the specified track. </p>
<p>If this node already contains a <a class="el" href="interface_c_c3_frozen_node_animation.html" title="A concrete CC3NodeAnimation that holds animation a single, frozen animation frame. ">CC3FrozenNodeAnimation</a> on the specified track (from a prior invocation of this method), it is populated from the current location, quaternion, and scale properties of this node, to effectively freeze this node to its current location, rotation, and scale, throughout the animation of the specified track. It is safe, therefore, to invoke this method more than once.</p>
<p>If this node already contains animation of any other kind, this method does nothing.</p>
<p>This freezing behaviour is different than if the node had no animation at all. A node with no animation content can have its location, quaternion, and scale properties freely set, even while animation is running. By contrast, while an animation is running on the node containing instance of <a class="el" href="interface_c_c3_frozen_node_animation.html" title="A concrete CC3NodeAnimation that holds animation a single, frozen animation frame. ">CC3FrozenNodeAnimation</a>, the values of the location, quaternion, and scale properties will each be locked to a single value.</p>
<p>Invoking this method can be useful if this node is not really animated, but you want to ensure that when animation is playing on a node assembly, that this node is forced to a particular location, rotation, and scale. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a7d611a8024784bc8a16f4a4a95699a13">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a074b619d6b1473f6a70e8aeb121ca234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (CCAction*) getActionByTag: </td>
          <td></td>
          <td class="paramtype">(NSInteger)&#160;</td>
          <td class="paramname"><em>tag</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the action with the specified tag running on this node. </p>

</div>
</div>
<a class="anchor" id="a29b9c12cfd93822e1c38fa862b962fbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node_animation.html">CC3NodeAnimation</a>*) getAnimationOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the animation for the specified animation track, or nil if no animation has been defined for this node on that animation track. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a29b9c12cfd93822e1c38fa862b962fbc">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ab2044d57de11fedaafbf51d153eec363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node_animation_state.html">CC3NodeAnimationState</a>*) getAnimationStateOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the animation state wrapper on the specified animation track, or nil if no animation has been defined for this node on that animation track. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ab2044d57de11fedaafbf51d153eec363">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a0ad53c9ac68bd48cb9675a919b1507fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>*) getMeshNodeNamed: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aName</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that retrieves the first node found with the specified name, anywhere in the structural hierarchy of descendants of this node (not just direct children), and returns the node cast as a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>. </p>
<p>The hierarchy search is depth-first.</p>
<p>This implementation simply invokes the getNodeNamed:, and casts the node returned as a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>. An assertion is raised if the node is not a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_c_c3_mesh_node_08.html#a0ad53c9ac68bd48cb9675a919b1507fb">CC3Node(CC3MeshNode)</a>.</p>

</div>
</div>
<a class="anchor" id="a42cd132329b6a2a98cf1456f3fe58275"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>*) getNodeNamed: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aName</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the first node found with the specified name, anywhere in the structural hierarchy of descendants of this node (not just direct children). </p>
<p>The hierarchy search is depth-first. </p>

</div>
</div>
<a class="anchor" id="a8f4927d3aca147fe0993ae4c29f6d9c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>*) getNodeTagged: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>aTag</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the first node found with the specified tag, anywhere in the structural hierarchy of descendants of this node (not just direct children). </p>
<p>The hierarchy search is depth-first. </p>

</div>
</div>
<a class="anchor" id="aabe8ee8dc78ba7d6db86f48475c2dd48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_shadow_volume_mesh_node.html">CC3ShadowVolumeMeshNode</a>*) getShadowVolumeForLight: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_light.html">CC3Light</a> *)&#160;</td>
          <td class="paramname"><em>aLight</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the shadow volume that was added to this node for the specified light, or returns nil if such a shadow volume does not exist in this node. </p>
<p>This implementation only looks through the immediate child nodes of this node, and does not recurse below this level. As such, this method only has meaning when invoked on a mesh node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#aabe8ee8dc78ba7d6db86f48475c2dd48">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a195ba5dba8708a36b093319bd58521d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) globalLocationOfGlobalRayIntesection: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_ray.html">CC3Ray</a>)&#160;</td>
          <td class="paramname"><em>aRay</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the location at which the specified ray intersects the bounding volume of this node, or returns kCC3VectorNull if this node does not have a bounding volume, the shouldIgnoreRayIntersection property is set to YES, or the ray does not intersect the bounding volume. </p>
<p>The result honours the startLocation of the ray, and will return kCC3VectorNull if the bounding volume is "behind" the startLocation, even if the line projecting back through the startLocation in the negative direction of the ray intersects the bounding volume.</p>
<p>The ray may start inside the bounding volume of this node, in which case, the returned location represents the exit location of the ray.</p>
<p>Both the input ray and the returned location are specified in global coordinates.</p>
<p>The returned result can be tested for null using the CC3VectorIsNull function.</p>
<p>When using this method, keep in mind that the returned intersection location is located on the surface of the bounding volume, not on the surface of the node. Depending on the shape of the surface of the node, the returned location may visually appear to be at a different location than where you expect to see it on the surface of on the node. </p>

</div>
</div>
<a class="anchor" id="ae38803f8979b66c35acb77bb51e084d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a>*) globalRotationMatrix </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a matrix representing all of the rotations that make up this node, including ancestor nodes. </p>

</div>
</div>
<a class="anchor" id="a3061a77b9f3bc1a77e1d41a732911f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasShadowVolumes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this node, or any descendant, has had a shadow volume added for any light. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a3061a77b9f3bc1a77e1d41a732911f2b">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a0723edbc79ce0b3518e11f35594ccd41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasShadowVolumesForLight: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_light.html">CC3Light</a> *)&#160;</td>
          <td class="paramname"><em>aLight</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this node, or any descendant, has had a shadow volume added for the specified light. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a0723edbc79ce0b3518e11f35594ccd41">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="af601798fa0d66d6bdb962589d9773087"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) hide </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that sets the visible property to NO. </p>

</div>
</div>
<a class="anchor" id="a966505787ca1b75d7f2401b7677f25bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isAnimationEnabledOnTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the animation on the specified animation track is enabled. </p>
<p>The value returned by this method applies only to this node, not its child nodes. Child nodes that return YES to this method will be animated even if this node returns NO, and vice-versa.</p>
<p>The initial value of this property is YES. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a966505787ca1b75d7f2401b7677f25bb">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="afde494ed8885dc8873dfd104e1622394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isDescendantOf: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td>
          <td class="paramname"><em>aNode</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this node is the same object as the specified node, or is a structural descendant (child, grandchild, etc) of the specified node. </p>

</div>
</div>
<a class="anchor" id="a652b0691f722e172b87cd5a9c10647ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isShadowVisible </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this node is a shadow volume, returns whether the shadow cast by the shadow volume will be visible. </p>
<p>Returns NO if this node is not a shadow volume node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a652b0691f722e172b87cd5a9c10647ee">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a970a4514c1af06c66382cef4b4135376"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) linkToPODNodes: </td>
          <td></td>
          <td class="paramtype">(NSArray *)&#160;</td>
          <td class="paramname"><em>nodeArray</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create links to the nodes in the specified array. </p>
<p>This implementation attaches this node to its parent as identified by the podParentIndex property. Subclasses may override to perform other linking. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_08.html#a970a4514c1af06c66382cef4b4135376">CC3Node(PVRPOD)</a>.</p>

</div>
</div>
<a class="anchor" id="a1ac29283d3443c07a8e64bb4c87ec45f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) locationOfGlobalRayIntesection: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_ray.html">CC3Ray</a>)&#160;</td>
          <td class="paramname"><em>aRay</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the location at which the specified ray intersects the bounding volume of this node, or returns kCC3VectorNull if this node does not have a bounding volume, the shouldIgnoreRayIntersection property is set to YES, or the ray does not intersect the bounding volume. </p>
<p>The result honours the startLocation of the ray, and will return kCC3VectorNull if the bounding volume is "behind" the startLocation, even if the line projecting back through the startLocation in the negative direction of the ray intersects the bounding volume.</p>
<p>The ray may start inside the bounding volume of this node, in which case, the returned location represents the exit location of the ray.</p>
<p>The ray must be specified in global coordinates. The returned location is in the local coordinate system of this node. A valid non-null result can therefore be used to place another node at the intersection location, by simply adding it to this node at the returned location (eg- drag &amp; drop, bullet holes, etc).</p>
<p>The returned result can be tested for null using the CC3VectorIsNull function.</p>
<p>When using this method, keep in mind that the returned intersection location is located on the surface of the bounding volume, not on the surface of the node. Depending on the shape of the surface of the node, the returned location may visually appear to be at a different location than where you expect to see it on the surface of on the node. </p>

</div>
</div>
<a class="anchor" id="a994aee6e1428f7005f896611361a5d6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) markAnimationDirty </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the animation state of this node as dirty, indicating that the animated properties of this node should be updated on the next update cycle. </p>
<p>This method is invoked automatically if a animated property has been changed on any animation track as a result of the invocation of the establishAnimationFrameAt:onTrack: method. Normally, the application never needs to invoke this method. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a994aee6e1428f7005f896611361a5d6f">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a1086b8f97c7efeeaf49e7b3e842ebdd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) markBoundingVolumeDirty </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the shouldUseFixedBoundingVolume property is set to NO, this method marks the bounding volume of this node as dirty and in need of rebuilding. </p>
<p>If the shouldUseFixedBoundingVolume property is set to YES, this method does nothing.</p>
<p>If this node has an underlying mesh, and you have changed the vertex locations in the mesh directly, you can invoke this method to ensure that the bounding volume is rebuilt to encompass the new vertex locations.</p>
<p>The bounding volume is automatically transformed as the node is transformed, so this method does NOT need to be invoked when the node is transformed (moved, rotated, or scaled). </p>

</div>
</div>
<a class="anchor" id="abe610fe825b7adc7c427df840a521712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) markTransformDirty </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks that the globalTransformMatrix of this node is dirty and requires recalculation. </p>
<p>In a hierarchical structure of nodes, the transform of each node affects the transforms of all descendant nodes. Therefore, in addition to marking the transform of this node as dirty, this method also propagates to all descendant nodes, to also mark their transforms as dirty.</p>
<p>This design assumes that if the transform of this node has already been marked as dirty, that all descendant nodes also have already been marked as dirty. Therefore, as an optimization, if the globalTransformMatrix of this node is already dirty when this method is invoked, no action is taken to mark the transforms of any descendant nodes as dirty.</p>
<p>This method is invoked automatically as needed. Usually the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="ad6d70878798bce4171f1d4350c44d8a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) node </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased unnamed instance with an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="a047b778650783f9028e1c64921d5b459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) nodeAtIndex: </td>
          <td></td>
          <td class="paramtype">(GLint)&#160;</td>
          <td class="paramname"><em>aPODIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromPODResource:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_p_o_d_resource.html">CC3PODResource</a> *)&#160;</td>
          <td class="paramname"><em>aPODRez</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased instance from the data of this type at the specified index within the specified POD resource. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_08.html#a047b778650783f9028e1c64921d5b459">CC3Node(PVRPOD)</a>.</p>

</div>
</div>
<a class="anchor" id="a05df079c40cdd3d2bb7661b14afeb0d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a>) nodePODStructAtIndex: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>aPODIndex</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromPODResource:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_p_o_d_resource.html">CC3PODResource</a> *)&#160;</td>
          <td class="paramname"><em>aPODRez</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the underlying SPODNode data structure from the specified resource, for the SPODNode at the specified index. </p>
<p>The returned pointer must be cast to SPODNode before accessing any internals of the data structure. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_08.html#a05df079c40cdd3d2bb7661b14afeb0d9">CC3Node(PVRPOD)</a>.</p>

</div>
</div>
<a class="anchor" id="ac1e69c96f4b6508528e82398d372e4bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node_puncturing_visitor.html">CC3NodePuncturingVisitor</a>*) nodesIntersectedByGlobalRay: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_ray.html">CC3Ray</a>)&#160;</td>
          <td class="paramname"><em>aRay</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the descendant nodes that are intersected (punctured) by the specified ray. </p>
<p>This node is included in the test, and will be included in the returned nodes if it has a bounding volume that is punctured by the ray.</p>
<p>The results are returned as a <a class="el" href="interface_c_c3_node_puncturing_visitor.html" title="CC3NodePuncturingVisitor is a CC3NodeVisitor that is used to collect nodes that are punctured (inters...">CC3NodePuncturingVisitor</a> instance, which can be queried for the nodes that were punctured by the ray, and the locations of the punctures on the nodes. The returned visitor orders the nodes by distance between the startLocation of the ray and the global puncture location on each node.</p>
<p>The ray must be specified in global coordinates.</p>
<p>This implementation creates an instance of <a class="el" href="interface_c_c3_node_puncturing_visitor.html" title="CC3NodePuncturingVisitor is a CC3NodeVisitor that is used to collect nodes that are punctured (inters...">CC3NodePuncturingVisitor</a> on the specified ray, and invokes the visit: method on that visitor, passing this node as that starting point of the visitation.</p>
<p>The results will not include nodes that do not have a bounding volume, or whose shouldIgnoreRayIntersection property is set to YES.</p>
<p>This method also excludes invisible nodes and nodes where the ray starts inside the bounding volume of the node. To gain finer control over this behaviour, instead of using this method, create an instance of <a class="el" href="interface_c_c3_node_puncturing_visitor.html" title="CC3NodePuncturingVisitor is a CC3NodeVisitor that is used to collect nodes that are punctured (inters...">CC3NodePuncturingVisitor</a>, adjust its settings, and invoke the visit: method on the visitor, with this node as the arguement.</p>
<p>Also, to avoid creating a new visitor for each visit, you can create a single instance of <a class="el" href="interface_c_c3_node_puncturing_visitor.html" title="CC3NodePuncturingVisitor is a CC3NodeVisitor that is used to collect nodes that are punctured (inters...">CC3NodePuncturingVisitor</a>, cache it, and invoke the visit: method repeatedly, with or without changing the ray between invocations. </p>

</div>
</div>
<a class="anchor" id="aa64f643344ead97b9f4cf56082d70d6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) nodeWasDestroyed: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td>
          <td class="paramname"><em>aNode</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the specified node is the node in the target property of this node, the target property of this node is set to nil. </p>
<p>Subclasses may add additional behaviour, but should invoke this superclass implementation to ensure basic targetting behaviour is maintained. </p>

<p>Reimplemented from <a class="el" href="protocol_c_c3_node_listener_protocol-p.html#ac2a1e1b221fe0b5396eab8d5111b950c">&lt;CC3NodeListenerProtocol&gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ace3ff422c4cee814c5c3a9863f3f72a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) nodeWasTransformed: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td>
          <td class="paramname"><em>aNode</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nodes can be listeners of the transforms of other nodes. </p>
<p>If the specified node is the node in the target property of this node, and the shouldTrackTarget property of this node is YES, the targetLocation property of this node is set from the globalLocation property of the specified node.</p>
<p>Subclasses may add additional behaviour, but should invoke this superclass implementation to ensure basic targetting behaviour is maintained. </p>

<p>Reimplemented from <a class="el" href="protocol_c_c3_node_transform_listener_protocol-p.html#a9058744bfedc513d4f7254e08d4ee4ca">&lt;CC3NodeTransformListenerProtocol&gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aee98350cf8efb119effb2bb42537b420"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) nodeWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aName</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified name and an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="a13a146da2a8401c683cc5cdd3524a577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) nodeWithTag: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>aTag</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an unnamed autoreleased instance with the specified tag. </p>

</div>
</div>
<a class="anchor" id="ae7eec38a17f61714d1924669e556b530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) <a class="el" href="interface_c_c3_node.html#a13a146da2a8401c683cc5cdd3524a577">nodeWithTag:</a> </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>aTag</em></td>
        </tr>
        <tr>
          <td class="paramkey">withName:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified tag and name. </p>

</div>
</div>
<a class="anchor" id="a6a856eaeac4bb517a2b76c2124733ddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSInteger) numberOfRunningActions </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the numbers of actions that are running plus the ones that are scheduled to run (actions in actionsToAdd and actions arrays). </p>
<p>Composable actions are counted as 1 action. Example: If you are running 1 Sequence of 7 actions, it will return 1. If you are running 7 Sequences of 2 actions, it will return 7. </p>

</div>
</div>
<a class="anchor" id="a6e37f720209024c758ec4cd1a834c815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) pauseAllActions </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pauses all actions running on this node. </p>

</div>
</div>
<a class="anchor" id="a5e40a66f9647fc9a7ff01de3cc2645db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) prewarmForShadowVolumes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prewarms the meshes of all descendant mesh nodes to prepare for shadow volumes. </p>
<p>Shadow volumes make very heavy use of many mesh face characteristics. This method ensures that the faces have been populated for each descendant mesh node.</p>
<p>This method is invoked automatically when a shadow volume is added to a mesh node. Usually, the application should never need to invoke this method directly. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a5e40a66f9647fc9a7ff01de3cc2645db">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="aefaf0265e8b2f99e9ab38cef8694805c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) reattachBonesFrom: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td>
          <td class="paramname"><em>aNode</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After copying a skin mesh node, the newly created copy will still be influenced by the original skeleton. </p>
<p>The result is that both the original mesh and the copy will move and be deformed in tandem as the skeleton moves.</p>
<p>If you are creating a chorus line of dancing characters, this may be the effect you are after. However, if you are creating a squadron of similar, but independently moving characters, each skin mesh node copy should be controlled by a separate skeleton.</p>
<p>After creating a copy of the skeleton bone node assembly, you can use this method to attach the skin mesh node to the new skeleton. The node that is provided as the argument to this method is the root bone node of the skeleton, or a structural ancestor of the skeleton that does not also include the original skeleton as a descendant.</p>
<p>This method iterates through all the bones referenced by any descendant skin mesh nodes, and retrieves a bone with the same name from the structural descendants of the specified node.</p>
<p>When copying a <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a> instance, this method is automatically invoked as part of the copying of the soft-body object, and you do not need to invoke this method directly. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_skinning_08.html#aefaf0265e8b2f99e9ab38cef8694805c">CC3Node(Skinning)</a>.</p>

</div>
</div>
<a class="anchor" id="a12b9ca835a8707f654c348301144d5bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) releaseRedundantContent </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Once the vertex content has been buffered into a GL vertex buffer object (VBO) within the GL engine, via the createGLBuffer method, this method can be used to release the data in main memory that is now redundant from all meshes that have been buffered to the GL engine. </p>
<p>Invoking this method on a node will release from main memory any data within all descendant mesh nodes, that has successfully been copied to buffers in the GL engine. It is safe to invokde this method even if createGLBuffer has not been invoked, and even if VBO buffering was unsuccessful.</p>
<p>To exempt vertex content from release, invoke one or more of the following methods once on nodes for which data should be retained, before invoking this method:</p>
<ul>
<li>retainVertexContent</li>
<li>retainVertexLocations</li>
<li>retainVertexNormals</li>
<li>retainVertexTangents</li>
<li>retainVertexBitangents</li>
<li>retainVertexColors</li>
<li>retainVertexTextureCoordinates</li>
<li>retainVertexBoneWeights</li>
<li>retainVertexBoneIndices</li>
<li>retainVertexPointSizes</li>
<li>retainVertexIndices</li>
</ul>
<p>For example, sophisticated physics engines and collision detection algorithms may make use of vertex location data in main memory. Or a rippling texture animation might retain texture coordinate data in order to dyamically adjust the texture coordinate data.</p>
<p>Normally, you would invoke the retainVertex... methods on specific individual nodes, and then invoke this method on the parent node of a node assembly, or on the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>. </p>

</div>
</div>
<a class="anchor" id="ab638f5dbea673bc7b88dc311bf7ae470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) remove </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that removes this node from its structural hierarchy by simply invoking removeChild: on the parent of this node. </p>
<p>If the shouldStopActionsWhenRemoved property of this node is set to YES, any CCActions running on this node will be stopped and removed. If the shouldStopActionsWhenRemoved property of this node is set to NO, any CCActions running on that node will be paused, but not removed.</p>
<p>Stopping and removing CCActions is important because the actions running on a node retain links to the node. If the actions are simply paused, those links will be retained forever, potentially creating memory leaks of nodes that are invisibly retained by their actions.</p>
<p>By default, the shouldStopActionsWhenRemoved property is set to YES, and all CCActions running on this node will be stopped and removed. If the shouldStopActionsWhenRemoved is set to NO, it is up to you to clean up any running CCActions when you are done with this node. You can do this using either the stopAllActions or cleanupActions method.</p>
<p>During a node visitation run with a CCNodeVisitor, you should avoid using this method directly. The visitation process involves iterating through collections of child nodes, and removing a node during the iteration of a collection raises an error.</p>
<p>Instead, during a visitation run, you can use the requestRemovalOf: method on the visitor, which safely processes all removal requests once the full visitation run is complete. </p>

</div>
</div>
<a class="anchor" id="a0532b78d1036a404f8dd6d87b97d4e87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeAllChildren </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all child nodes of this node. </p>

</div>
</div>
<a class="anchor" id="abae4e44bd04d192def8a432fe0bb397e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeAllDirectionMarkers </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the direction marker child nodes that were previously added using the addDirectionMarkerColored:inDirection: and addDirectionMarker methods, from this node and all descendant nodes. </p>

</div>
</div>
<a class="anchor" id="a0301c693a7d708653ef5f216b4ff47ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeAllTransformListeners </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all transform listeners, that were previously added via the addTransformListener: method, from this node. </p>

</div>
</div>
<a class="anchor" id="affdd8450a201128f4034d63f2eb1dee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeAnimation: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_animation.html">CC3NodeAnimation</a> *)&#160;</td>
          <td class="paramname"><em>animation</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified animation from this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#affdd8450a201128f4034d63f2eb1dee4">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ab825fc724f9d83dac4876f077c50364e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeAnimationState: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_animation_state.html">CC3NodeAnimationState</a> *)&#160;</td>
          <td class="paramname"><em>animationState</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified animation state wrapper from this node. </p>
<p>Typically, to remove animation from a node, the application would use the removeAnimation: or removeAnimationTrack: methods, rather than this method. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ab825fc724f9d83dac4876f077c50364e">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a77ce0c5d88798d68ac35e306c93d4c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeAnimationTrack: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the animation on the specified animation track from this node and all descendant nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a77ce0c5d88798d68ac35e306c93d4c40">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="aba8f89a7edb29eb961336837f4cf3dd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeChild: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node.html">CC3Node</a> *)&#160;</td>
          <td class="paramname"><em>aNode</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified node as a direct child node to this node. </p>
<p>Does nothing if the specified node is not actually a child of this node.</p>
<p>If the shouldStopActionsWhenRemoved property of the node being removed is set to YES, any CCActions running on that node will be stopped and removed. If the shouldStopActionsWhenRemoved property of the node being removed is set to NO, any CCActions running on that node will be paused, but not removed.</p>
<p>Stopping and removing CCActions is important because the actions running on a node retain links to the node. If the actions are simply paused, those links will be retained forever, potentially creating memory leaks of nodes that are invisibly retained by their actions.</p>
<p>By default, the shouldStopActionsWhenRemoved property is set to YES, and all CCActions running on the node being removed will be stopped and removed. If the shouldStopActionsWhenRemoved is set to NO, it is up to you to clean up any running CCActions when you are done with the node. You can do this using either the stopAllActions or cleanupActions method.</p>
<p>If the shouldAutoremoveWhenEmpty property is YES, and the last child node is removed, this node will invoke its own remove method to remove itself from the node hierarchy as well. See the notes for the shouldAutoremoveWhenEmpty property for more info on autoremoving when all child nodes have been removed. </p>

</div>
</div>
<a class="anchor" id="a4b26864bdd4e165a33e9dc93b27e2ebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeShaders </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the shaders from each descendant mesh node, allowing new shaders to be selected for each mesh node, either directly by subsequently invoking the selectShaders method, or automatically the next time each mesh node is drawn. </p>
<p>Shader selection is driven by the characteristics of each mesh node and its material, including the number of textures, whether alpha testing is used, etc. If you change any of these characteristics that affect the shader selection, you can invoke the removeShaders method to cause different shaders to be selected for each mesh node, based on the new mesh node and material characteristics. You can also invoke the removeLocalShaders on a specific mesh node to cause only the shader program of that mesh node to be cleared.</p>
<p>This method is equivalent to setting the shaderProgram property to nil on each descendant mesh node. </p>

</div>
</div>
<a class="anchor" id="abdfe025f79b0e7ce367b5e2e43818aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeShadowVolumes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the shadow volume child nodes that were previously added using the addShadowVolumesForLight: and addShadowVolumes methods, from this node and all descendant nodes, by invoking the removeShadowVolumesForLight: method for each light in the scene. </p>
<p>It is safe to invoke this method more than once, or even if no shadow volumes have previously been added. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#abdfe025f79b0e7ce367b5e2e43818aa3">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a55d0af035ee74b21441ff1860a4094db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeShadowVolumesForLight: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_light.html">CC3Light</a> *)&#160;</td>
          <td class="paramname"><em>aLight</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the shadow volume child nodes that were previously added using the addShadowVolumesForLight: and addShadowVolumes methods for the specified light, from this node and all descendant nodes. </p>
<p>Removing shadow volumes from a node will NOT automatically set its shouldCacheFaces property to NO, and will not automatically free up vertex data that was retained to build the shadow volumes. If you no longer need the face or vertex data to be cached, you should explicitly set the shouldCacheFaces property to NO, and the shouldReleaseRedundantContent property to YES, and invoke the releaseRedundantContent method.</p>
<p>It is safe to invoke this method more than once, or even if no shadow volumes have previously been added. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a55d0af035ee74b21441ff1860a4094db">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a08506fd072f51e411bb330f4767a26d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeTransformListener: </td>
          <td></td>
          <td class="paramtype">(id&lt; <a class="el" href="protocol_c_c3_node_transform_listener_protocol-p.html">CC3NodeTransformListenerProtocol</a> &gt;)&#160;</td>
          <td class="paramname"><em>aListener</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified transform listener from the list of objects that have requested that they be notified whenever the transform of this node has changed. </p>
<p>It is safe to invoke this method with a listener that was not previously added, or with a nil listener. In either case, this method simply ignores the request. </p>

</div>
</div>
<a class="anchor" id="a49bbb4ec4f75df2db53169ccdd74011b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) resumeAllActions </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes all actions running on this node. </p>

</div>
</div>
<a class="anchor" id="a04bccb6952665f28e3f7852acbfb2f68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexBitangents </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bitangent content of this node and all descendant nodes to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex content after the data has been buffered to a GL VBO.</p>
<p>Only the vertex normals will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="aacad82a5d895bb394f28a1a63943450e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexBoneIndices </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bone index content of this node and all descendant nodes to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex bone index will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a93574c731d7af8c6cee90cdac1a3951b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexBoneWeights </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex bone weight content of this node and all descendant nodes to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex bone weight will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="aae6580702191d386d7495c6801a016ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexColors </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex color content of this node and all descendant nodes to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex content after the data has been buffered to a GL VBO.</p>
<p>Only the vertex colors will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a82d4afc9b9fff75fe8bf65ad14496b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexContent </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause all vertex content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>All vertex content, such as location, normal, color, texture coordinates, point size, weights and matrix indices will be retained.</p>
<p>This method does NOT cause vertex index data to be retained. To retain vertex index data, use the retainVertexIndices method as well. </p>

</div>
</div>
<a class="anchor" id="af476409b656940fe8fd6e348b5b8b2be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexIndices </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex index content of this node and all descendant nodes to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex content after the data has been buffered to a GL VBO.</p>
<p>Only the vertex indices will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a99cdb8a721320e3b4aa237389eeb117a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexLocations </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex location content of this node and all descendant nodes to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex content after the data has been buffered to a GL VBO.</p>
<p>Only the vertex locations will be retained. Any other vertex content, such as normals, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a41dc7d2c118673a0690be00d450094ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexNormals </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex normal content of this node and all descendant nodes to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex content after the data has been buffered to a GL VBO.</p>
<p>Only the vertex normals will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a1cae4ff654855d167acbdf21ad9ea487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexPointSizes </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex point size content to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex point sizes will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

<p>Implemented in <a class="el" href="interface_c_c3_point_particle_emitter.html#abb9ec8bbdc7a40985565bb1dadb201a7">CC3PointParticleEmitter</a>.</p>

</div>
</div>
<a class="anchor" id="a328df8f0c825def35671b0aa343edbc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexTangents </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex tangent content of this node and all descendant nodes to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex content after the data has been buffered to a GL VBO.</p>
<p>Only the vertex normals will be retained. Any other vertex content, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="a3f757942e44ce601a9d72eedca5a1f2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) retainVertexTextureCoordinates </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method to cause the vertex texture coordinate content of this node and all descendant nodes, for all texture units, used by this mesh to be retained in application memory when releaseRedundantContent is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex content after the data has been buffered to a GL VBO.</p>
<p>Only the vertex texture coordinates will be retained. Any other vertex content, such as locations, or normals, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantContent is invoked. </p>

</div>
</div>
<a class="anchor" id="ae31dc98fcd8cf5cfe08414ffd1d221e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) rotateBy: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>aRotation</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates this node from its current rotational state by the specified Euler angles in degrees. </p>
<p>The incoming Euler angles specify the amount of change in rotation, not the final rotational state. </p>

</div>
</div>
<a class="anchor" id="ae84672c16d621066005bf26916e2103e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) rotateByAngle: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>angle</em></td>
        </tr>
        <tr>
          <td class="paramkey">aroundAxis:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates this node from its current rotational state by rotating around the specified axis by the specified angle in degrees. </p>
<p>The incoming axis and angle specify the amount of change in rotation, not the final rotational state.</p>
<p>Thanks to Cocos3D user nt901 for contributing to the development of this feature </p>

</div>
</div>
<a class="anchor" id="afc504304b527c0475ead41b8ea8fa00c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) rotateByAngle: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>angle</em></td>
        </tr>
        <tr>
          <td class="paramkey">aroundAxis:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>axis</em></td>
        </tr>
        <tr>
          <td class="paramkey">atLocation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>pivotLocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates this node from its current rotational state by rotating around the specified axis by the specified angle in degrees, using the specified location as the rotational pivot point. </p>
<p>The location is specified in the local coordinate system of this node. The incoming axis and angle specify the amount of change in rotation, not the final rotational state. </p>

</div>
</div>
<a class="anchor" id="aaa60c56626c0ca8bd7d94af4aeaf8bed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) rotateByQuaternion: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector4.html">CC3Quaternion</a>)&#160;</td>
          <td class="paramname"><em>aQuaternion</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates this node from its current rotational state by the specified quaternion. </p>
<p>The incoming quaternion specifies the amount of change in rotation, not the final rotational state. </p>

</div>
</div>
<a class="anchor" id="a88bc1389a0a31d1684f197ed50e24677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (CCAction*) runAction: </td>
          <td></td>
          <td class="paramtype">(CCAction *)&#160;</td>
          <td class="paramname"><em>action</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the specified action, and returns that action. </p>
<p>This node becomes the action's target. </p>

</div>
</div>
<a class="anchor" id="a52947dbc390c443e3fec75c2ec139875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (CCAction*) <a class="el" href="interface_c_c3_node.html#a88bc1389a0a31d1684f197ed50e24677">runAction:</a> </td>
          <td></td>
          <td class="paramtype">(CCAction *)&#160;</td>
          <td class="paramname"><em>action</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTag:</td>
          <td></td>
          <td class="paramtype">(NSInteger)&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops any existing action on this node that had previously been assigned the specified tag, assigns the tag to the specified new action, starts that new action, returns it. </p>
<p>This node becomes the action's target.</p>
<p>This method is useful for replacing one action of a particular type with another, without affecting any other actions that might be executing on the same node. For instance, a node might be both moving and fading-in concurrently. If the movement is altered by a user interaction, it might be desirable to stop the movement action and replace it, without affecting the fade action.</p>
<p>Using this method to assign a tag to the movement action when running it allows that movement action to be stopped and replaced with a new movement action, through a second invocation of this method with the same tag, without affecting the fade action.</p>
<p>When using this method, you can use the CC3ActionTag enumeration as a convenience for consistently assigning tags by action type. </p>

</div>
</div>
<a class="anchor" id="a204e8eded1fcebad408b1a11dfdecdc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) selectShaders </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects an appropriate shaders for each descendant mesh node. </p>
<p>When running under a programmable rendering pipeline, such as OpenGL ES 2.0 or OpenGL, all mesh nodes require a shaders to be assigned. This can be done directly using the shaderProgram property. Or shaders can be selected automatically based on the characteristics of the mesh node.</p>
<p>You can use this method to cause a shaders to be automatically selected for each descendant mesh node that does not already have shaders assigned. You can assign shader programs to some specific mesh nodes, and then invoke this method on the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> to have shaders assigned to the remaining mesh nodes.</p>
<p>Since all mesh nodes require shaders, if this method is not invoked, and a shader program was not manually assigned via the shaderProgram property, a shaders will be automatically assigned to each mesh node the first time it is rendered. The automatic selection is the same, whether this method is invoked, or the selection is made lazily. However, if the shaders must be loaded and compiled, there can be a noticable pause in drawing a mesh node for the first time if lazy assignment is used.</p>
<p>Shader selection is driven by the characteristics of each mesh node and its material, including the number of textures, whether alpha testing is used, etc. If you change any of these characteristics that affect the shader selection, you can invoke the removeShaders method to cause different shaders to be selected for each mesh node, based on the new mesh node and material characteristics. You can also invoke the removeLocalShaders on a specific mesh node to cause only the shader program of that mesh node to be cleared.</p>
<p>Shader selection is handled by an implementation of the <a class="el" href="protocol_c_c3_shader_matcher-p.html" title="CC3ShaderMatcher describes the behaviour required to match nodes and materials to an appropriate GL p...">CC3ShaderMatcher</a> held in the <a class="el" href="interface_c_c3_shader_program.html" title="CC3ShaderProgram represents an OpenGL shader program, containing one vertex shader and one fragment s...">CC3ShaderProgram</a> shaderMatcher class-side property. The application can therefore customize shader program selection by establishing a custom instance in the <a class="el" href="interface_c_c3_shader_program.html" title="CC3ShaderProgram represents an OpenGL shader program, containing one vertex shader and one fragment s...">CC3ShaderProgram</a> shaderMatcher class-side property </p>

</div>
</div>
<a class="anchor" id="aa083e04f6344b05eea661820086eeed7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setAnimationBlendingWeight: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>blendWeight</em></td>
        </tr>
        <tr>
          <td class="paramkey">onTrack:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>trackID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the animation blending weight for the animation on the specified track, and sets the same weight into all descendants. </p>
<p>When multiple animation tracks are active, the blending weight of a track determines the relative influence the animation track has on the properties of this node. Animation tracks with larger weights relative to the other tracks will have a proportionally larger influence on the transform properties of the node. An animation track with a blending weight of zero will have no influence on the properties of the node.</p>
<p>The absolute value of the weights does not matter, nor do the weights across all animation tracks have to add up to unity. Therefore, a blending weight of 0.2 on one track and a blending weight of 0.1 on a second track will have exactly the same affect as a weight of 1.2 on the first track and a weight of 0.6 on the second track. In both cases, the first animation track will have twice the influence as the second animation track.</p>
<p>When only one animation track is active, the blending weight has no effect unless it is zero. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#aa083e04f6344b05eea661820086eeed7">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="acca0220c5456f6a204665cadff58a780"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) setDefaultScaleTolerance: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000150">Deprecated:</a></b></dt><dd>This property is no longer needed, since the rigidity of a node transform is now tracked by the globalTransformMatrix itself. Setting this property will have no effect. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d4305b124b27d89d50b859f9ebff784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) setDescriptorFontSize: </td>
          <td></td>
          <td class="paramtype">(CGFloat)&#160;</td>
          <td class="paramname"><em>fontSize</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the font size that will be used when drawing the descriptor text when the shouldDrawDescriptor property is set to YES on any node. </p>
<p>The initial value of this class-side property is 14.0. </p>

</div>
</div>
<a class="anchor" id="a4ba164580d0895194fbf3a5b859ecb60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) setDirectionMarkerColor: </td>
          <td></td>
          <td class="paramtype">(ccColor4F)&#160;</td>
          <td class="paramname"><em>aColor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color that direction marker lines will be drawn in when created using the addDirectionMarker method. </p>
<p>Changing this property will affect the color of any new direction marker lines created. It does not affect any existing direction marker lines.</p>
<p>Setting this property to kCCC4FBlackTransparent will cause the color of any new direction marker lines to be set to the value of the color property of the node instead.</p>
<p>The initial value of this class property is kCCC4FRed. </p>

</div>
</div>
<a class="anchor" id="a8b87b6c17ec84530d378fa2d0a2d74d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setSkeletalBoundingVolume: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_bounding_volume.html">CC3NodeBoundingVolume</a> *)&#160;</td>
          <td class="paramname"><em>boundingVolume</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mesh nodes whose vertices are deformable by bones are not automatically assigned a bounding volume, because the vertices are not completely under control of the mesh node, complicating the definition of the boundary. </p>
<p>Creating bounding volumes for skinned mesh nodes is left to the application.</p>
<p>If the bones are animated independently from the mesh node, it is possible that the bones will move the entire mesh far away from the mesh node. In this situation, it is better to have the bounding volume controlled by one of the root bones of the model, but still allow the skinned mesh nodes use this bounding volume to determine if the vertices are within the camera's field of view.</p>
<p>To do this, manually create a bounding volume of the right size and shape for the movement of the vertices from the perspective of a root bone of the skeleton. Assign the bounding volume to the root bone by using the boundingVolume property, and once it has been assigned to the skeleton, use this method on an ancestor node of all of the skinned mesh nodes that are to use that bounding volume, to assign that bounding volume to all of the appropriate skinned mesh nodes. A good choice to target for the invocation of this method might be the <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a> of the model, or even the <a class="el" href="interface_c_c3_resource_node.html" title="A CC3ResourceNode is a CC3Node that that can be populated from a CC3NodesResource, and forms the root of the node structural assembly loaded from a resource file. ">CC3ResourceNode</a> above it, if loaded from a file.</p>
<p>During development, you can use the shouldDrawBoundingVolume property to make the bounding volume visible, to aid in determining and setting the right size and shape for it. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_skinning_08.html#a8b87b6c17ec84530d378fa2d0a2d74d0">CC3Node(Skinning)</a>.</p>

</div>
</div>
<a class="anchor" id="ae69fcaf11981b068bcdc8963639c7317"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) setWireframeBoxColor: </td>
          <td></td>
          <td class="paramtype">(ccColor4F)&#160;</td>
          <td class="paramname"><em>aColor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the color that wireframes will be drawn in when created using the shouldDrawWireframeBox property. </p>
<p>Changing this property will affect the color of any new wireframe bounding boxes created. It does not affect any instances that already have a wireframe bounding box established.</p>
<p>Setting this property to kCCC4FBlackTransparent will cause the color of any new wireframe bounding boxes to be set to the value of the color property of the node instead.</p>
<p>The initial value of this class property is kCCC4FYellow. </p>

</div>
</div>
<a class="anchor" id="a4d93096313f1fdb93e268bcc391910d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) show </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method that sets the visible property to YES. </p>

</div>
</div>
<a class="anchor" id="a5491e5b27a1c2c241cbc0389a1c25ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) stopAction: </td>
          <td></td>
          <td class="paramtype">(CCAction *)&#160;</td>
          <td class="paramname"><em>action</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops and removes the specified action on this node. </p>

</div>
</div>
<a class="anchor" id="a7d1734b48ce0028d269e7b3c83fdb404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) stopActionByTag: </td>
          <td></td>
          <td class="paramtype">(NSInteger)&#160;</td>
          <td class="paramname"><em>tag</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops and removes the action with the specified tag from this node. </p>

</div>
</div>
<a class="anchor" id="a6b01f39758bd6f3f8e906b7a2fb0e6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) stopAllActions </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops and removes all actions on this node. </p>

</div>
</div>
<a class="anchor" id="ab82ef9ad2019facf5e9abce84ab60407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) touchDisableAll </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the touchEnabled property to NO on this node and all descendant nodes. </p>
<p>This is a convenience method that will make this node and all its decendants unresponsive to touches. For more info see the notes for the touchEnabled and touchableNode properties. </p>

</div>
</div>
<a class="anchor" id="aa67c8b5f44c53322c4eebc9f5254cf61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) touchEnableAll </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the touchEnabled property to YES on this node and all descendant nodes. </p>
<p>This is a convenience method that will make all descendants individually touchable and selectable, which is not usually what is wanted. Usually, you would set touchEnabled on specific parent nodes that are of interest to select a sub-assembly as a whole. However, making all components individually selectable can sometimes be desired, and is useful for testing.</p>
<p>For more info see the notes for the touchEnabled and touchableNode properties.</p>
<p>This is a convenience method that can find use in testing, where it might be of interest to be able to individually select small components of a larger assembly. </p>

</div>
</div>
<a class="anchor" id="a0eedf769aba75fa6b0d51a5e330bcb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) trackTargetWithVisitor: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000162">Deprecated:</a></b></dt><dd>No longer needed. Does nothing. </dd></dl>

</div>
</div>
<a class="anchor" id="a422d97fc205cb37b3386424a19d7fa83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) transformAndDrawWithVisitor: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template method that applies this node's transform matrix to the GL matrix stack and draws this node using the specified visitor. </p>
<p>This method is invoked by the drawing visitor when it visits the node, if all of the following conditions are met by this node:</p>
<ul>
<li>ths node is visible (as indicated by the visible property)</li>
<li>has content to draw (as indicated by the hasLocalContent property)</li>
<li>intersects the camera's frustum (which is checked by invoking the method doesIntersectFrustum: of this node with the frustum from the visitor).</li>
</ul>
<p>If all of these tests pass, drawing is required, and this method transforms and draws the local content of this node.</p>
<p>This method is automatically invoked from the visitor. The application should never have need to used this method. </p>

</div>
</div>
<a class="anchor" id="ac184ae5d67268b69539f89d90ac04676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) translateBy: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>)&#160;</td>
          <td class="paramname"><em>aVector</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates the location of this node by the specified vector. </p>
<p>The incoming vector specify the amount of change in location, not the final location. </p>

</div>
</div>
<a class="anchor" id="a3c74947cca4fdd39d89ea8cdf6e48dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateAfterTransform: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_updating_visitor.html">CC3NodeUpdatingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template method is invoked periodically whenever the 3D nodes are to be updated. </p>
<p>This method provides this node with an opportunity to perform update activities after the globalTransformMatrix of the node has been recalculated. The similar and complimentary method updateBeforeTransform: is automatically invoked before the globalTransformMatrix has been recalculated.</p>
<p>The global transform properties of a node (globalLocation, globalRotation, globalScale) will have accurate values when this method is run, since they are only valid after the globalTransformMatrix has been updated. If you need to make use of the global properties of a node (such as for collision detection), override this method.</p>
<p>Since the globalTransformMatrix has already been updated when this method is invoked, if you override this method and make any changes to the transform properties (location, rotation, scale) of any node, you should invoke the updateTransformMatrices method of that node, to have its globalTransformMatrix, and those of its child nodes, recalculated.</p>
<p>This abstract template implementation does nothing. Subclasses that need access to their global transform properties will override accordingly. Subclasses that override do not need to invoke this superclass implementation. Nor do subclasses need to invoke this method on their child nodes. That is performed automatically.</p>
<p>The specified visitor encapsulates the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance, to allow this node to interact with other nodes in the scene.</p>
<p>The visitor also encapsulates the deltaTime, which is the interval, in seconds, since the previous update. This value can be used to create realistic real-time motion that is independent of specific frame or update rates. Depending on the setting of the maxUpdateInterval property of the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance, the value of dt may be clamped to an upper limit before being passed to this method. See the description of the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> maxUpdateInterval property for more information about clamping the update interval.</p>
<p>If you wish to remove this node during an update visitation, avoid invoking the remove method on the node from this method. The visitation process involves iterating through collections of child nodes, and removing a node during the iteration of a collection raises an error. Instead, you can use the requestRemovalOf: method on the visitor, which safely processes all removal requests once the full visitation run is complete.</p>
<p>As described in the class documentation, in keeping with best practices, updating the model state should be kept separate from frame rendering. Therefore, when overriding this method in a subclass, do not perform any drawing or rending operations. This method should perform model updates only.</p>
<p>This method is invoked automatically at each scheduled update. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="ab33607fc5db4c079ebfb42d9da5acbea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateBeforeTransform: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_updating_visitor.html">CC3NodeUpdatingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template method is invoked periodically whenever the 3D nodes are to be updated. </p>
<p>This method provides this node with an opportunity to perform update activities before any changes are applied to the globalTransformMatrix of the node. The similar and complimentary method updateAfterTransform: is automatically invoked after the globalTransformMatrix has been recalculated. If you need to make changes to the transform properties (location, rotation, scale) of the node, or any child nodes, you should override this method to perform those changes.</p>
<p>The global transform properties of a node (globalLocation, globalRotation, globalScale) will not have accurate values when this method is run, since they are only valid after the globalTransformMatrix has been updated. If you need to make use of the global properties of a node (such as for collision detection), override the udpateAfterTransform: method instead, and access those properties there.</p>
<p>This abstract template implementation does nothing. Subclasses that act predictively, such as those undergoing trajectories or IPO curves can update their properties accordingly. Subclasses that override do not need to invoke this superclass implementation. Nor do subclasses need to invoke this method on their child nodes. That is performed automatically.</p>
<p>The specified visitor encapsulates the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance, to allow this node to interact with other nodes in the scene.</p>
<p>The visitor also encapsulates the deltaTime, which is the interval, in seconds, since the previous update. This value can be used to create realistic real-time motion that is independent of specific frame or update rates. Depending on the setting of the maxUpdateInterval property of the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance, the value of dt may be clamped to an upper limit before being passed to this method. See the description of the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> maxUpdateInterval property for more information about clamping the update interval.</p>
<p>If you wish to remove this node during an update visitation, avoid invoking the remove method on the node from this method. The visitation process involves iterating through collections of child nodes, and removing a node during the iteration of a collection raises an error. Instead, you can use the requestRemovalOf: method on the visitor, which safely processes all removal requests once the full visitation run is complete.</p>
<p>As described in the class documentation, in keeping with best practices, updating the model state should be kept separate from frame rendering. Therefore, when overriding this method in a subclass, do not perform any drawing or rending operations. This method should perform model updates only.</p>
<p>This method is invoked automatically at each scheduled update. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a6bd1682dc37bdbbd15763203bb897dfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) wasAdded </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template method that is invoked automatically when this node is added to its parent node. </p>
<p>This method is invoked automatically after the node has been added to its parent (and to the scene if the parent is already in the scene). You can override this method to implement any node initialization that might depend on knowing the parent of this node.</p>
<p>You can also override the setParent: method to perform simple initialization to this node that depends on the parent (eg- setting the name of this node based on the parent's name).</p>
<p>However, if you need to make any structural changes, such as adding children to this node once it is added to its parent, you must do so in this wasAdded method instead.</p>
<p>The wasAdded method is inherently safer than the setParent: method because the wasAdded method is invoked after this node has been fully established in the parent ancestor hierarchy, whereas the setParent: method is invoked part-way through establishing that structural relationship.</p>
<p>This implementation does nothing. Subclasses can override. </p>

</div>
</div>
<a class="anchor" id="ae728eca9485726ddd19641aa6750fc07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) wasRemoved </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template method that is invoked automatically when this node is removed from its parent node. </p>
<p>This implementation sets the isRunning property to NO. It also checks the value of the shouldStopActionsWhenRemoved property and, if it is set to YES, stops and removes any CCActions running on this node and its descendants. </p>

</div>
</div>
<a class="anchor" id="a95bebe8af43ea7f80e5a6d8c1a333c09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (ccColor4F) wireframeBoxColor </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the color that wireframe bounding boxes will be drawn in when created using the shouldDrawWireframeBox property. </p>
<p>Setting this property to kCCC4FBlackTransparent will cause the color of any new wireframe bounding boxes to be set to the value of the color property of the node instead.</p>
<p>The initial value of this class property is kCCC4FYellow. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a9978b3e942066d848862f0ddf1c2879f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> sceneUpDirection) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000146">Deprecated:</a></b></dt><dd>Renamed to referenceUpDirection. </dd></dl>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_08.html#a05f216c78fa543cd5a8885fbe3bdb0d3">CC3Node(PVRPOD)</a>.</p>

</div>
</div>
<a class="anchor" id="a5810dbc871619ae3a25f16b9d87764b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> worldUpDirection) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000147">Deprecated:</a></b></dt><dd>Renamed to referenceUpDirection. </dd></dl>

</div>
</div>
<a class="anchor" id="a768cba72501db26953306ee19d69aa4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat scaleTolerance) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000148">Deprecated:</a></b></dt><dd>This property is no longer needed, since the rigidity of a node transform is now tracked by the globalTransformMatrix itself. This property will always return zero. Setting this property will have no effect. </dd></dl>

</div>
</div>
<a class="anchor" id="a32c2203c5f79689baeafb6511fd7556a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="_c_c3_rotator_8h.html#afc5673e97432b6a4bee46ca01f979303">CC3TargettingConstraint</a> axisRestriction) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000151">Deprecated:</a></b></dt><dd>Renamed to targettingConstraint. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ee95ecb668094da8e79cfaaca03e256"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> globalLightLocation) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000152">Deprecated:</a></b></dt><dd>Use globalLightPosition instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e83ffc0f937a602d17ed5d1fac53393"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a>* transformMatrix) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000164">Deprecated:</a></b></dt><dd>Renamed to globalTransformMatrix.</dd></dl>
<p>This property will be redefined in a future release of Cocos3D, and will result in incorrect behaviour in any legacy code that depends on the older functionality provided by this property. Convert your code now. </p>

</div>
</div>
<a class="anchor" id="a042b4d5c3f960c41590decd1fc896ed2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a>* transformMatrixInverted) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000165">Deprecated:</a></b></dt><dd>Renamed to globalTransformMatrixInverted.</dd></dl>
<p>This property will be redefined in a future release of Cocos3D, and will result in incorrect behaviour in any legacy code that depends on the older functionality provided by this property. Convert your code now. </p>

</div>
</div>
<a class="anchor" id="abacdbd6410fda6a2f98b0a2b19ffbd6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>* dirtiestAncestor) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000168">Deprecated:</a></b></dt><dd>No longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f823d6ebfe25a2b4cbdcedb8ec7d20e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a>* parentGlobalTransformMatrix) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000169">Deprecated:</a></b></dt><dd>No longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad78489c6ba37567f1ca624293294b7a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a>* parentTransformMatrix) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000170">Deprecated:</a></b></dt><dd>Renamed to parentGlobalTransformMatrix. No longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a908cd90a975e20fb20010ffe5c79ee23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_scene.html">CC3Scene</a>* world) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000173">Deprecated:</a></b></dt><dd>Renamed to scene. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4cf3478f3671dedb41a4a60ca8976a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL shouldCleanupActionsWhenRemoved) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000174">Deprecated:</a></b></dt><dd>Renamed to shouldStopActionsWhenRemoved. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f8fac8bdff2bdd92a6df79f8afb48b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL shouldCleanupWhenRemoved) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000175">Deprecated:</a></b></dt><dd>Renamed to shouldStopActionsWhenRemoved. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c93e6c1c60cf0757df9bd33cdc09fbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_camera.html">CC3Camera</a>*) activeCamera</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this node has been added to the 3D scene, either directly, or as part of a node assembly, returns the activeCamera property of the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance, as accessed via the scene property, otherwise returns nil. </p>
<p>Reading this property traverses up the node hierarchy. If this property is accessed frequently, it is recommended that it be cached. </p>

</div>
</div>
<a class="anchor" id="a87fc1dcd7533a6d9f29564116ab7d3fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (ccColor4F) ambientColor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The ambient color of the materials of this node. </p>
<p>Setting this property sets the same property on all child nodes.</p>
<p>Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

</div>
</div>
<a class="anchor" id="a5373d56dc052aecd0f81ba4107982b7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node_animation.html">CC3NodeAnimation</a>*) animation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The animation content of animation track zero of this node. </p>
<p>Setting this property is the same as invoking addAnimation:asTrack: and specifying track zero. Querying this property is the same as invoking getAnimationOnTrack: and specifying track zero.</p>
<p>To animate this node, set this property to an instance of a subclass of the abstract <a class="el" href="interface_c_c3_node_animation.html" title="A CC3NodeAnimation manages the animation of a node. ">CC3NodeAnimation</a> class, populated with animation content, and then create an instance of a <a class="el" href="interface_c_c3_action_animate.html" title="CC3ActionAnimate animates a single track of animation on a CC3Node and its descendants. ">CC3ActionAnimate</a> action, and run it on this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a5373d56dc052aecd0f81ba4107982b7c">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a6a691668927439a11ce912193faf2d46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node_animation_state.html">CC3NodeAnimationState</a>*) animationState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The animation state wrapper for animation track zero. </p>
<p>This is a convenience property for accessing the animation when only a single animation track is used.</p>
<p>This wrapper is created automatically when the animation property is set. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a6a691668927439a11ce912193faf2d46">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="af98fb62a333ea1cc0fdbe4d401c0e2aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (ccBlendFunc) blendFunc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the <a class="el" href="class_c_c_blend_protocol-p.html">CCBlendProtocol</a> blendFunc property. </p>
<p>This is a convenience property that gets and sets the same property of the material of all descendant nodes</p>
<p>Querying this property returns the value of the same property from the first descendant node that supports materials, or {GL_ONE, GL_ZERO} if no descendant nodes support materials. Setting this property sets the same property on the materials in all descendant nodes.</p>
<p>Before setting this property, for this property to have affect on descendant mesh nodes, you must assign a material to each of those nodes using its material property, or assign a texture to those mesh nodes using the texture property, which will automatically create a material to hold the texture. </p>

</div>
</div>
<a class="anchor" id="a707ebf00f2c8d22fc99b53cd9503678c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_box.html">CC3Box</a>) boundingBox</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest axis-aligned bounding box that surrounds any local content of this node, plus all descendants of this node. </p>
<p>The returned bounding box is specified in the local coordinate system of this node.</p>
<p>Returns kCC3BoxNull if this node has no local content or descendants.</p>
<p>The computational cost of reading this property depends on whether the node has children. For a node without children, this property can be read quickly from the cached bounding box of any local content of the node (for example, the mesh in a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>).</p>
<p>However, for nodes that contain children (and possibly other descendants), since the bounding box of a node can change based on the locations, rotations, or scales of any descendant node, this property must measured dynamically on each access, by traversing all descendant nodes. This is a computationally expensive method. </p>

</div>
</div>
<a class="anchor" id="a68af664d6e99946dad0a3d90462ea744"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node_bounding_volume.html">CC3NodeBoundingVolume</a>*) boundingVolume</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The bounding volume of this node. </p>
<p>This is used by culling during drawing operations, it can be used by the application to detect when two nodes intersect in space (collision detection), and it can be used to determine whether a node intersects a specific location, ray, or plane.</p>
<p>Different shapes of boundaries are available, permitting tradeoffs between accuracy and computational processing time.</p>
<p>By default, nodes do not have a bounding volume. You can add a bounding volume by setting this property directly, you can invoke the createBoundingVolume method to have a bounding volume created automatically, or you can invoke the createBoundingVolumes method to have a bounding volume created for each descendant node that requires one.</p>
<p>In most cases, each node has its own bounding volume. However, when using bounding volumes with skin mesh nodes whose vertices are influenced by separate bone nodes, it sometimes makes sense to share the bounding volume between one of the primary skeleton bones and the skin mesh node, so that the bone can control the movement and shape of the bounding volume, and the skin node can use that same bounding volume to determine whether its vertices are intersecting another bounding volume, including the camera frustum.</p>
<p>You employ this technique by assigning the bounding volume to the bone first, making it the primary node for the bounding volume, and then assigning the same bounding volume to the skin node (or maybe even more than one skin node), to allow the bounding volume to determine the camera visibility of the skin node, and to detect collisions for the skin node.</p>
<p>You can make the bounding volume of any node visible by setting the shouldDrawBoundingVolume property to YES. You can use the shouldDrawAllBoundingVolumes property to make the bounding volumes of this node and all its descendants visible by setting the shouldDrawAllBoundingVolumes property to YES. This can be quite helpful during development time to help determine the size and shape of a manually-assigned bounding volume, such as those assigned to skinned mesh nodes as described above. </p>

</div>
</div>
<a class="anchor" id="a7733dc8471757b6109d86e7fb688cbf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) boundingVolumePadding</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Padding that is added to all edges of the bounding volume, when the bounding volume or the boundingBox property is determined. </p>
<p>You can use this to establish a "buffer zone" around the node when creating bounding volumes or when working with the boundingBox of this node.</p>
<p>The initial value of this property is zero. </p>

</div>
</div>
<a class="anchor" id="a73616444ed3fc114a8ad59e6be9babee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) cameraDistanceProduct</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A measure of the distance from the camera to the global center of geometry of the node. </p>
<p>This is used to test the Z-order of this node to determine rendering order.</p>
<p>For nodes whose rendering order depends on distance to the camera (eg- translucent nodes), this property is set automatically when the nodes are sequenced for drawing. The application will generally make no use of this property directly.</p>
<p>Do not use the value of this property as the true distance from the node to the camera. This measure is not the actual distance from the camera to the node, but it is related to that distance, and increases monotonically as the distance to the camera increases.</p>
<p>Different node sequencers may measure distance differently. If the node sequencer uses the true distance from the camera to the node, this property will be set to the square of that distance to avoid making the computationally expensive and unnecessary square-root calculation. If the node sequencer compares distance in one direction only, such as only in the forwardDirection of the camera, or only the Z-axis component of the distance, the value will be somewhat different than the square of the distance. </p>

</div>
</div>
<a class="anchor" id="ac165afbc71dec4bbcd1cfae54c52ffe8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) centerOfGeometry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the center of geometry of this node, including any local content of this node, plus all descendants of this node. </p>
<p>The returned location is specfied in the local coordinate system of this node.</p>
<p>If this node has no local content or descendants, returns a zero vector.</p>
<p>This property is calculated from the value of the boundingBox property. The computational cost of reading that property depends on whether this node has children. See the notes for that property for more info. </p>

</div>
</div>
<a class="anchor" id="a710e83cae07a116b0f068a57f78a245b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray*) children</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The child nodes of this node, in a node structural hierarchy. </p>
<p>This property will be nil if this node has no child nodes.</p>
<p>To change the contents of this array, use the addChild: and removeChild: methods of this class. Do not manipulate the contents of this array directly. </p>

</div>
</div>
<a class="anchor" id="ad829a1f147dd9be0b2f6289385682de5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="_c_c3_c_c2_extensions_8h.html#a9ee2c61886665ba64b5de7be1a1bf83d">CCColorRef</a>) color</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The average color of this node. </p>
<p>Setting this property sets the same property on all child nodes.</p>
<p>Before setting this property, for this property to have affect on descendant mesh nodes, you must assign a material to each of those nodes using its material property, or assign a texture to those mesh nodes using the texture property, which will automatically create a material to hold the texture.</p>
<p>Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

</div>
</div>
<a class="anchor" id="a6daa5b2b6ffe4a8e369551e8342c1359"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) containsAnimation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this node, or any of its descendants, contains animation on any tracks. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#a6daa5b2b6ffe4a8e369551e8342c1359">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="ab1b6459ed926cf832f3c3c736da55f9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) decalOffsetFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An offset factor used by the GL engine when comparing the Z-distance of the content of this node against previously drawn content. </p>
<p>This can be used to correct for Z-fighting between overlapping, and nearly co-planar, faces of two objects that overlap.</p>
<p>The definitive example is when you wish to apply a decal object on top of another, such as bullet-holes on a wall, or a real label on a box. Since the decal is co-planar with the surface it is attached to, it is easy for rounding errors to cause some of the pixels of the decal to be considered on top of the background, and others to be considered behind the background, resulting in only a partial display of the decal content. This is known as Z-fighting.</p>
<p>A face whose orientation is at an angle to the camera, particularly those who are oriented almost edge-on to the camera, might have a significant change in depth across its visible span. Depending on which parts of the face are used to determine each pixel depth, the difference in the depth value might be significant.</p>
<p>By assigning a value to this property, the depth of each pixel will be offset by the overall change in depth across the face being drawn, multiplied by the value of this property. When comparing the depth of content to be drawn against content that has already been drawn, a positive value for this property will effectively move that content away from the camera, and a negative value will effectively move that content towards the camera, relative to the content that has already been drawn.</p>
<p>A value of -1.0 will cause the depth of content to be drawn to be offset by the overall change in depth across the face, effectively pulling the face toward the camera by an amount equal to the span of its depth.</p>
<p>The depth offset determined by this property is added to the depth offset determined by the decalOffsetUnits property to determine the overall depth offset to be applied to each pixel.</p>
<p>This property only has effect if the shouldDisableDepthTest property is set to NO.</p>
<p>The initial value of this property is zero, indicating that no depth offset based on the change in depth across the face will be applied.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns the first non-zero value of this property from any descendant mesh node, or will return zero if no mesh nodes are found in the descendants of this node. </p>

</div>
</div>
<a class="anchor" id="a08e8694bf6bf60f3f73a201dd6ac2fcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) decalOffsetUnits</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An offset value used by the GL engine when comparing the Z-distance of the content of this node against previously drawn content. </p>
<p>This can be used to correct for Z-fighting between overlapping, and nearly co-planar, faces of two objects that overlap.</p>
<p>The definitive example is when you wish to apply a decal object on top of another, such as bullet-holes on a wall, or a real label on a box. Since the decal is co-planar with the surface it is attached to, it is easy for rounding errors to cause some of the pixels of the decal to be considered on top of the background, and others to be considered behind the background, resulting in only a partial display of the decal content. This is known as Z-fighting.</p>
<p>By assigning a value to this property, the depth of each pixel will be offset by the minimum resolvable depth buffer value, multiplied by the value of this property. When comparing the depth of content to be drawn against content that has already been drawn, a positive value for this property will effectively move that content away from the camera, and a negative value will effectively move that content towards the camera, relative to the content that has already been drawn.</p>
<p>A value of -1.0 will cause the depth of content to be drawn to be offset by the minimum resolvable depth buffer value, effectively pulling the face toward the camera by an amount equal to the minimum Z-distance that is resolvable by the depth buffer (which depends on the configuration of the depth buffer).</p>
<p>The depth offset determined by this property is added to the depth offset determined by the decalOffsetFactor property to determine the overall depth offset to be applied to each pixel.</p>
<p>This property only has effect if the shouldDisableDepthTest property is set to NO.</p>
<p>The initial value of this property is zero, indicating that no absolute depth offset will be applied.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns the first non-zero value of this property from any descendant mesh node, or will return zero if no mesh nodes are found in the descendants of this node. </p>

</div>
</div>
<a class="anchor" id="a8b5a7a014ef8c5297a0d2a5a74442316"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLenum) depthFunction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The depth function used by the GL engine when comparing the Z-distance of the content of this node against previously drawn content. </p>
<p>This property only has effect if the shouldDisableDepthTest property is set to NO.</p>
<p>This property must be set to one of the following values:</p>
<ul>
<li>GL_LESS - the content of this node will be drawn if it is closer to the camera than previously drawn content.</li>
<li>GL_LEQUAL - the content of this node will be drawn if it is at least as close to the camera as previously drawn content.</li>
<li>GL_EQUAL - the content of this node will be drawn if it is exactly as close to the camera as previously drawn content.</li>
<li>GL_GEQUAL - the content of this node will be drawn if it is at least as far away from the camera as previously drawn content.</li>
<li>GL_GREATER - the content of this node will be drawn if it is farther away from the camera than previously drawn content.</li>
<li>GL_NOTEQUAL - the content of this node will be drawn if it is not exactly as close to the camera as previously drawn content.</li>
<li>GL_ALWAYS - the content of this node will always be drawn</li>
<li>GL_NEVER - the content of this node will not be drawn</li>
</ul>
<p>The initial value of this property is GL_LEQUAL. In most cases, to draw an accurate scene, this value is the most suitable. However, some special cases, including some particle emitters, may benefit from the use of one of the other depth functions.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns the value of this property from the first descendant mesh node, or will return GL_NEVER if no mesh node are found in the descendants of this node. </p>

</div>
</div>
<a class="anchor" id="ae7dedd671475792c90a14ba94f867d6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node_descriptor.html">CC3NodeDescriptor</a>*) descriptorNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the shouldDrawDescriptor is set to YES, returns the child node that draws the descriptor text on this node. </p>
<p>Otherwise, returns nil. </p>

</div>
</div>
<a class="anchor" id="a0bb07b8079bf75af208434b5360cc58b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (ccColor4F) diffuseColor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The diffuse color of the materials of this node. </p>
<p>Setting this property sets the same property on all child nodes. Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

</div>
</div>
<a class="anchor" id="af2209e5b3cde94de7cee8a32cb50970c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray*) directionMarkers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of all the direction marker child nodes that were previously added using the addDirectionMarkerColored:inDirection: and addDirectionMarker methods. </p>

</div>
</div>
<a class="anchor" id="a821370544c7d36e7cbb742988b936102"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (ccColor4F) emissionColor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The emission color of the materials of this node. </p>
<p>Setting this property sets the same property on all child nodes. Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

</div>
</div>
<a class="anchor" id="a93791d6535584f5f2a01132eb600d051"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) expectsVerticallyFlippedTextures</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the texture coordinates of the meshes of the descendants expect that the texture was flipped upside-down during texture loading. </p>
<p>The vertical axis of the coordinate system of OpenGL is inverted relative to the CoreGraphics view coordinate system. As a result, some texture file formats may be loaded upside down. Most common file formats, including JPG, PNG &amp; PVR are loaded right-way up, but using proprietary texture formats developed for other platforms may result in textures being loaded upside-down.</p>
<p>For each descendant mesh node, the value of this property is used in combination with the value of the isUpsideDown property of a texture to determine whether the texture will be oriented correctly when displayed using these texture coordinates.</p>
<p>When a texture or material is assigned to a mesh node, the value of this property is compared with the isUpsideDown property of the texture to automatically determine whether the texture coordinates of the mesh need to be flipped vertically in order to display the texture correctly. If needed, the texture coordinates will be flipped automatically. As part of that inversion, the value of this property will also be flipped, to indicate that the texture coordinates are now aligned differently.</p>
<p>Reading the value of this property will return YES if the same property of any descendant mesh node returns YES, otherwise this property will return NO.</p>
<p>The initial value of this property is set when the underlying mesh texture coordinates are built or loaded. See the same property on the <a class="el" href="interface_c_c3_nodes_resource.html" title="CC3NodesResource is a wrapper class around a resource structure loaded from a data file containing 3D...">CC3NodesResource</a> class to understand how this property is set during mesh resource loading.</p>
<p>Generally, the application never has need to change the value of this property. If you do need to adjust the value of this property, you sould do so before setting a texture or material into any descendant mesh nodes.</p>
<p>Setting the value of this property will set the same property on all descendant nodes.</p>
<p>When building meshes programmatically, you should endeavour to design the mesh so that this property will be YES if you will be using vertically-flipped textures (all texture file formats except PVR). This avoids the texture coordinate having to be flipped automatically when a texture or material is assigned to this mesh node. </p>

</div>
</div>
<a class="anchor" id="ace91e6e8d7aa2448ecf0e05b69358099"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) forwardDirection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The direction in which this node is pointing. </p>
<p>The value of this property is specified in the local coordinate system of this node.</p>
<p>The initial value of this property is kCC3VectorUnitZPositive, pointing down the positive Z-axis in the local coordinate system of this node. When this node is rotated, the original positive-Z axis of the node's local coordinate system will point in this direction.</p>
<p>Pointing the node in a particular direction does not fully define its rotation in 3D space, because the node can be oriented in any rotation around the axis along the forwardDirection vector (think of pointing a camera at a scene, and then rotating the camera along the axis of its lens, landscape towards portrait).</p>
<p>The orientation around this axis is defined by specifying an additional 'up' direction, which fixes the rotation around the forwardDirection by specifying which direction is considered to be 'up'. The 'up' direction is specified by setting the referenceUpDirection property, which is independent of the tilt of the local axes, and does not need to be perpendicular to the forwardDirection.</p>
<p>The value returned for this property is of unit length. When setting this property, the value will be normalized to be a unit vector.</p>
<p>A valid direction vector is required. Attempting to set this property to the zero vector (kCC3VectorZero) will raise an assertion error. </p>

</div>
</div>
<a class="anchor" id="a2f5908c5348fefc150081fc467bf3160"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_box.html">CC3Box</a>) globalBoundingBox</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest axis-aligned bounding box that surrounds any local content of this node, plus all descendants of this node. </p>
<p>The returned bounding box is specified in the global coordinate system of the 3D scene.</p>
<p>Returns kCC3BoxNull if this node has no local content or descendants.</p>
<p>Since the bounding box of a node can change based on the locations, rotations, or scales of any descendant node, this property is measured dynamically on each access, by traversing all descendant nodes. This is a computationally expensive method. </p>

</div>
</div>
<a class="anchor" id="acc22d73847310f1201968c6f40921200"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) globalCenterOfGeometry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the center of geometry of this node, including any local content of this node, plus all descendants of this node. </p>
<p>The returned location is specfied in the global coordinate system of the 3D scene.</p>
<p>If this node has no local content or descendants, returns the value of the globalLocation property.</p>
<p>This property is calculated from the value of the boundingBox property. The computational cost of reading that property depends on whether this node has children. See the notes for that property for more info. </p>

</div>
</div>
<a class="anchor" id="a530c7446c691efd97f83804c4251a644"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) globalForwardDirection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The direction in which this node is pointing, relative to the global coordinate system. </p>
<p>This is calculated by using the globalTransformMatrix to translate the forwardDirection.</p>
<p>The value returned is of unit length. </p>

</div>
</div>
<a class="anchor" id="a168499724355b3e405d770e3e6176974"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>) globalHomogeneousPosition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position of this node in a global 4D homogeneous coordinate space. </p>
<p>The X, Y &amp; Z components of the returned 4D vector are the same as those in the globalLocation property, and for most nodes, the W-component will be one, indicating that the returned vector represents a location. Certain directional subclasses, particularly lights, may optionally return this vector with a W-component of zero, indicating that the returned vector represents a direction. </p>

</div>
</div>
<a class="anchor" id="a526c2c85371de43cc7f1ddabb8874bb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>) globalLightPosition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When a mesh node is textured with a DOT3 bump-map (normal map) in object-space, this property indicates the position, in the global homogeneous coordinate system, of the light that is illuminating the node. </p>
<p>When setting this property, this implementation sets the same property in all child nodes. Set the value of this property to the globalHomogeneousPosition of the light source. Object-space bump-map textures may interact with only one light source.</p>
<p>This property only needs to be set, and will only have effect when set, on individual CC3MeshNodes whose material is configured for bump-mapping using object-space bump-mapping. This property is NOT required to be set when using tangent-space bump-mapping using tangent and/or bitangent vertex attributes under OpenGL ES 2.0.</p>
<p>This property is provided in <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D scene, including visible mesh...">CC3Node</a> as a convenience to automatically traverse the node structural hierarchy to set this property in all descendant nodes.</p>
<p>When reading this property, this implementation returns the value of the same property from the first descendant node that is a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> and that contains a texture unit configured for object-space bump-mapping. Otherwise, this implementation returns kCC3Vector4Zero.</p>
<p>This property is primarily used for setting the global light position. When reading the value of this property, be aware that the position is converted to a local direction within each node. When this property is read, it is always returned as a direction (W = 0). </p>

</div>
</div>
<a class="anchor" id="ad0ca6732d1834fb1ad348a190f810121"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) globalLocation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The location of the node in 3D space, relative to the global origin. </p>
<p>This is calculated by using the globalTransformMatrix to tranform the local origin (0,0,0). </p>

</div>
</div>
<a class="anchor" id="a6333466c83a1709f7a1cb7e5d15daddd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) globalRightDirection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The direction that is considered to be "off to the right" for this node, relative to the global coordinate system. </p>
<p>This is calculated by using the globalTransformMatrix to translate the rightDirection.</p>
<p>The value returned is of unit length. </p>

</div>
</div>
<a class="anchor" id="a4b3a431575f6e933f31ba2a8d9fa54e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) globalRotation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the overall rotation of the node in 3D space, relative to the global X, Y &amp; Z axes. </p>
<p>The returned value contains three Euler angles, specified in degrees, defining a global rotation of this node around the X, Y and Z axes. </p>

</div>
</div>
<a class="anchor" id="a14e0823f5a3988cbd52c2bc566a5f492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) globalScale</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The scale of the node in 3D space, relative to the global coordinate system, and accumulating the scaling of all ancestor nodes. </p>

</div>
</div>
<a class="anchor" id="a92ebf7b4acebdbe4d109d7ae71318196"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a>*) globalTransformMatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The global transformation matrix derived from the location, rotation and scale transform properties of this node and all ancestor nodes. </p>
<p>This matrix is updated automatically whenever any of the transform properties (location, rotation, or scale) of this node, or any of its ancestors, is changed.</p>
<p>This transform matrix includes the transforms of all ancestors to the node. This streamlines rendering in that it allows the transform of each drawable node to be applied directly, and allows the order in which drawable nodes are drawn to be independent of the node structural hierarchy. </p>

</div>
</div>
<a class="anchor" id="aca936278e62c47c93bf0fd6eec86500c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a>*) globalTransformMatrixInverted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the matrix inversion of the globalTransformMatrix. </p>
<p>This can be useful for converting global transform properties, such as global location, rotation and scale to the local coordinate system of the node. </p>

</div>
</div>
<a class="anchor" id="ae97970afde522625afa1c5be2b520827"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) globalUpDirection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The direction that is considered to be 'up' for this node, relative to the global coordinate system. </p>
<p>This is calculated by using the globalTransformMatrix to translate the upDirection. As the node is rotated from its default orientation, this value will be different than the referenceUpDirection, which is fixed and independent of the orientation of the node.</p>
<p>The value returned is of unit length. </p>

</div>
</div>
<a class="anchor" id="ae984cc3ad8b86f4a031fa569d7745161"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasLocalContent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this node has local content that will be drawn. </p>
<p>Default value is NO. Subclasses that do draw content will override to return YES. </p>

</div>
</div>
<a class="anchor" id="ab7dc69f8df858e108e70fc9f6258a347"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasSoftBodyContent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this structural node contains any descendant nodes that are used for soft-body vertex skinning. </p>
<p>This would include nodes of type <a class="el" href="interface_c_c3_skin_mesh_node.html" title="CC3SkinMeshNode is a CC3MeshNode specialized to use vertex skinning to draw the contents of its mesh...">CC3SkinMeshNode</a> or <a class="el" href="interface_c_c3_bone.html" title="CC3Bone is the building block of skeletons that control the deformation of a skin mesh...">CC3Bone</a>.</p>
<p>This property is a convenience used to identify nodes that should be grouped together structurally under a <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a>. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_skinning_08.html#ab7dc69f8df858e108e70fc9f6258a347">CC3Node(Skinning)</a>.</p>

</div>
</div>
<a class="anchor" id="a67a36b58203368ce77f3c7ab8803a568"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasTarget</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this node is tracking the location of a target node. </p>
<p>This is a convenience property that returns YES if the target property is not nil. </p>

</div>
</div>
<a class="anchor" id="ad3066628bf8e7d7ec14ed8a13670371c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isAnimationEnabled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the animation on any animation track in this node is enabled. </p>
<p>The value of this property applies only to this node, not the descendant nodes. Descendant nodes that return YES to this method will be animated even if this node returns NO, and vice-versa.</p>
<p>The initial value of this property is YES. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_animation_08.html#ad3066628bf8e7d7ec14ed8a13670371c">CC3Node(Animation)</a>.</p>

</div>
</div>
<a class="anchor" id="a58a798d71f952da9502d312719c88f3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isBasePODNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this POD is a base node, meaning that it has no parent. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_08.html#a58a798d71f952da9502d312719c88f3f">CC3Node(PVRPOD)</a>.</p>

</div>
</div>
<a class="anchor" id="a8cfa79dcdf72a6f16eaafc208978d50b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isBillboard</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this node is a billboard. </p>
<p>This implementation returns NO. Subclasses that are billboard will override to return YES. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_billboards_08.html#a8cfa79dcdf72a6f16eaafc208978d50b">CC3Node(Billboards)</a>.</p>

</div>
</div>
<a class="anchor" id="a3386cb5bc0372362bafc80abdfef7633"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isCamera</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this node is a camera. </p>
<p>This implementation returns NO. Subclasses that are cameras will override to return YES. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_camera_08.html#a3386cb5bc0372362bafc80abdfef7633">CC3Node(Camera)</a>.</p>

</div>
</div>
<a class="anchor" id="aef0217b56f3fb45b2e9fd83f3d7b15a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isLight</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this node is a light. </p>
<p>This implementation returns NO. Subclasses that are lights will override to return YES. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_c_c3_light_08.html#aef0217b56f3fb45b2e9fd83f3d7b15a2">CC3Node(CC3Light)</a>.</p>

</div>
</div>
<a class="anchor" id="afa487c243f8dca5ec2c90d3000f2a696"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isLightProbe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this node is a light probe. </p>
<p>This implementation returns NO. Subclasses that are light probes will override to return YES. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_environment_nodes_08.html#afa487c243f8dca5ec2c90d3000f2a696">CC3Node(EnvironmentNodes)</a>.</p>

</div>
</div>
<a class="anchor" id="a1667ad6733f7883a474fde3cb52de98a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isMeshNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this node has 3D mesh data to be drawn. </p>
<p>Default value is NO. Subclasses that do draw 3D meshes will override to return YES. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_c_c3_mesh_node_08.html#a1667ad6733f7883a474fde3cb52de98a">CC3Node(CC3MeshNode)</a>.</p>

</div>
</div>
<a class="anchor" id="ac178e6f33f03b599753ac1692bcf3dce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isOpaque</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the content of this node and its descendants is opaque. </p>
<p>Returns NO if at least one descendant is not opaque, as determined by its isOpaque property. Returns YES if all descendants return YES from their isOpaque property.</p>
<p>Setting this property sets the same property in all descendants. See the notes for this property on <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> for more information on how this property interacts with the other material properties.</p>
<p>Setting this property should be thought of as a convenient way to switch between the two most common types of blending combinations. For finer control of blending, set specific blending properties on the <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> instance directly, and avoid making changes to this property.</p>
<p>Before setting this property, for this property to have affect on descendant mesh nodes, you must assign a material to each of those nodes using its material property, or assign a texture to those mesh nodes using the texture property, which will automatically create a material to hold the texture. </p>

</div>
</div>
<a class="anchor" id="a239f148f08d434791a2cb52420c20698"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isRunning</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the dynamic behaviour of this node is enabled. </p>
<p>Setting this property affects both internal activities driven by the update process, and any CCActions controling this node. Setting this property to NO will effectively pause all update and CCAction behaviour on the node. Setting this property to YES will effectively resume the update and CCAction behaviour.</p>
<p>Setting this property sets the same property in all descendant nodes.</p>
<p>Be aware that when this property is set to NO, any CCActions are just paused, but not stopped or removed. If you want to fully stop all CCActions on this node, use the stopAllActions method, or if you want to fully stop all CCActions on this node AND all descendant nodes, use the cleanupActions method. </p>

</div>
</div>
<a class="anchor" id="a3a95e1d8511ab08e4683290d1369448c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isScene</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this node is a scene. </p>
<p>This implementation returns NO. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_scene_08.html#a3a95e1d8511ab08e4683290d1369448c">CC3Node(Scene)</a>.</p>

</div>
</div>
<a class="anchor" id="a243087849ddd0878811a3fd2d9be85e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isShadowVolume</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this node is an instance of a shadow volume. </p>
<p>Always returns NO. Subclasses that are shadow volumes will return YES. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a243087849ddd0878811a3fd2d9be85e3">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a82daff61037ecddfdb9591119ba0fbc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isTouchable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this node will respond to UI touch events. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000177">Deprecated:</a></b></dt><dd>Property renamed to touchEnabled, with getter isTouchEnabled. </dd></dl>
<p>A node may often be touchable even if the touchEnabled flag is set to NO.</p>
<p>When the node is visible, this property returns YES under either of the following conditions:</p>
<ul>
<li>The touchEnabled property of this node is set to YES.</li>
<li>The shouldInheritTouchability property of this node is set to YES, AND the isTouchable property of the parent of this node returns YES.</li>
</ul>
<p>When the node is NOT visible, this property returns YES under either of the following conditions:</p>
<ul>
<li>The touchEnabled property of this node is set to YES AND the shouldAllowTouchableWhenInvisible is set to YES.</li>
<li>The shouldInheritTouchability property of this node is set to YES, AND the isTouchable property of the parent of this node returns YES. AND the shouldAllowTouchableWhenInvisible of this node is set to YES.</li>
</ul>
<p>This design simplifies identifying the node that is of interest when a touch event occurs. Thus, a car may be drawn as a node assembly of many descendant nodes (doors, wheels, body, etc). If touchEnabled is set for the car structural node, but not each wheel, it will be the parent car node that will be returned by the touchableNode property of the car structural node, or each wheel node. This allows the user to touch a wheel, but still have the car identified as the object of interest. </p>

</div>
</div>
<a class="anchor" id="acb2abc9c2a605d725b949853f836bf54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isTrackingForBumpMapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the node held in the target property is a <a class="el" href="interface_c_c3_light.html" title="CC3Light represents the light in the 3D scene. ">CC3Light</a>, the target can be tracked by this node for the purpose of updating the lighting of a contained bump-map texture, instead of rotating to face the light, as normally occurs with tracking. </p>
<p>This property indicates whether this node should update its globalLightPosition from the tracked location of the light, instead of rotating to face the light.</p>
<p>The initial property is set to NO, indicating that this node will rotate to face the target as it or this node moves. If you have set the target property to a <a class="el" href="interface_c_c3_light.html" title="CC3Light represents the light in the 3D scene. ">CC3Light</a> instance, and want the bump-map lighting property globalLightPosition to be updated as the light is tracked instead, set this property to YES. </p>

</div>
</div>
<a class="anchor" id="ac2ed8acc0f14fb7a9abf24d706873b83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isTransformDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether any of the transform properties, location, rotation, or scale have been changed, and so the globalTransformMatrix of this node needs to be recalculated. </p>
<p>This property is automatically set to YES when one of those properties have been changed, and is reset to NO once the globalTransformMatrix has been recalculated. The value of this property is not affected by the state of the localTransformMatrix.</p>
<p>Recalculation of the globalTransformMatrix occurs automatically when that property is accessed. </p>

</div>
</div>
<a class="anchor" id="a277e1309c2aa9c2c4dc313497c1ce7e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isTransformRigid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the current transform applied to this node is rigid. </p>
<p>A rigid transform contains only rotation and translation transformations, and does not include scaling.</p>
<p>This implementation returns the value of the isRigid property of the globalTransformMatrix. </p>

</div>
</div>
<a class="anchor" id="afd9e3b759aaa56641df88a70e1ec07dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isUniformlyScaledGlobally</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether current global scaling is uniform along all axes. </p>
<p>This property takes into consideration the scaling of all ancestors. </p>

</div>
</div>
<a class="anchor" id="a212fe1cdd0af61fb5fbbe74be761d876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) isUniformlyScaledLocally</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether current local scaling (via the scale property) is uniform along all axes. </p>
<p>This property does not take into consideration the scaling of any ancestors. </p>

</div>
</div>
<a class="anchor" id="a1660e02d6c940fcaebb5ff9651592fb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLenum) lineSmoothingHint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates how the GL engine should trade off between rendering quality and speed. </p>
<p>The value of this property should be one of GL_FASTEST, GL_NICEST, or GL_DONT_CARE.</p>
<p>The initial value of this property is GL_DONT_CARE. </p>

</div>
</div>
<a class="anchor" id="acb75ab6c0cd40a98c819d7fbd9f15561"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) lineWidth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The width of the lines that will be drawn. </p>
<p>The initial value is 1.0. </p>

</div>
</div>
<a class="anchor" id="a7c75563f8cd56b1f2d4b0e4d9fc0f2eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_matrix.html">CC3Matrix</a>*) localTransformMatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The local transformation matrix derived from the location, rotation and scale transform properties of this node, relative to the parent of this node. </p>
<p>This matrix determines the transformation between this node and its parent.</p>
<p>If not set directly, this property will be lazily created on first access. Thenceforth, it is updated automatically whenever any of the transform properties (location, rotation, or scale) of this node is changed.</p>
<p>You can set this property directly as an alternative to setting the individual transform properties (location, rotation, and scale). This can sometimes be quite useful for certain complex transformation combinations, especially when sourced from animation data. However, be aware subsequent change to any of the individual tranform properties (location, rotation, or scale) will change the composition of this matrix. </p>

</div>
</div>
<a class="anchor" id="a4fd02187b1ee7884b9d0d8a19e413ae9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) location</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The location of the node in 3D space, relative to the parent of this node. </p>
<p>The global location of the node is therefore a combination of the global location of the parent of this node and the value of this location property. </p>

</div>
</div>
<a class="anchor" id="a49f80cf856a152e5c5a9f08efe15b0b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="_c_c3_node_8h.html#a4bed21b96ced6e7ff2d912800ab99bba">CC3NormalScaling</a>) normalScalingMethod</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the method to be used to scale vertex normals after they have been transformed during vertex drawing. </p>
<p>Normal vectors should have a unit length. Since normals are vectors in the local coordinate system of the node, they are transformed into scene and eye coordinates during drawing.</p>
<p>During transformation, there are several factors that might distort the normal vector:</p>
<ul>
<li>If the normals started out not being of unit length, they will generally be transformed into vectors that are not of unit length.</li>
<li>If the transforms are not rigid, and include scaling, even normals that have unit length in object space will end up shorter or longer than unit length in eye space.</li>
<li>If the transform scaling is not uniform, the normals will shear, and end up shorter or longer than unit length.</li>
</ul>
<p>Normals that are not of unit length, or are sheared, will cause portions of the objects to appear lighter or darker after transformation, or will cause specular highlights to actually be dark, distorting the overall look of the material covering the mesh.</p>
<p>The GL engine can be instructed to compensate for these transforms by setting this property as follows:</p>
<ul>
<li>kCC3NormalScalingNone: No compensating scaling is performed on the normals after they have been transformed. This has the highest performance, but will not adjust the normals if they have been scaled. Use this option if you know that the normals will not be significantly scaled during transformation.</li>
<li>kCC3NormalScalingRescale: Uses the modelview matrix to scale all normals by the inverse of the node's overall scaling. This does have a processing cost, but is much faster than using kCC3NormalScalingNormalize. However, it is not as accurate if significantly non-uniform scaling has been applied to the node.</li>
<li>kCC3NormalScalingNormalize: Normalizes each norml vector independently. This is the most accurate method, but is also, by far, the most computationally expensive. Use this method only if selecting one of the other options does not give you the results that you expect.</li>
<li>kCC3NormalScalingAutomatic: Chooses the most appropriate method based on the scaling that has been applied to the node. If no scaling has been applied to the node, kCC3NormalScalingNone will be used. If only uniform scaling has been applied to the node, kCC3NormalScalingRescale will be used. If non-uniform scaling has been applied to the node, then kCC3NormalScalingNormalize will be used.</li>
</ul>
<p>The initial value of this property is kCC3NormalScalingAutomatic. You can generally leave this property at this default value unless you are not getting the results that you expect.</p>
<p>Setting this property sets the corresponding property in all descendant nodes, and affects the processing of normals in all vertex meshes contained in all descendant nodes.</p>
<p>Querying this property returns the value of this property from the first descendant mesh node, or will return kCC3NormalScalingNone if no mesh node are found in the descendants of this node. </p>

</div>
</div>
<a class="anchor" id="af1226f19a687ba9fbac6960200bee550"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="_c_c3_c_c2_extensions_8h.html#aa13d5a16c4c3791576122915480e1772">CCOpacity</a>) opacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The average opacity of this node. </p>
<p>Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming.</p>
<p>Setting this property sets the same property in all descendants. See the notes for this property on <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> for more information on how this property interacts with the other material properties.</p>
<p>Before setting this property, for this property to have affect on descendant mesh nodes, you must assign a material to each of those nodes using its material property, or assign a texture to those mesh nodes using the texture property, which will automatically create a material to hold the texture.</p>
<p>Setting this property should be thought of as a convenient way to switch between the two most common types of blending combinations. For finer control of blending, set specific blending properties on the <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> instance directly, and avoid making changes to this property. </p>

</div>
</div>
<a class="anchor" id="a09dd9e9f066613896e47b377a086b0e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>*) parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The parent node of this node, in a node structural hierarchy. </p>
<p>This property will be nil if this node has not been added as a child to a parent node. </p>

</div>
</div>
<a class="anchor" id="a968396edac85926dcd809809220f0489"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_performance_statistics.html">CC3PerformanceStatistics</a>*) performanceStatistics</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some node types (notably <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>) collect runtime performance statistics using an instance of <a class="el" href="interface_c_c3_performance_statistics.html" title="Collects statistics about the updating and drawing performance of the 3D scene. ">CC3PerformanceStatistics</a> accessed by this property. </p>
<p>By default, nodes do not collect statistics. This property always returns nil, and setting this property has no effect. Subclasses that performance support statistics collection will override to allow the property to be get and set. </p>

</div>
</div>
<a class="anchor" id="aef24a4c8bb91a62df21ed8b6d61c8a26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLint) podContentIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index of the POD data that forms the type-specific content of this node. </p>
<p>This is distinct from the podIndex property, which is the index of the data for the node, which may be of any node type. Once the type is established, the type-specific content is indexed by the podContentIndex property.</p>
<p>This abstract implementation does not map this property to an instance variable, and always returns kCC3PODNilIndex. Concrete subclasses must override to map to an actual instance variable. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_08.html#aef24a4c8bb91a62df21ed8b6d61c8a26">CC3Node(PVRPOD)</a>.</p>

</div>
</div>
<a class="anchor" id="a63e4fb1452c2513d6484be740d5fa9b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLint) podParentIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index of the parent node of this node. </p>
<p>This will be -1 if this node has no parent.</p>
<p>This abstract implementation does not map this property to an instance variable, and always returns kCC3PODNilIndex. Concrete subclasses must override to map to an actual instance variable. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_08.html#a63e4fb1452c2513d6484be740d5fa9b8">CC3Node(PVRPOD)</a>.</p>

</div>
</div>
<a class="anchor" id="a7390275cb13c5705dc152fecaf2c27f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLint) podTargetIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index of the node that is the target of this node. </p>
<p>This node will be linked to its target in the linkToPODNodes: method.</p>
<p>This abstract implementation does not map this property to an instance variable, and always returns kCC3PODNilIndex. Concrete subclasses must override to map to an actual instance variable. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_p_v_r_p_o_d_08.html#a7390275cb13c5705dc152fecaf2c27f6">CC3Node(PVRPOD)</a>.</p>

</div>
</div>
<a class="anchor" id="a9b45149a327a4c6968b4ddf6c3a569b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) projectedLocation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current location of this node, as projected onto a 2D position in the display coordinate space, indicating where on the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> this 3D location will be seen. </p>
<p>The initial value of this property is kCC3VectorZero. To set the value of this property, pass this node as the argument to the projectNode: method of a <a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D scene. ">CC3Camera</a>. For more information, see the notes for the projectNode: method of <a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D scene. ">CC3Camera</a>.</p>
<p>The 2D position can be read from the X and Y components of the returned 3D location, and is measured in points in the coordinate system of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a>.</p>
<p>The Z-component of the returned location indicates the distance from the camera to this node, with a positive value indicating that this node is in front of the camera, and a negative value indicating that it is behind the camera. If you are only interested in the case when this node is in front of the camera (potentially visible to the camera), check that the Z-component of the returned location is positive.</p>
<p>When several nodes overlap a 2D position on the screen, you can also use the Z-component of the projectedLocation property of each of the nodes to determine which node is closest the camera, and is therefore "on-top" visually. This can be useful when trying to select a 3D node from a touch event position. </p>

</div>
</div>
<a class="anchor" id="a8d2860d65aa974fe26a45d9d2d6cb286"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (CGPoint) projectedPosition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current position of this node, as projected onto a 2D position in the display coordinate space, indicating where on the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> this 3D location will be seen. </p>
<p>This is a convenience property. The value of this property is derived from the X and Y coordinates of the projectedLocation property. If this node is behind the camera, both the X and Y coordinates of the returned point will have the value -kCC3MaxGLfloat.</p>
<p>The initial value of this property is (-kCC3MaxGLfloat, -kCC3MaxGLfloat). To set the value of this property, pass this node as the argument to the projectNode: method of a <a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D scene. ">CC3Camera</a>. For more information, see the notes for the projectNode: method of <a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D scene. ">CC3Camera</a>. </p>

</div>
</div>
<a class="anchor" id="a427a097ebb4cafacc71a22257291aeaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector4.html">CC3Quaternion</a>) quaternion</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rotation of the node in 3D space, relative to the parent of this node, expressed as a quaternion. </p>
<p>Rotational transformation can also be specified using the rotation property (Euler angles), or the rotationAxis and rotationAngle properties. Subsequently, this property can be read to return the corresponding quaternion. </p>

</div>
</div>
<a class="anchor" id="a6c1f03343c83fe05834a5e1a0549428d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) referenceUpDirection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The direction that is considered to be 'up' when rotating to face in a particular direction, by using one of the directional properties forwardDirection, target, or targetLocation. </p>
<p>As explained in the note for the forwardDirection, specifying a forwardDirection alone is not sufficient to determine the rotation of a node in 3D space. This property indicates which direction should be considered 'up' when orienting the rotation of the node to face a direction, target, or target location.</p>
<p>The interpretation of whether the value of this property is specified in local or global coordinates depends on how the direction of pointing is being specified.</p>
<p>When using the forwardDirection property, the value of this property is taken to be specified in the local coordinate system. When using either the target or targetLocation properties, the interpretation of whether the value of this property is specified in the local or global coordinate system is determined by the value of the targettingConstraint property.</p>
<p>The initial value of this property is kCC3VectorUnitYPositive, pointing parallel to the positive Y-axis, and in most cases, this property can be left with that value.</p>
<p>The value returned is of unit length. When setting this property, the value will be normalized to be a unit vector.</p>
<p>When setting this property, a valid direction vector is required. Attempting to set this property to the zero vector (kCC3VectorZero) will raise an assertion error. </p>

</div>
</div>
<a class="anchor" id="a1fcc2bf770c060f53226e219d87f91c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) reflectivity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The reflectivity of the materials of this node. </p>
<p>Setting this property sets the same property on all child nodes. Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

</div>
</div>
<a class="anchor" id="a30f63bb8813dfec78f294e108c090a30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (const char*) renderStreamGroupMarker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a marker string that is pushed onto the GL render stream prior to rendering this node. </p>
<p>The group is popped from the GL render stream after this node is rendered.</p>
<p>This property returns a NULL pointer. Subclasses that contain renderable content can override to provide a meaningful string. Subclasses should avoid dynamically generating this property on each access, since this property is accessed each time the node is rendered. </p>

</div>
</div>
<a class="anchor" id="ae3408ccc2fcaa4d7140170807cbf28c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) rightDirection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The direction in the node's coordinate system that would be considered to be "off to the right" when looking out from the node, along the forwardDirection and with the upDirection defined. </p>
<p>The value returned by this property is in the local coordinate system of this node, except when this node is actively tracking a target node (the shouldTrackTarget property is YES), in which case, the value returned will be a global direction in the global coordinate system.</p>
<p>The value returned is of unit length. </p>

</div>
</div>
<a class="anchor" id="a78c1dc69cd157d76184a077803d57df9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>*) rootAncestor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the root ancestor of this node, in the node structural hierarchy, or returns this node, if this node has no parent. </p>
<p>In almost all cases, this node returned will be the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>. However, if this node and all of its ancestors have not been added to the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>, then the returned node may be some other node.</p>
<p>Reading this property traverses up the node hierarchy. If this property is accessed frequently, it is recommended that it be cached. </p>

</div>
</div>
<a class="anchor" id="a40bf4400c59a1c7dbe3040e32de5c2c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) rotation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rotational orientation of the node in 3D space, relative to the parent of this node. </p>
<p>The global rotation of the node is therefore a combination of the global rotation of the parent of this node and the value of this rotation property. This value contains three Euler angles, defining a rotation of this nodearound the X, Y and Z axes. Each angle is specified in degrees.</p>
<p>Rotation is performed in Y-X-Z order, which is the OpenGL default. Depending on the nature of the object you are trying to control, you can think of this order as yaw, then pitch, then roll, or heading, then inclination, then tilt,</p>
<p>When setting this value, each component is converted to modulo +/-360 degrees.</p>
<p>Rotational transformation can also be specified using the rotationAxis and rotationAngle properties, or the quaternion property. Subsequently, this property can be read to return the corresponding Euler angles. </p>

</div>
</div>
<a class="anchor" id="a7df49fd1ba5f759e58cf941e6f6c5192"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) rotationAngle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The angular rotation around the axis specified in the rotationAxis property. </p>
<p>Rotational transformation can also be specified using the rotation property (Euler angles), or the quaternion property. Subsequently, this property can be read to return the corresponding angle of rotation.</p>
<p>When setting this value, it is converted to modulo +/-360 degrees. When reading this value after making changes using rotateByAngle:aroundAxis:, or using another rotation property, the value of this property will be clamped to +/-180 degrees.</p>
<p>For example, if current rotation is 170 degrees around the rotationAxis, invoking the rotateByAngle:aroundAxis: method using the same rotation axis and 20 degrees, reading this property will return -170 degrees, not 190 degrees. </p>

</div>
</div>
<a class="anchor" id="abe5011c1eb664c356e4a3a37f04d36b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) rotationAxis</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The axis of rotation of the node in 3D space, relative to the parent of this node, expressed as a directional vector. </p>
<p>This axis can be used in conjunction with the rotationAngle property to describe the rotation as a single angular rotation around an arbitrary axis.</p>
<p>Under the identity rotation (no rotation), the rotationAngle is zero and the rotationAxis is undefined. Under that condition, this property will return the zero vector kCC3VectorZero.</p>
<p>Rotational transformation can also be specified using the rotation property (Euler angles), or the quaternion property. Subsequently, this property can be read to return the corresponding axis of rotation. </p>

</div>
</div>
<a class="anchor" id="a86c5d6f12425298dec18c02c18972c0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_rotator.html">CC3Rotator</a>*) rotator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rotator that manages the local rotation of this node. </p>
<p><a class="el" href="interface_c_c3_rotator.html" title="CC3otator encapsulates the various mechanisms of rotating a node, and converts between them...">CC3Rotator</a> is the base class of a class cluster, of which different subclasses perform different types of rotation. The type of object returned by this property may change, depending on what rotational changes have been made to this node.</p>
<p>For example, if no rotation is applied to this node, this property will return a base <a class="el" href="interface_c_c3_rotator.html" title="CC3otator encapsulates the various mechanisms of rotating a node, and converts between them...">CC3Rotator</a>. After the rotation of this node has been changed, this property will return a <a class="el" href="interface_c_c3_mutable_rotator.html" title="CC3MutableRotator encapsulates the various mechanisms for specifiying rotation, and converts between ...">CC3MutableRotator</a>, and if directional properties, such as forwardDirection have been accessed or changed, this property will return a <a class="el" href="interface_c_c3_directional_rotator.html" title="CC3DirectionalRotator is a subclass of CC3MutableRotator that adds the ability to set rotation based ...">CC3DirectionalRotator</a>. The creation of the type of rotator required to support the various rotations is automatic. </p>

</div>
</div>
<a class="anchor" id="a3046c4ba3c92d526869f704243db5207"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) scale</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The scale of the node in each dimension, relative to the parent of this node. </p>
<p>Unless non-uniform scaling is needed, it is recommended that you use the uniformScale property instead.</p>
<p>To ensure that scales used in transforms do not cause singularities and uninvertable matrices, when this scale is applied to the transform of this node, the transform ensures the absolute value of each of the components in the specified scale vector is greater than kCC3ScaleMin. Any component between -kCC3ScaleMin and kCC3ScaleMin is replaced with -kCC3ScaleMin or kCC3ScaleMin, depending on whether the component is less than zero, or not, respectively. </p>

</div>
</div>
<a class="anchor" id="a2a9196fcfe8adf00c77fd292d0b22760"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_scene.html">CC3Scene</a>*) scene</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this node has been added to the 3D scene, either directly, or as part of a node assembly, returns the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance that forms the 3D scene, otherwise returns nil. </p>
<p>Reading this property traverses up the node hierarchy. If this property is accessed frequently, it is recommended that it be cached. </p>

</div>
</div>
<a class="anchor" id="a0866f372eeeb442df83d022f725de856"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_shader_context.html">CC3ShaderContext</a>*) shaderContext</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The GLSL program context containing the GLSL program (vertex &amp; fragment shaders) used to decorate the descendant nodes. </p>
<p>See the notes about the same property in <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>, for more info about the use of shader contexts.</p>
<p>Setting this property causes each descendant to use the specified program context. Querying this property returns the value of the same property from the first descendant node that has a non-nil value in its shaderContext property.</p>
<p>Within each descendant node, the program is held in the program context in the shaderContext property. When using this property to set the program context into each descendant, all descendant nodes will share the same program context. Uniform overrides added to that shared context will be used by all descendant nodes. As an alternative, the shaderProgram property of this node can be used to cause each descendant node to use the same program, but each node will wrap that program in a unique program context. This allows separate uniform overrides to be used on each descendant node.</p>
<p>This property is used only when running under OpenGL ES 2. </p>

</div>
</div>
<a class="anchor" id="aff71f9e4bbe542f4b79dee2d8f9311cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_shader_program.html">CC3ShaderProgram</a>*) shaderProgram</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The GLSL program (vertex &amp; fragment shaders) used to decorate the descendant mesh nodes. </p>
<p>See the notes about the same property in <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>, for more info about the use of shader programs.</p>
<p>Setting this property causes each descendant to use the specified program. Querying this property returns the value of the same property from the first descendant node that has a non-nil value in its shaderProgram property.</p>
<p>Within each descendant mesh node, the program is held in the program context in the shaderContext property. When using this property to set the program into each descendant, a new unique context will be created in each node that does not already have a context. In this way, each node may have its own context, which can be customized separately. As an alternative, the shaderContext property of this node can be used to ensure that each descendant node will not only use the same program, but will share a shader context as well. That will ensure that customizations and uniform overrides made to the shader context will be applied to all nodes that share the context.</p>
<p>This property is used only when running under OpenGL ES 2. </p>

</div>
</div>
<a class="anchor" id="a9c8ba79801408f832114cf0015d6d709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) shadowExpansionLimitFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For shadows cast from locational lights, indicates a maximum distance that the shadow will be allowed to expand. </p>
<p>A shadow from lights at a specific location (locational lights), will expand in size the farther it is cast from the shadow casting node. For some types of shadows, allowing it to expand forever can cause visual artifacts, and so it can be beneficial to limit that expansion.</p>
<p>For example, an infinitely expanding shadow volume can display ghost-shadow artifacts from single-sided shadow meshes (such as planes). In this case, limiting the expansion allows the shadow volume to be closed off at the end by extending the remaining shadow volume to a single point at infinity, rather than an infinite size at infinity.</p>
<p>The value is specified as a multiplicative factor of the distance from the light to the shadow casting node. For example, a value of 10 indicates that the shadow will continue to expand for a distance behind the shadow-caster equivalent to 10 times the distance from the light to the shadow-caster, and then it will remain the same size out to infinity.</p>
<p>The initial value of this property is 100. The value of this property can only be changed after the shadows have been added.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the value of this property from any descendant shadow node, or will return zero if no shadow nodes are found in the descendants of this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a9c8ba79801408f832114cf0015d6d709">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a4cf664f8d955af2cca08a225854c06aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLushort) shadowLagCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the current number of update cycles to the shadow-casting node, light and camera that must be processed before the shadow shape and movement will be updated. </p>
<p>In order to improve performance, the shadowLagFactor property can be used to control how often the shape and location of the shadow should be updated. The value of that property indicates the number of update cycles (usually the same as the number of frames) between successive updates of the shadow volume shape and location. This introduces a lag between the movement of the shadow-casting node, and its shadow, which in many cases will not be visibly significant See the notes of the shadowLagFactor for more info about controlling this behaviour.</p>
<p>The value of this property is decremented just before the updateBeforeTransform: method is invoked during each update cycle, and when the value reaches zero, the transform, shape, and location of the shadow will be recalculated. Once the recalculation is complete, the value of this property is set to the value of the shadowLagFactor, to being the update cycle countdown again.</p>
<p>When the shadowLagFactor property is used to improve performance, to avoid having all shadows updated in the same update cycle, setting the value of this property to a different value across different shadow-casting nodes can help distribute the load of calculating the shadows for a number of shadow-casting nodes across several update cycles.</p>
<p>In most cases, you do not need to set the value of this property directly. becuase when the value of the shadowLagFactor property is set, the value of this property is automatically set to a random value between one and the value of the shadowLagFactor.</p>
<p>When setting the value of this property, it is usually desireable to set the same value in all the nodes within each structural node assembly so that the shadows of all shadow-casting nodes that are moving together, will move together.</p>
<p>Reading the value of this property will tell you where in the update cycle the shadow is currently sitting. The value of this property will change on each update, cycling between the value of the shadowLagFactor, and zero.</p>
<p>The initial value of this property is one, indicating that the shadow shape and motion will be updated on the next update of the shadow-casting node, light or camera.</p>
<p>After that update, the value will be automatically changed to the value of the shadowLagFactor property.</p>
<p>The value of this property can only be changed after the shadow volumes have been added.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first value greater than zero from this property from any descendant shadow node, or will return zero if no shadow nodes are found in the descendants of this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a4cf664f8d955af2cca08a225854c06aa">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a48e5c7fd0e89e322cdba3830a7aa01e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLushort) shadowLagFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calculation of shadow shape and movement can often be quite expensive. </p>
<p>To keep performance high, these calculations are performed only when necessary, specifically when any of the shadow-casting node, light or camera moves.</p>
<p>Because of this design, few updates will be required for a relatively static environment where the light, camera, and node do not often move. In such a situation, the processing load added by the shadow calculations will be low.</p>
<p>However, when the node, light and camera are in constant motion, a noticable performance penalty may arise as the shadow shape and movement is re-calculated frequently.</p>
<p>This property can be used to control how often the shape and location of the shadow should be updated. The value of this property indicates the number of update cycles (usually the same as the number of frames) between successive updates of the shadow volume shape and location.</p>
<p>Setting the value of this property to one will cause the shape and location of the shadow to be updated on every update to the locations of the node, light and camera (ie- every frame). Setting the value of this property to an integer greater than one will cause the update of the shadow to occur only once per that many updates to the shadow-casting node, light and camera (ie- once per that number of frames), effectively creating a lag between the movement of the shadow-casting node, and its shadow.</p>
<p>The visible effect of this lag depends on the nature of the movement of the shadow-casting node. In many situations, the lag will be unnoticable, or at least acceptablly low. However, the lag can sometimes create self-shadowing effects on the side of the node that is in shadow. The acceptability of this will depend on whether the camera can move behind the node to view the sides that are in shadow, and whether the self-shadow is visible on the darkened side.</p>
<p>The use of a value larger than one for this property can often be particularly useful for the shadows of skinned mesh nodes (bone-rigged characters), because the calculations involved in updating the shape and motion of deformable meshes are particularly performance-heavy, and the additional lag introduced by this property is usually quite acceptable visually.</p>
<p>When a number of shadows are being calculated, and the value of this property is set to a value greater than one, the shadowLagCount property can be used to ensure that all shadows are not calculated during the same update cycle, spreading the load of calculating shadow updates for a number of mesh nodes across several update cycles. See the notes of the shadowLagCount property for more info.</p>
<p>The initial value of this property is one, indicating that the shadow shape and motion will be updated on every update of the shadow-casting node, light or camera.</p>
<p>The value of this property can only be changed after the shadow volumes have been added.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first value greater than one from this property from any descendant shadow node, or will return one if no shadow nodes are found in the descendants of this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a48e5c7fd0e89e322cdba3830a7aa01e6">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a86c68a1ac21d067436344c5710acdcfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) shadowOffsetFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An offset factor used by the GL engine when comparing the Z-distance of the content of shadows against previously drawn content. </p>
<p>This can be used to correct for Z-fighting between shadows and the surrounding objects (including the node casting the shadow itself).</p>
<p>For descendant nodes that are shadow volumes, this property combines with the shadowOffsetUnits property to offset the shadow volume from the shadow-casting node itself, so that the shadow volume end caps are drawn slightly in front of the shadow-casting node, to ensure that the shadow volume end caps do not acquire holes caused by Z-fighting with the shadow-caster.</p>
<p>For shadow volume nodes, the initial value of this property is zero. You can adjust this value (typically negative) if Z-fighting occurs. However, be aware that larger absolute values can distort the shadows.</p>
<p>This is a convenience property that sets or queries the decalOffsetFactor property on any descendant shadow nodes. The decalOffsetFactor property will only be set on descendant nodes that represent shadows. The value of that property on other nodes that are not shadows will be left unchanged.</p>
<p>See the notes for the decalOffsetFactor property for technical details about how the value of this property affects drawing.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first non-zero value of this property from any descendant shadow node, or will return zero if no shadow nodes are found in the descendants of this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a86c68a1ac21d067436344c5710acdcfd">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a11c702551a8be555cef1f68a1d71c59e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) shadowOffsetUnits</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An offset value used by the GL engine when comparing the Z-distance of the content of shadows against previously drawn content. </p>
<p>This can be used to correct for Z-fighting between shadows and the surrounding objects (including the node casting the shadow itself).</p>
<p>For descendant nodes that are shadow volumes, this property combines with the shadowOffsetFactor property to offset the shadow volume from the shadow-casting node itself, so that the shadow volume end caps are drawn slightly in front of the shadow-casting node, to ensure that the shadow volume end caps do not acquire holes caused by Z-fighting with the shadow-caster.</p>
<p>For shadow volume nodes, the initial value of this property is minus one (-1) unit. You can adjust this value (typically negative) if Z-fighting occurs. However, be aware that larger absolute values will tend to distort shadows cast.</p>
<p>This is a convenience property that sets or queries the decalOffsetUnits property on any descendant shadow nodes. The decalOffsetUnits property will only be set on descendant nodes that represent shadows. The value of that property on other nodes that are not shadows will be left unchanged.</p>
<p>See the notes for the decalOffsetUnits property for technical details about how the value of this property affects drawing.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first non-zero value of this property from any descendant shadow node, or will return zero if no shadow nodes are found in the descendants of this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a11c702551a8be555cef1f68a1d71c59e">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="ab26210b7713c538378d2042733a112e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray*) shadowVolumes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of all the shadow volume child nodes that were previously added to this node using the addShadowVolumesForLight: and addShadowVolumes methods. </p>
<p>This implementation only looks through the immediate child nodes of this node, and does not recurse below this level. As such, this method only has meaning when invoked on a mesh node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#ab26210b7713c538378d2042733a112e1">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="ab22c2849e08e0f698bfa7c14a864a3ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) shadowVolumeVertexOffsetFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertices of a shadow volume start at the vertices of the light terminator of the shadow-casting node, and extend away from the light source. </p>
<p>The value of this property is multiplied by the distance from the camera to the shadow-casting node to derive a short distance to offset the shadow volume vertices from the corresponding vertices of the shadow-casting node, in the direction away from the light.</p>
<p>The purpose of nudging the vertices of the shadow volume away from the shadow-casting mesh is to reduce Z-fighting between the shadow-caster mesh and the shadow volume mesh. In this sense, this property aims to fix the same issue that the shadowOffsetUnits and shadowOffsetFactor properties attempt to resolve.</p>
<p>The difference is that the shadowVolumeVertexOffsetFactor is always applied in the direction away from the <em>light</em>, whereas the shadowOffsetUnits and shadowOffsetFactor properties move the depth testing towards or away from the <em>camera</em>. This difference can sometimes show up as the relative positions of the shadow-caster, light and camera move around, and is particularly apparent with 2D planar meshes.</p>
<p>Particularly with 2D planar meshes, you can set this property to a positive, non-zero value to nudge the shadow volume vertices away from the shadow-caster vertices in the direction away from the light.</p>
<p>Although both this property and the shadowOffsetUnits and shadowOffsetFactor properties can be used together, doing so can introduce conflicts, again depending on the relative positions of the shadow-casting node, light and camera. It is recommended that you use one or the other technique. Either set one or both of the shadowOffsetUnits and shadowOffsetFactor properties to a non-zero value, and leave this property with a zero value, or set this property to a non-zero value, and set the shadowOffsetUnits and shadowOffsetFactor properties each to zero.</p>
<p>For non-planar convex meshes, leave this property set to zero. For planar meshes, set this property to a positive non-zero value, and set the shadowOffsetUnits and shadowOffsetFactor properties to zero.</p>
<p>The initial value of this property is zero, indicating that no offset will be applied to the shadow volume vertices. Typically, the value of this property is measured in thousandths. As a convenience, the constant kCC3DefaultShadowVolumeVertexOffsetFactor can be used to set the value of this property to an appropriate value.</p>
<p>The value of this property can only be changed after the shadow volumes have been added.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first non-zero value of this property from any descendant shadow node, or will return zero if no shadow nodes are found in the descendants of this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#ab22c2849e08e0f698bfa7c14a864a3ab">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a6e668a4c0befa6bfb3d93cb3a7fc9aaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) shininess</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The shininess of the materials of this node. </p>
<p>Setting this property sets the same property on all child nodes. Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

</div>
</div>
<a class="anchor" id="a216302555d47b0ab179cccc47aa342aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldAddShadowVolumeEndCapsOnlyWhenNeeded</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When using shadow volumes, the shadow volume can be drawn with or without end-caps. </p>
<p>This property determines whether the end-caps will always be added, or will be automatically added only when needed.</p>
<p>Adding end-caps can add a large number of additional faces to the shadow volume, which can affect performance. It is therefore desireable to avoid using end-caps where possible.</p>
<p>End-caps are required when the camera is located within the shadow volume (meaning that the camera is shadowed by the node casting the shadow). Because of this, end-caps will automatically be added to a shadow volume when the camera passes into that shadow volume, and will automatically be removed when the camera passes back out of the shadow volume.</p>
<p>However, without end-caps, the shadow will also be cast across the back of the shadow-casting object itself, darkening the side of the object away from the light, which may or may not be visible from the camera, and may or may not appear as visually undesireable, depending on the lighting and color or texture applied to the node. This self-shadowing is more noticable on light-colored materials. In this situation, it may be desireable to include the end-caps at all times, regardless of whether the camera is inside the shadow of the node or not.</p>
<p>When this property is set to YES, the end-caps will automatically be added only when the camera is within the shadow volume, and will be removed when the camera moves out of the shadow volume. This provides optimal performance.</p>
<p>When this property is set to NO, end-caps will be included always. This is not as efficient, but avoids the issue of self-shadowing described above.</p>
<p>The initial value of this property is NO, indicating that end-caps will be included always, to avoid self-shadowing. If the visual effect of self-shadowing on your object is not significant, you can set the value of this property to YES to improve performance.</p>
<p>The value of this property can only be changed after the shadow volumes have been added.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first NO value of this property from any descendant shadow node, or will return YES if no shadow nodes are found in the descendants of this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a216302555d47b0ab179cccc47aa342aa">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="aa09d8bfdfd1a67eb94f108a984197dd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldAllowTouchableWhenInvisible</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this node should be touchable even when invisible. </p>
<p>When this property and the visible property are set to NO, the isTouchable property will always return NO. When this property is YES, the isTouchable property can return YES for an invisible node, if the other conditions for touchability are met. See the isTouchable property for more info.</p>
<p>The initial value of this propety is NO. </p>

</div>
</div>
<a class="anchor" id="aaa942701fc9f9ad9186b045ae82418a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldApplyOpacityAndColorToMeshContent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For descendant mesh nodes whose mesh contains per-vertex color content, this property indicates whether setting the opacity and color properties should change the color content of all vertices in the mesh. </p>
<p>Normally, opacity and color information is held in the material of a mesh node, and changing the opacity and color properties of a mesh node will change the material properties only. However, when a mesh contains per-vertex coloring, the material opacity and coloring will be ignored in favour of the opacity and coloring of each vertex, and changing these properties will not affect a mesh node with per-vertex coloring. In the case of opacity, this effectivly means that the mesh node cannot be faded in and out by using the opacity property.</p>
<p>Setting this property to YES will ensure that changes to the opacity and color properties are also propagated to the vertex content of any mesh node descendants that have per-vertex color content. In the case of opacity, this allows such mesh nodes to be effectively faded in and out.</p>
<p>This property has no effect on mesh nodes that do not contain per-vertex color content.</p>
<p>The initial value of this property is NO, indicating that changes to the opacity and color of each descendant mesh node will only be applied to the material of the mesh node and not to any per-vertex color content.</p>
<p>Querying this property returns the value of this property on the first descendant mesh node.</p>
<p>Setting this property sets the value in the same property in all descendant mesh nodes. </p>

</div>
</div>
<a class="anchor" id="a452f578797e63d9a8fabd8e3fdb7d772"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldAutoremoveWhenEmpty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this instance should automatically remove itself from its parent once its last child is removed. </p>
<p>Setting this property to YES can be useful for certain types of wrapper subclasses, where a instance wraps a single child node. Removing that child node from the node hierarchy (typically by invoking the remove method on that child node, and which may be performed automatically for some types of child nodes), will also cause the wrapper node to be removed as well. This cleanup is important to avoid littering your scene with empty wrapper nodes.</p>
<p>The initial value of this property is NO, indicating that this instance will NOT automatically remove itself from the node hierarchy once all its child nodes have been removed. </p>

</div>
</div>
<a class="anchor" id="aa8bbe60ca8c2e956a07d749c2446effc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldAutotargetCamera</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this instance should automatically find and track the camera as its target. </p>
<p>If this property is set to YES, this instance will automatically find and track the camera without having to set the target and shouldTrackTarget properties explicitly.</p>
<p>Setting this property to YES has the same effect as setting the shouldTrackTarget to YES and setting the target to the active camera. Beyond simplifying the two steps into one, this property can be set before the active camera is established, or without being aware of the active camera. When using this property, you do not need to set the target property, as it will automatically be set to the active camera.</p>
<p>This property will be set to NO once the camera has been attached as the target.</p>
<p>If the active camera is changed to a different camera (via the activeCamera property of the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>), this property will ensure that this node will target the new active camera.</p>
<p>Setting this property to NO also sets the shouldTrackTarget to NO.</p>
<p>This initial value of this property is NO. </p>

</div>
</div>
<a class="anchor" id="a4e4f9242f26e4c65ceea0ff5e60778df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldBlendAtFullOpacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether blending should be applied even when the material is at full opacity on each descendant node. </p>
<p>Setting the value of this property sets the same property on the material of each descendant mesh node. Reading this property returns YES if this property is set to YES in the material of any descendant node, otherwise this method returns NO.</p>
<p>See the <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> shouldBlendAtFullOpacity property for a description of the effect this property has on blending when changing the opacity of a node. </p>

</div>
</div>
<a class="anchor" id="a171357c7c12e1234776f4dd6d578d798"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldCacheFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether information about the faces of mesh should be cached. </p>
<p>If this property is set to NO, accessing information about the faces through the methods faceAt:, faceIndicesAt:, faceCenterAt:, faceNormalAt:, or facePlaneAt:, will be calculated dynamically from the mesh data.</p>
<p>If such data will be accessed frequently, this repeated dynamic calculation may cause a noticable impact to performance. In such a case, this property can be set to YES to cause the data to be calculated once and cached, improving the performance of subsequent accesses to information about the faces.</p>
<p>However, caching information about the faces will increase the amount of memory required by the mesh, sometimes significantly. To avoid this additional memory overhead, in general, you should leave this property set to NO, unless intensive access to face information is causing a performance impact.</p>
<p>An example of a situation where the use of this property may be noticable, is when adding shadow volumes to nodes. Shadow volumes make intense use of accessing face information about the mesh that is casting the shadow.</p>
<p>When the value of this property is set to NO, any data cached during previous access through the indicesAt:, centerAt:, normalAt:, or planeAt:, methods will be cleared.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES. Initially, and in most cases, all mesh nodes have this property set to NO. </p>

</div>
</div>
<a class="anchor" id="a1a90c32dfff7b406f94cbc61594388cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldCastShadows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this node should cast shadows, if shadows are applied to the node hierarchy to which this node belongs. </p>
<p>Setting the value of this property sets the value of this property in all descendant nodes.</p>
<p>The initial value of this property is YES. You can set the value of this property to NO on specific nodes that you do not want to cast shadows when shadows are applied to a hierarchy of nodes. </p>

</div>
</div>
<a class="anchor" id="a0405e1cf9dfcc80a09cf4fe39282844f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldCastShadowsWhenInvisible</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether descendant mesh nodes should cast shadows even when invisible. </p>
<p>Normally, when a mesh is made invisible, its shadows should disappear as well. However, there are certain situations where you might want a mesh to cast shadows, even when it is not being rendered visibly. One situation might be to use an invisible low-poly mesh to generate the shadows of a more detailed high-poly mesh, in order to reduce the processing effort required to generate the shadows. This technique can be particularly useful when using shadow volumes.</p>
<p>The initial value of this propety is NO.</p>
<p>Setting this value sets the same property on all descendant mesh and light nodes.</p>
<p>Querying this property returns the first YES value of this property from any descendant mesh or light node, or will return NO if no descendant nodes have this property set to YES. </p>

</div>
</div>
<a class="anchor" id="a0a02ef76817887e925c9dc04c0e9826e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldCullBackFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the back faces should be culled on the meshes contained in descendants of this node. </p>
<p>The initial value is YES, indicating that back faces will not be displayed. You can set this property to NO if you have reason to display the back faces of the mesh (for instance, if you have a rectangular plane and you want to show both sides of it).</p>
<p>Since the normal of the face points out the front face, back faces interact with light the same way the front faces do, and will appear luminated by light that falls on the front face, much like a stained-glass window. This may not be the affect that you are after, and for some lighting conditions, instead of disabling back face culling, you might consider creating a second textured front face, placed back-to-back with the original front face.</p>
<p>Be aware that culling improves performance, so this property should be set to NO only when specifically needed for visual effect, and only on the meshes that need it.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns NO if any of the descendant mesh nodes have this property set to NO. Initially, and in most cases, all mesh nodes have this property set to YES.</p>
<p>For more information about this use of this property, see the class notes for the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> class. </p>

</div>
</div>
<a class="anchor" id="a890865bb4d5cf77011e4e3de7f3d1e17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldCullFrontFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the front faces should be culled on the meshes contained in descendants of this node. </p>
<p>The initial value is NO. Normally, you should leave this property with the initial value, unless you have a specific need not to display the front faces.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES. Initially, and in most cases, all mesh nodes have this property set to NO.</p>
<p>For more information about this use of this property, see the class notes for the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a> class. </p>

</div>
</div>
<a class="anchor" id="a26a30412b0a1de08a1baae7db25d0790"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldDisableDepthMask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this instance will disable the GL depth mask while drawing the content of this node. </p>
<p>When the depth mask is disabled, drawing activity will not write to the depth buffer.</p>
<p>If this property is set to NO, the Z-distance of this node will be compared against previously drawn content, and the drawing of this node will update the depth buffer, so that subsequent drawing will take into consideration the Z-distance of this node.</p>
<p>If this property is set to YES, the Z-distance of this node will still be compared against previously drawn content, but the drawing of this node will NOT update the depth buffer, and subsequent drawing will NOT take into consideration the Z-distance of this node.</p>
<p>This property only has effect if the shouldDisableDepthTest property is set to NO.</p>
<p>In most cases, to draw an accurate scene, we want depth testing to be performed at all times, and this property is usually set to NO. However, there are some occasions where it is useful to disable writing to the depth buffer during the drawing of a node. One notable situation is with particle systems, where temporarily disabling the depth mask will avoid Z-fighting between individual particles.</p>
<p>The initial value of this property is NO, indicating that the GL depth mask will not be disabled during the drawing of this node, and the depth buffer will be updated during the drawing of this node.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES, otherwise returns NO. </p>

</div>
</div>
<a class="anchor" id="ae14b782b005ee61d7c12a66669100a1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldDisableDepthTest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this instance will disable the GL depth test while drawing the content of this node. </p>
<p>When the depth test is disabled, the Z-distance of this node will not be compared against previously drawn content, and drawing activity will not write to the depth buffer.</p>
<p>If this property is set to NO, the Z-distance of this node will be compared against previously drawn content, and the drawing of this node will update the depth buffer, so that subsequent drawing will take into consideration the Z-distance of this node.</p>
<p>If this property is set to YES, the Z-distance of this node will not be compared against previously drawn content and this node will be drawn over all previously drawn content. In addition, the drawing of this node will not update the depth buffer, with the result that subsequent object drawing will not take into consideration the Z-distance of this node.</p>
<p>In most cases, to draw an accurate scene, we want depth testing to be performed at all times, and this property is usually set to NO. However, there are some occasions where it is useful to disable depth testing during the drawing of a node. One notable situation is with particle systems, where temporarily disabling depth testing may help avoid Z-fighting between individual particles.</p>
<p>The initial value of this property is NO, indicating that the GL depth tesing will not be disabled during the drawing of this node, and the depth buffer will be updated during the drawing of this node.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES, otherwise returns NO. </p>

</div>
</div>
<a class="anchor" id="aae40f4920a3c8e23a7fe0088a44e2735"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldDrawAllBoundingVolumes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that this node, and each of its descendant nodes, should display the extent of its bounding volumes. </p>
<p>Setting the value of this property has the effect of setting the value of the shouldDrawBoundingVolume property on this node and all its descendant nodes.</p>
<p>Reading this property will return YES if this property is set to YES on any descendant, otherwise NO will be return. </p>

</div>
</div>
<a class="anchor" id="ae4262f42e7d2a599cf5cdf2d7a2edb6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldDrawAllDescriptors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the state of the shouldDrawDescriptor property of this node and all descendant nodes. </p>
<p>Setting this property sets that value into the shouldDrawDescriptor property on this and all descendant nodes.</p>
<p>Setting this property to YES draws a descriptor label on this node and each descendant node. Setting this property to NO removes all of those labels.</p>
<p>Reading this property traverses this node and its descendants and returns NO if any descendant returns NO. Otherwise returns YES. </p>

</div>
</div>
<a class="anchor" id="a5fcb4583de836b376bd11880c67d7598"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldDrawAllLocalContentWireframeBoxes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the state of the shouldDrawLocalContentWireframeBox property of this node, if it has local content, and all descendant nodes that have local content. </p>
<p>Setting this property sets that value into the shouldDrawLocalContentWireframeBox property on this node, if it has local content, and all descendant nodes that have local content.</p>
<p>Setting this property to YES draws individual wireframe boxes around any local content of this node and any descendant nodes that have local content. Setting this property to NO removes all of those boxes.</p>
<p>Reading this property traverses this node and its descendants and returns NO if any descendant returns NO. Otherwise returns YES. </p>

</div>
</div>
<a class="anchor" id="a791e5a2fb4e409d23125af2e9fc3b9a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldDrawAllWireframeBoxes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the state of the shouldDrawWireframeBox property of this node and all descendant nodes. </p>
<p>Setting this property sets that value into the shouldDrawWireframeBox property on this and all descendant nodes.</p>
<p>Setting this property to YES draws individual wireframe boxes around this node and each descendant node. Setting this property to NO removes all of those boxes.</p>
<p>Reading this property traverses this node and its descendants and returns NO if any descendant returns NO. Otherwise returns YES.</p>
<p>If this node has no local content, or has descendant nodes without local content, or descendants themselves (for example cameras, lights, or simply empty structural nodes), setting this property will have no effect for those descendants. Under those conditions, it is possible to set this property to YES and subsequently read the property back as NO. </p>

</div>
</div>
<a class="anchor" id="a52f442144f6dcc33c987e09002109363"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldDrawBoundingVolume</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the node should display the extent of its bounding volume. </p>
<p>The bounding volume is drawn by creating and adding a <a class="el" href="interface_c_c3_bounding_volume_display_node.html" title="CC3BoundingVolumeDisplayNode is a type of CC3MeshNode specialized for displaying the bounding volume ...">CC3BoundingVolumeDisplayNode</a> as a child node to this node. The shape, dimensions, and color of the child node are determined by the type of bounding volume.</p>
<p>If the bounding volume of this node is a composite bounding node, such as the standard <a class="el" href="interface_c_c3_node_tightening_bounding_volume_sequence.html" title="A composite bounding volume that contains other bounding volumes. ">CC3NodeTighteningBoundingVolumeSequence</a>, all bounding volumes will be displayed, each in its own color.</p>
<p>If this node has no bounding volume, setting this property will have no visible effect.</p>
<p>Setting this property to YES can be useful during development in determining the boundaries of a 3D structural node, and how it is interacting with the camera frustum and other nodes during collision detection.</p>
<p>By default, the displayed bounding volume node is not touchable, even if this node is touchable. If, for some reason you want the displayed bounding volume to be touchable, you can retrieve the bounding volume node from the displayNode property of the bounding volume, and set its touchEnabled property to YES. </p>

</div>
</div>
<a class="anchor" id="a98878a97ed2aeaa6cd809cd9596e91b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldDrawDescriptor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this node should display a descriptive label on this node. </p>
<p>When set to YES, a descriptive text label will appear on this node. The descriptive label is positioned at the origin of this node, in this node's local coordinate system. The origin is the location around which transforms such as rotation, movement and scale will occur when applied to this node. The origin is not always the same as the center of geometry of the node.</p>
<p>The descriptive text will appear in the font size specified in the class-side descriptorFontSize property. The color of the descriptive text is determined by the subclass. Typically, for structural nodes, it is the same color as the wireframe box that is drawn around the node when the shouldDrawWireframeBox property is set to YES. For nodes with local content to draw, the color of the text is the same as the wireframe box that is drawn around the local content of the node when the shouldDrawLocalContentWireframeBox property is set to YES.</p>
<p>Setting this property to YES can be useful during development in determining the identification of visible nodes, or the location of nodes that are unable to be drawn correctly.</p>
<p>The descriptive label is drawn by creating and adding a <a class="el" href="interface_c_c3_node_descriptor.html" title="CC3NodeDescriptor is a type of CC3Billboard specialized for attaching a descriptive text label to ano...">CC3NodeDescriptor</a> node as a child node to this node. <a class="el" href="interface_c_c3_node_descriptor.html" title="CC3NodeDescriptor is a type of CC3Billboard specialized for attaching a descriptive text label to ano...">CC3NodeDescriptor</a> is a type of <a class="el" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D Cocos2D CCNode as part of the 3D scene. ">CC3Billboard</a>, and is configured to contain a 2D CCLabel, whose text is set to the description of this node. Setting this property to YES adds the descriptor child node, and setting this property to NO removes the descriptor child node.</p>
<p>By default, the child descriptor node is not touchable, even if this node is touchable. If, for some reason you want the descriptor text to be touchable, you can retrieve the descriptor node from the descriptorNode property, and set the touchEnabled property to YES. </p>

</div>
</div>
<a class="anchor" id="a60fa71718772224c8d18bbea3056c0df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldDrawInClipSpace</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether drawing should be performed in clip-space. </p>
<p>The clip-space coordinate system is a transformation of the camera frustum, where the camera looks down the -Z axis, and entire coorinate system is normalized to cover the range +/-1.0 in each of the X, Y &amp; Z dimensions.</p>
<p>When this property is set to YES, a simple square plane node, with X &amp; Y sides of length 2.0, centered on the origin and facing the +Z axis will fill the entire view. This makes it very easy to create backdrops and post-processing effects.</p>
<p>When this property is set to YES, all combinations of the projection, view, and model matrices will be set to identity matrices during rendering. The node is effectivly drawn with an orthographic projection, looking down the negative Z axis, with X &amp; Y axis dimensions normalized to +/-1.0 each.</p>
<p>To support this node being rendered in clip-space, setting this property to YES also makes the following configuration changes to this mesh node:</p>
<ul>
<li>The mesh is replaced with a simple 2D square mesh with sides of length 2.0.</li>
<li>The shouldUseLighting property is set to NO.</li>
<li>The shouldDisableDepthTest property is set to YES.</li>
<li>The shouldDisableDepthMask property is set to YES.</li>
<li>The boundingVolume property is set to nil.</li>
</ul>
<p>If you want to set the above properties and characteristics to other values, do so after setting this property.</p>
<p>Normally, you want this node to completely cover the entire view, which it does by default, and you do not need to apply any transforms to this node. However, by applying location and scale transforms, you can configure this node so that it only covers a portion of the view. In doing so, keep in mind that clip-space, only the X &amp; Y values of the location and scale properties are used, and that the coordinate system occupies a range between -1 and +1.</p>
<p>Setting the value of this property sets the value of this property in all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES. Initially, and in most cases, all mesh nodes have this property set to NO.</p>
<p>The initial value of this property is NO. </p>

</div>
</div>
<a class="anchor" id="a6296e007b77e700dc737c733454dfa16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldDrawWireframeBox</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the node should display a wireframe bounding box around this node and all its descendants. </p>
<p>The wireframe box is drawn by creating and adding a <a class="el" href="interface_c_c3_wireframe_bounding_box_node.html" title="CC3WireframeBoundingBoxNode is a type of CC3LineNode specialized for drawing a wireframe bounding box...">CC3WireframeBoundingBoxNode</a> as a child node to this node. The dimensions of the child node are set from the boundingBox property of this node. Setting this property to YES adds the wireframe child node, and setting this property to NO removes the wireframe child node.</p>
<p>Setting this property to YES can be useful during development in determining the boundaries of a 3D structural node.</p>
<p>The color of the wireframe box will be the value of the class-side defaultWireframeBoxColor property, or the value of the color property of this node if defaultWireframeBoxColor is equal to kCCC4FBlackTransparent.</p>
<p>If this node has no local content, or no descendant nodes with local content, setting this property will have no effect. In this condition, it is possible to set this property to YES and subsequently read the property back as NO.</p>
<p>By default, the child wireframe node is not touchable, even if this node is touchable. If, for some reason you want the wireframe to be touchable, you can retrieve the wireframe node from the wireframeBoxNode property, and set the touchEnabled property to YES. </p>

</div>
</div>
<a class="anchor" id="a748cf91fcd056313bd242ef769a5b595"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldIgnoreRayIntersection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this bounding volume should ignore intersections from rays. </p>
<p>If this property is set to YES, intersections with rays will be ignored, and the doesIntersectGlobalRay: method will always return NO, and the locationOfGlobalRayIntesection: and globalLocationOfGlobalRayIntesection: properties will always return kCC3VectorNull.</p>
<p>The initial value of this property is NO, and most of the time this is sufficient.</p>
<p>For some uses, such as nodes that should be excluded from puncturing from touch selection rays, such as particle emitters, it might make sense to set this property to YES, so that the bounding volume is not affected by rays from touch events.</p>
<p>This property delegates to the bounding volume. If this node has no bounding volume, this property will always return YES, and setting this property will have no effect. </p>

</div>
</div>
<a class="anchor" id="a6833d96291530bec5cdcdc62fc7dad43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldInheritTouchability</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this node should automatically be considered touchable if this node's parent is touchable. </p>
<p>By using this property, you can turn off touchability on a child node, even when the parent node is touchable.</p>
<p>Normally, a node will be touchable if its touchEnabled property is set to YES on the node itself, or on one of its ancestors. You can change this behaviour by setting this property to NO on the child node. With the touchEnabled property and this property both set to NO, the isTouchable property will return NO, even if the isTouchable property of the parent returns YES, and the node will not respond to touch events even if the parent node does.</p>
<p>The initial value of this property is YES, indicating that this node will return YES in the isTouchable property if the parent node returns YES in its isTouchable property, even if the touchEnabled property of this node is set to NO. </p>

</div>
</div>
<a class="anchor" id="a841ebcfb2bd23fdcb9e9a88859dedf27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldLogIntersectionMisses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When this property is set to YES, a log message will be output whenever the doesIntersectBoundingVolume: method returns NO (indicating that another bounding volume does not intersect the bounding volume of this node), if the shouldLogIntersectionMisses property of the other bounding volume is also set to YES. </p>
<p>The shouldLogIntersectionMisses property of this node and the other bounding volumes must both be set to YES for the log message to be output.</p>
<p>The initial value of this property is NO.</p>
<p>This property is useful during development to help trace intersections between nodes and bounding volumes, such as collision detection between nodes, or whether a node is within the camera's frustum.</p>
<p>This property is only available when the LOGGING_ENABLED compiler build setting is defined and set to 1. </p>

</div>
</div>
<a class="anchor" id="a23a2175dc4b412f1c82fbbbaf2462cd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldLogIntersections</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When this property is set to YES, a log message will be output whenever the doesIntersectBoundingVolume: method returns YES (indicating that another bounding volume intersects the bounding volume of this node), if the shouldLogIntersections property of the other bounding volume is also set to YES. </p>
<p>The shouldLogIntersections property of this node and the other bounding volumes must both be set to YES for the log message to be output.</p>
<p>The initial value of this property is NO.</p>
<p>This property is useful during development to help trace intersections between nodes and bounding volumes, such as collision detection between nodes, or whether a node is within the camera's frustum.</p>
<p>This property is only available when the LOGGING_ENABLED compiler build setting is defined and set to 1. </p>

</div>
</div>
<a class="anchor" id="aaf6148501d14c6d4dec9e418e3c6ddb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldShadowBackFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a shadow should be cast from the back faces of the mesh. </p>
<p>For most meshes, the front faces form the visible faces of the mesh, and the back faces are not rendered. In these typical situations, the value of this property should be set to NO so that a shadow will not be built from the back faces of the object.</p>
<p>However, there are situations, such as with 2D planar meshes that can be viewed from either side, where the back faces will be rendered.</p>
<p>With shadows, there is also the situation where a planar node can be used as a wall, with light coming from behind the wall. Since the back faces of the wall mesh are facing the light, the wall will not cast a shadow.</p>
<p>In these less-common situations, this property can be set to YES to cause a shadow to be cast by the back faces of the mesh.</p>
<p>For a two-sided planar mesh, you can set both the shouldShadowFrontFaces property and this property to YES to cause a shadow to be cast regardless of the orientation of the 2D planar mesh to the light or the camera.</p>
<p>The initial value of this property is NO, indicating that the shadow will not be cast from the back faces of the node.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first YES value of this property from any descendant shadow node, or will return NO if no shadow nodes are found in the descendants of this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#aaf6148501d14c6d4dec9e418e3c6ddb7">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="a7ea076319848bb9c70158ffed4610df4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldShadowFrontFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a shadow should be cast from the front faces of the mesh. </p>
<p>For most meshes, the front faces form the visible faces of the mesh, and it is these visible faces that will cast the shadow.</p>
<p>The initial value of this property is YES, indicating that the shadow will be cast from the front faces of the node.</p>
<p>Setting this value sets the same property on all descendant nodes that are shadows.</p>
<p>Querying this property returns the first NO value of this property from any descendant shadow node, or will return YES if no shadow nodes are found in the descendants of this node. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_shadow_volumes_08.html#a7ea076319848bb9c70158ffed4610df4">CC3Node(ShadowVolumes)</a>.</p>

</div>
</div>
<a class="anchor" id="aece9d9e7bb707235daa70aaca94bc83d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldSmoothLines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether lines should be smoothed (antialiased). </p>
<p>The initial value is NO. </p>

</div>
</div>
<a class="anchor" id="a57ce18b52a92a681ae6f3e8d1a6e93a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldStopActionsWhenRemoved</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether all the CCActions currently running on this node and all descendants should be stopped and removed when this node is removed from its parent. </p>
<p>If the value of this property is YES, when this node is removed from its parent, the cleanupActions method will automatically be invoked. If the value of this method is NO, when this node is removed from its parent, the isRunning property will be set to NO, which causes all actions to be paused, but not removed.</p>
<p>Stopping and removing CCActions is important because the actions running on a node retain links to the node. If the actions are simply paused, those links will be retained forever, potentially creating memory leaks of nodes that are invisibly retained by their actions.</p>
<p>The initial value of this property is YES, indicating that all actions will be stopped and removed when this node is removed from its parent. If you have reason to want the actions to be paused but not removed when removing this node from its parent, set this property to NO.</p>
<p>If you set this property to NO, be sure to set it back to YES before this node, or the ancestor node assembly that this node belongs to is removed for good, otherwise this node will continue to be retained by any actions running on this node, and this node will not be deallocated.</p>
<p>Alternately, if you have this property set to NO, you can manually stop and remove all actions using the cleanupActions method. </p>

</div>
</div>
<a class="anchor" id="af790e290503df860c57147e3e10ab914"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldTrackTarget</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this instance should track the targetLocation or target properties as this node, or the target node, moves around. </p>
<p>If this property is set to YES, as this node move around, or the node in the target property moves around, this node will automatically rotate itself to face the target or targetLocation. If this property is set to NO, this node will initially rotate to face the target or targetLocation, but will not track the target or targetLocation when this node, or the target node, subsequently moves.</p>
<p>The initial value of this property is NO, indicating that if the either the target or targetLocation properties is set, this node will initially point to it, but will not track it as this node, or the target node, moves.</p>
<p>If this property is set to YES, subsequently changing the value of the rotation, quaternion, or forwardDirection properties will have no effect, since they would interfere with the ability to track the target. To set specific rotations or pointing direction, first set this property back to NO. </p>

</div>
</div>
<a class="anchor" id="a899c01b0e0a806669d7827112a275ddc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldUseClockwiseFrontFaceWinding</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the edge-widing algorithm used by the GL engine to determine which face of a triangle is the front face should use clockwise winding. </p>
<p>If this property is set to YES, the front face of all triangles in the mesh of this node will be determined using clockwise winding of the edges. If this property is set to NO, the front face of all triangles in the mesh of this node will be determined using counter-clockwise winding of the edges.</p>
<p>The initial value of this property is NO, indicating that the OpenGL-standard counter-clockwise winding will be used by the GL engine to determine the front face of all triangles in the mesh of this node. Unless you have a reason to change this value, you should leave it at the initial value.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES, otherwise returns NO. </p>

</div>
</div>
<a class="anchor" id="ab17442122bf69cf1f949c241cb229fe3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldUseFixedBoundingVolume</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the bounding volume of this node should be considered fixed, even if the mesh vertices that determine the boundary are changed, or should be recalculated whenever the underlying mesh vertices change. </p>
<p>If the value of this property is set to YES, the bounding volume will NOT be recalculated each time the vertices of the mesh are modified (typically via the setVertexLocation:at: method). If the value of this property is set to NO, the bounding volume will be recalculated each time the vertices of the mesh are modified.</p>
<p>The initial value of this property is NO, indicating that the bounding volume will be recalculated whenever the underlying mesh vertices change.</p>
<p>For most scenarios, the most accurate bounding volume is achieved by leaving setting this property to NO, and letting the bounding volume automatically adapt to changes in the underlying mesh vertices.</p>
<p>However, for some specialized meshes, such as particle generators, where the vertex data is continuously being modified in a predictable manner, the processing cost of constantly re-measuring the bounding volume may be significant, and it may be more effective to set a fixed bounding volume that encompasses the entire possible range of vertex location data, and set the value of this property to YES to stop the bounding volume from being recalculated every time the vertex content is changed.</p>
<p>See the note for the various subclasses of <a class="el" href="interface_c_c3_node_bounding_volume.html" title="CC3NodeBoundingVolumes are used by CC3Nodes to determine whether a node intersets another bounding vo...">CC3NodeBoundingVolume</a> (eg- <a class="el" href="interface_c_c3_node_box_bounding_volume.html" title="A bounding volume that forms an axially aligned bounding box (AABB) around the node, in the node&#39;s local coordinate system. ">CC3NodeBoxBoundingVolume</a> and <a class="el" href="interface_c_c3_node_spherical_bounding_volume.html" title="A bounding volume that forms a sphere around a single point. ">CC3NodeSphericalBoundingVolume</a>) to learn how to set the properties of the bounding volumes, to fix them to a particular range. </p>

</div>
</div>
<a class="anchor" id="a3cbea6e6582b701b52b7a64d37ce6aa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldUseLighting</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this value is set to YES, current lighting conditions (from either lights or light probes) will be taken into consideration when drawing colors and textures. </p>
<p>If this value is set to NO, lighting conditions will be ignored when drawing colors and textures, and the emissionColor will be applied to the mesh surface, without regard to lighting. Blending will still occur, but the other material aspects, including ambientColor, diffuseColor, specularColor, and shininess will be ignored. This is useful for a cartoon effect, where you want a pure color, or the natural colors of the texture, to be included in blending calculations, without having to arrange lighting, or if you want those colors to be displayed in their natural values despite current lighting conditions.</p>
<p>Be aware that the initial value of the emissionColor property is normally black. If you find your node disappears or turns black when you set this property to NO, try changing the value of the emissionColor property.</p>
<p>Setting the value of this property sets the same property in all descendant nodes. Reading the value of this property returns YES if any descendant node returns YES, and returns NO otherwise. </p>

</div>
</div>
<a class="anchor" id="ac18b13f1a27bbeccfd9c620016bf4c60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldUseLightProbes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this value is set to YES, any descendant mesh nodes will ignore the lights in the scene and will, instead, determine the lighting of the mesh node using textures held by light probes in the scene. </p>
<p>This property only has effect if the shouldUseLighting property is set to YES.</p>
<p>Setting the value of this property sets the same property in all descendant nodes. Reading the value of this property returns YES if any descendant node returns YES, and returns NO otherwise.</p>
<p>See the notes of the <a class="el" href="interface_c_c3_light_probe.html" title="CC3LightProbe is a type of light that uses a texture to define the light intensity in any direction a...">CC3LightProbe</a> class to learn more about using light probes to illuminate models within the scene. </p>

</div>
</div>
<a class="anchor" id="adcf527d032102ac1750699662c0c753d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldUseSmoothShading</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the shading of the faces of the mesh of this node should be smoothly shaded, using color interpolation between vertices. </p>
<p>If this property is set to YES, the color of each pixel in any face in the mesh of this node will be interpolated from the colors of all three vertices of the face, using the distance of the pixel to each vertex as the means to interpolate. The result is a smooth gradient of color across the face.</p>
<p>If this property is set to NO, the color of all pixels in any face in the mesh of this node will be determined by the color at the third vertex of the face. All pixels in the face will be painted in the same color.</p>
<p>The initial value is YES. For realistic rendering, you should leave this property with the initial value, unless you have a specific need to render flat color across each face in the mesh, such as to deliberately create a cartoon-like effect on the model.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns NO if any of the descendant mesh nodes have this property set to NO. Initially, and in most cases, all mesh nodes have this property set to YES. </p>

</div>
</div>
<a class="anchor" id="a91c4ff343a0bf2fd2d9df6423dcc16c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) skeletalScale</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the aggregate scale of this node relative to its closest soft-body ancestor. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_skinning_08.html#a91c4ff343a0bf2fd2d9df6423dcc16c1">CC3Node(Skinning)</a>.</p>

</div>
</div>
<a class="anchor" id="a33241811980bc3c100a576de8349c99b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_soft_body_node.html">CC3SoftBodyNode</a>*) softBodyNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nearest structural ancestor node that is a soft-body node, or returns nil if no ancestor nodes are soft-body nodes. </p>

<p>Provided by category <a class="el" href="category_c_c3_node_07_skinning_08.html#a33241811980bc3c100a576de8349c99b">CC3Node(Skinning)</a>.</p>

</div>
</div>
<a class="anchor" id="a12ec9c3ae66471ffdc3eec5612cf4b4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (ccColor4F) specularColor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The specular color of the materials of this node. </p>
<p>Setting this property sets the same property on all child nodes. Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

</div>
</div>
<a class="anchor" id="af4f64f9bff8e82bd227b87368bdd6ae5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) structureDescription</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a description of the structure of this node and its descendants, by recursing through this node and its descendants and appending the result of the description property of each node. </p>
<p>The description of each node appears on a separate line and is indented according to its depth in the structural hierarchy, starting at this node. </p>

</div>
</div>
<a class="anchor" id="a4146d1cc85c17d2ee04215b49098f57e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>*) target</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The target node at which this node is pointed. </p>
<p>If the shouldTrackTarget property is set to YES, this node will track the target so that it always points to the target, regardless of how the target and this node move through the 3D scene.</p>
<p>The reference to the target is weak, allowing the target node to be removed from the scene if needed. This node will receive a nodeWasDestroyed: reference if the target node is removed and deallocated. The default implementation of that method is to set this target property to nil. </p>

</div>
</div>
<a class="anchor" id="aa80feb12e8d0a98ec8b18e3738544ab2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) targetLocation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The global location towards which this node is facing. </p>
<p>This property is always taken to be a global location, even if the targettingConstraint property is set to one of the local coordinate system constraints. The node will always orient to the target or targetLocation as a global coordinate.</p>
<p>Instead of specifying a target node with the target property, this property can be used to set a specific global location to point towards. If the shouldTrackTarget property is set to YES, this node will track the targetLocation so that it always points to the targetLocation, regardless of how this node moves through the 3D scene.</p>
<p>If both target and targetLocation properties are set, this node will orient to the target.</p>
<p>When retrieving this property value, if the property was earlier explictly set, it will be retrieved cleanly. However, if rotation was set by Euler angles, quaternions, or forwardDirection, retrieving the targetLocation comes with two caveats.</p>
<p>The first caveat is that calculating a targetLocation requires the global location of this node, which is only calculated when the node's globalTransformMatrix is calculated after all model updates have been processed. This means that, depending on when you access this property, the calculated targetLocation may be one frame behind the real value.</p>
<p>The second caveat is that the derived targetLocation will be an invented location one unit length away from the globalLocation of this node, in the direction of the fowardDirection of this node. Although this is a real location, it is unlikely that this location is meaningful to the application.</p>
<p>In general, it is best to use this property directly, both reading and writing it, rather than reading this property after setting one of the other rotational properties. </p>

</div>
</div>
<a class="anchor" id="a3fef617a4c42b761f557678cd1bf63ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="_c_c3_rotator_8h.html#afc5673e97432b6a4bee46ca01f979303">CC3TargettingConstraint</a>) targettingConstraint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether rotation should be constrained when attempting to rotate the node to point at the target or targetLocation. </p>
<p>For example, a cheap way of simulating a full 3D tree is to have a simple flat picture of a tree that you rotate around the vertical axis so that it always faces the camera. Or you might have a signpost that you want to rotate towards the camera, or towards another object as that object moves around the scene, and you want the signpost to remain vertically oriented, and rotate side to side, but not up and down, should the object being tracked move up and down.</p>
<p>The initial value of this property is kCC3TargettingConstraintGlobalUnconstrained, indicating that the forward direction of this node will point directly at the target or targetLocation, rotating in the global coordinate system in all three axial directions to do so, and treating the referenceUpDirection as a direction in the global coordinate system. The result is that the node will retain the same global orientation, regardless of how it is moved, or how its ancestors (parent, etc) are moved and rotated. </p>

</div>
</div>
<a class="anchor" id="a66d1b274a380d13313b614b01b2a76ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_texture.html">CC3Texture</a>*) texture</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience property for setting the texture covering all descendant mesh nodes. </p>
<p>Setting the value of this property sets the same property in all descendant mesh nodes. Querying the value of this property returns the first non-nil texture from a descendant mesh node. </p>

</div>
</div>
<a class="anchor" id="aa18700eb982dbcff8acbf70ce0f97b6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_node.html">CC3Node</a>*) touchableNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the node that is of interest if this node is selected by a touch event. </p>
<p>The value of this property is not always this node, but may be an ancestor node instead.</p>
<p>The value returned by this property is this node if the touchEnabled property of this node is set to YES, or the nearest ancestor whose touchEnabled property is set to YES, or nil if neither this node, nor any ancestor has the touchEnabled property set to YES.</p>
<p>This design simplifies identifying the node that is of interest when a touch event occurs. Thus, a car may be drawn as a node assembly of many descendant nodes (doors, wheels, body, etc). If touchEnabled is set for the car structural node, but not each wheel, it will be the parent car node that will be returned by the touchableNode property of the car structural node, or each wheel node. This allows the user to touch a wheel, but still have the car identified as the object of interest. </p>

</div>
</div>
<a class="anchor" id="a3e9737fdedb894debfc209a6e471c02a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) touchEnabled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if this node, or any of its descendants, will respond to UI touch events. </p>
<p>This property also affects which node will be returned by the touchableNode property. If the touchEnabled property is explicitly set for a parent node, but not for a child node, both the parent and the child can be touchable, but it will be the parent that is returned by the touchableNode property of either the parent or child.</p>
<p>This design simplifies identifying the node that is of interest when a touch event occurs. Thus, a car may be drawn as a node assembly of many descendant nodes (doors, wheels, body, etc). If touchEnabled is set for the car structural node, but not each wheel, it will be the parent car node that will be returned by the touchableNode property of the car structural node, or each wheel node. This allows the user to touch a wheel, but still have the car identified as the object of interest.</p>
<p>Normally, only visible nodes can be touched. But this can be changed by setting the shouldAllowTouchableWhenInvisible property to YES.</p>
<p>The initial value of this property is NO. </p>

</div>
</div>
<a class="anchor" id="a09e15c0ce82e6a3b021f2c2e3b3447b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet*) transformListeners</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the collection of objects that have requested that they be notified whenever the transform of this node has changed, which occurs when one of the transform properties (location, rotation &amp; scale) of this node, or any of its structural ancestor nodes, changes. </p>
<p>Each object in the returned collection implements the <a class="el" href="protocol_c_c3_node_transform_listener_protocol-p.html" title="This protocol defines the behaviour requirements for objects that wish to be notified whenever the tr...">CC3NodeTransformListenerProtocol</a>, and will be sent the nodeWasTransformed: notification message when the transform of this node changes.</p>
<p>Objects can be added to this collection by using the addTransformListener: method, and removed using the removeTransformListener: method. This property returns a copy of the collection stored in this node. You can safely invoke the addTransformListener: or removeTransformListener: methods while iterating the returned collection.</p>
<p>Transform listeners are weakly referenced. Each listener should know who it has subscribed to, and must remove itself as a listener (using the removeTransformListener: method) when appropriate, such as when being deallocated.</p>
<p>For the same reason, transform listeners are not automatically copied when a node is copied. If you copy a node and want its listeners to also listen to the copied node, you must deliberately add them to the new node. </p>

</div>
</div>
<a class="anchor" id="a112d11012a4d25e53e1cf431ea5c8469"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLfloat) uniformScale</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The scale of the node, uniform in each dimension, relative to the parent of this node. </p>
<p>Unless non-uniform scaling is needed, it is recommended that you use this property instead of the scale property.</p>
<p>If non-uniform scaling is applied via the scale property, this uniformScale property will return the length of the scale property vector divided by the length of a unit cube (sqrt(3.0)), as an approximation of the overall scaling condensed to a single scalar value.</p>
<p>To ensure that scales used in transforms do not cause singularities and uninvertable matrices, when this scale is applied to the transform of this node, the transform ensures the absolute value of the specified scale value is greater than kCC3ScaleMin. If the value is between -kCC3ScaleMin and kCC3ScaleMin, it is replaced with -kCC3ScaleMin or kCC3ScaleMin, depending on whether the component is less than zero, or not, respectively. </p>

</div>
</div>
<a class="anchor" id="a7d2ea592784c931aa1c78e02f5de5ed5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>) upDirection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The direction, in the node's coordinate system, that is considered to be 'up'. </p>
<p>This corresponds to the referenceUpDirection, after it has been transformed by the rotations of this node. For example, rotating the node upwards to point towards an elevated target will move the upDirection of this node away from the referenceUpDirection.</p>
<p>The value returned by this property is in the local coordinate system of this node, except when this node is actively tracking a target node (the shouldTrackTarget property is YES), in which case, the value returned will be a global direction in the global coordinate system.</p>
<p>The value returned is of unit length. </p>

</div>
</div>
<a class="anchor" id="ab8d92d79ffd98917bdcce43917eb87d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) visible</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controls whether this node should be displayed. </p>
<p>Initial value is YES.</p>
<p>You can set this to NO to make this node and all its descendants invisible to stop them from being displayed and to stop rendering processing on them.</p>
<p>When reading this property, the return value takes into consideration whether the parent is visible. As a result, setting this property to YES and then reading it may return NO if an ancestor has visibility set to NO. </p>

</div>
</div>
<a class="anchor" id="a9ad12e8a7b4202e8cd152c64a31b70aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_wireframe_bounding_box_node.html">CC3WireframeBoundingBoxNode</a>*) wireframeBoxNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the shouldDrawWireframeBox is set to YES, returns the child node that draws the wireframe box around this node. </p>
<p>Otherwise, returns nil. </p>

</div>
</div>
<a class="anchor" id="acbb29f8d02c53f72f48d45c673d33ce4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLint) zOrder</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the order in which this node should be drawn when compared to other nodes, when drawing order should be determined by distance from the camera (Z-order). </p>
<p>Sequencing nodes for drawing based on distance from the camera is necessary for translucent nodes.</p>
<p>In a drawing sequencer that sorts nodes by drawing order based on distance from the camera, the value of this property overrides the distances of the nodes from the camera. Sorting occurs on the value of this property first, and then on distance from the camera.</p>
<p>Sorting based on distance to the camera alone is quite effective. In almost all cases, it is not necessary to set the value of this property, and if nodes are moving around, setting a value to this property can actually interfere with the dynamic determination of the correct drawing order. Only use this property if you have reason to force a node to be drawn before or after another node for visual effect.</p>
<p>The smaller the value of this property, the closer to the camera the node is deemed to be. This property may be assigned a negative value.</p>
<p>The initial value of this property is zero.</p>
<p>The <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> must be configured with a drawing sequencer that sorts by Z-order for this property to be effective.</p>
<p>This property only has effect for nodes with local content to draw (instances of <a class="el" href="interface_c_c3_local_content_node.html" title="CC3LocalContentNode is an abstract class that forms the basis for nodes that have local content to dr...">CC3LocalContentNode</a>). Setting this property passes the value to all descendant nodes. Reading this value returns the average value of all child nodes, or returns zero if there are no child nodes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_c_c3_node_8h.html">CC3Node.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<address class="footer">
<p class="footer"/>© 2010 - 2014 The Brenwill Workshop Ltd.</p>
</address>
</body>
</html>
