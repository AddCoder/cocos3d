<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Cocos3D: Cocos3D API reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-cocos3d.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">
	   <a href="http://cocos3d.org"><img src="http://cocos3d.org/images/cocos3d-Banner-55h.png" /></a>
	   <span id="projectnumber">v2.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="#pub-static-methods">Class Methods</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_c_c3_shader_program-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CC3ShaderProgram Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#import &lt;CC3Shaders.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3ShaderProgram:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_shader_program__inherit__graph.png" border="0" usemap="#_c_c3_shader_program_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_shader_program_inherit__map" id="_c_c3_shader_program_inherit__map">
<area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="115,229,228,256"/><area shape="rect" id="node4" href="protocol_c_c3_cacheable-p.html" title="Defines the behaviour required for an object that can be held in a cache. " alt="" coords="108,155,236,181"/><area shape="rect" id="node5" href="protocol_c_c3_object-p.html" title="Extension to support Cocos3D functionality. " alt="" coords="121,80,223,107"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:a97cf1dd2343958eb30b9beed84da0699"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_attribute.html">CC3GLSLAttribute</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a97cf1dd2343958eb30b9beed84da0699">attributeAtLocation:</a></td></tr>
<tr class="separator:a97cf1dd2343958eb30b9beed84da0699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e70735c8b64e5aa8a64b8640ae3c8d"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_attribute.html">CC3GLSLAttribute</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a77e70735c8b64e5aa8a64b8640ae3c8d">attributeForSemantic:</a></td></tr>
<tr class="separator:a77e70735c8b64e5aa8a64b8640ae3c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac280ca6548d131bd23fd32dea0179e65"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_attribute.html">CC3GLSLAttribute</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#ac280ca6548d131bd23fd32dea0179e65">attributeForSemantic:at:</a></td></tr>
<tr class="separator:ac280ca6548d131bd23fd32dea0179e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dbbcdc808e0790f10d3c6cf201fb64"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_attribute.html">CC3GLSLAttribute</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#ad2dbbcdc808e0790f10d3c6cf201fb64">attributeNamed:</a></td></tr>
<tr class="separator:ad2dbbcdc808e0790f10d3c6cf201fb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822701c0acd09750712dfa7924edd3b9"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a822701c0acd09750712dfa7924edd3b9">bindWithVisitor:</a></td></tr>
<tr class="separator:a822701c0acd09750712dfa7924edd3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c46a2f806ba29e4e9d51a3c7b60cce5"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a8c46a2f806ba29e4e9d51a3c7b60cce5">constructorDescription</a></td></tr>
<tr class="separator:a8c46a2f806ba29e4e9d51a3c7b60cce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eec9a388ffe057058a63c08534e59d"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a88eec9a388ffe057058a63c08534e59d">fullDescription</a></td></tr>
<tr class="separator:a88eec9a388ffe057058a63c08534e59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd578886348e488184515bdc81bcc19"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a4fd578886348e488184515bdc81bcc19">initFromVertexShaderFile:andFragmentShaderFile:</a></td></tr>
<tr class="separator:a4fd578886348e488184515bdc81bcc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768fcbc041056c123d19ef08c02ab584"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a768fcbc041056c123d19ef08c02ab584">initWithSemanticDelegate:fromVertexShaderFile:andFragmentShaderFile:</a></td></tr>
<tr class="separator:a768fcbc041056c123d19ef08c02ab584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a52aa66ca0b5df3f2c8cf8885f2fff"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a29a52aa66ca0b5df3f2c8cf8885f2fff">initWithSemanticDelegate:withVertexShader:andFragmentShader:</a></td></tr>
<tr class="separator:a29a52aa66ca0b5df3f2c8cf8885f2fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a560aab4e4ef0078760a65d1eebae30"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a7a560aab4e4ef0078760a65d1eebae30">initWithVertexShader:andFragmentShader:</a></td></tr>
<tr class="separator:a7a560aab4e4ef0078760a65d1eebae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1663362274cc29dcbd195e0ff0968da4"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a1663362274cc29dcbd195e0ff0968da4">link</a></td></tr>
<tr class="separator:a1663362274cc29dcbd195e0ff0968da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c724ffed2cf9c9dabc1d43a31ea4191"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a2c724ffed2cf9c9dabc1d43a31ea4191">markSceneScopeDirty</a></td></tr>
<tr class="separator:a2c724ffed2cf9c9dabc1d43a31ea4191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12573ce51df5a8f733645ddec035a2b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#ad12573ce51df5a8f733645ddec035a2b">populateDrawScopeUniformsWithVisitor:</a></td></tr>
<tr class="separator:ad12573ce51df5a8f733645ddec035a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428fe1233086f91735eb8fde41152873"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a428fe1233086f91735eb8fde41152873">populateNodeScopeUniformsWithVisitor:</a></td></tr>
<tr class="separator:a428fe1233086f91735eb8fde41152873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df7daf96d863eaf1a5c540e95dafa56"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a2df7daf96d863eaf1a5c540e95dafa56">populateSceneScopeUniformsWithVisitor:</a></td></tr>
<tr class="separator:a2df7daf96d863eaf1a5c540e95dafa56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56ae0a4139ab64cb9979f246c5ae004"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#ae56ae0a4139ab64cb9979f246c5ae004">populateVertexAttributesWithVisitor:</a></td></tr>
<tr class="separator:ae56ae0a4139ab64cb9979f246c5ae004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb52e22a68f33ea431bd7856ffe00684"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#adb52e22a68f33ea431bd7856ffe00684">prewarm</a></td></tr>
<tr class="separator:adb52e22a68f33ea431bd7856ffe00684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa4370177b76515230777d19c543c23"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#abaa4370177b76515230777d19c543c23">remove</a></td></tr>
<tr class="separator:abaa4370177b76515230777d19c543c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46cf709e9bc887897e0d77dc15dd4dc"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#ae46cf709e9bc887897e0d77dc15dd4dc">resetGLState</a></td></tr>
<tr class="separator:ae46cf709e9bc887897e0d77dc15dd4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad446ecec5c07d5f587209a70ea49febe"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#ad446ecec5c07d5f587209a70ea49febe">uniformAtLocation:</a></td></tr>
<tr class="separator:ad446ecec5c07d5f587209a70ea49febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1ea69459fa7a2779257880231655a0"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a6e1ea69459fa7a2779257880231655a0">uniformForSemantic:</a></td></tr>
<tr class="separator:a6e1ea69459fa7a2779257880231655a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65f97854b028611dcf49aada81c94ec"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#ae65f97854b028611dcf49aada81c94ec">uniformForSemantic:at:</a></td></tr>
<tr class="separator:ae65f97854b028611dcf49aada81c94ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d4001e68a75cf6aee271c24dddcb3c"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#af6d4001e68a75cf6aee271c24dddcb3c">uniformNamed:</a></td></tr>
<tr class="separator:af6d4001e68a75cf6aee271c24dddcb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5131c009efb61c818f2e4beeca86b4"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_shader_program.html#a0c5131c009efb61c818f2e4beeca86b4">willBeginDrawingScene</a></td></tr>
<tr class="separator:a0c5131c009efb61c818f2e4beeca86b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Instance Methods inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:ac177c497bf19de1f8208eb375edfef37 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#ac177c497bf19de1f8208eb375edfef37">copy</a></td></tr>
<tr class="separator:ac177c497bf19de1f8208eb375edfef37 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6048039af7b953470a6be1640f3f8fa8 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a6048039af7b953470a6be1640f3f8fa8">copyAsClass:</a></td></tr>
<tr class="separator:a6048039af7b953470a6be1640f3f8fa8 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba6f6333ec6b859b17394fa95a549f1 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aaba6f6333ec6b859b17394fa95a549f1">copyUserDataFrom:</a></td></tr>
<tr class="separator:aaba6f6333ec6b859b17394fa95a549f1 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc25bb52f8f0815c0985e02aeac0e35 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a2fc25bb52f8f0815c0985e02aeac0e35">copyWithName:</a></td></tr>
<tr class="separator:a2fc25bb52f8f0815c0985e02aeac0e35 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3b74491add447b79ad63f7f9912b9e inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aff3b74491add447b79ad63f7f9912b9e">copyWithName:asClass:</a></td></tr>
<tr class="separator:aff3b74491add447b79ad63f7f9912b9e inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5698b73dad043a09dd57c19290c1dcf inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aa5698b73dad043a09dd57c19290c1dcf">copyWithZone:withName:</a></td></tr>
<tr class="separator:aa5698b73dad043a09dd57c19290c1dcf inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6788277bbfff67ed111f2392db9f685a inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a6788277bbfff67ed111f2392db9f685a">copyWithZone:withName:asClass:</a></td></tr>
<tr class="separator:a6788277bbfff67ed111f2392db9f685a inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c7dcbb20dd8712720519d0d0c2410b inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#ae9c7dcbb20dd8712720519d0d0c2410b">deriveNameFrom:</a></td></tr>
<tr class="separator:ae9c7dcbb20dd8712720519d0d0c2410b inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60ad034ddbb26e568589c5254c12bff inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#aa60ad034ddbb26e568589c5254c12bff">deriveNameFrom:usingSuffix:</a></td></tr>
<tr class="separator:aa60ad034ddbb26e568589c5254c12bff inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51802b824fd430e3281e22574f1266ed inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a51802b824fd430e3281e22574f1266ed">init</a></td></tr>
<tr class="separator:a51802b824fd430e3281e22574f1266ed inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf728516905642fd71b913636fab13c0 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#adf728516905642fd71b913636fab13c0">initAtIndex:fromPODResource:</a></td></tr>
<tr class="separator:adf728516905642fd71b913636fab13c0 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096bc5294d2cc78dd979782504456569 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a096bc5294d2cc78dd979782504456569">initUserData</a></td></tr>
<tr class="separator:a096bc5294d2cc78dd979782504456569 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc220d9cffa20a01ecebefa44a44f354 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#afc220d9cffa20a01ecebefa44a44f354">initWithName:</a></td></tr>
<tr class="separator:afc220d9cffa20a01ecebefa44a44f354 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d154e055437d2e0ba9e707a69e3ec0 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#af7d154e055437d2e0ba9e707a69e3ec0">initWithTag:</a></td></tr>
<tr class="separator:af7d154e055437d2e0ba9e707a69e3ec0 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e0ab825fd6f3e9a703d28039c98886 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a36e0ab825fd6f3e9a703d28039c98886">initWithTag:withName:</a></td></tr>
<tr class="separator:a36e0ab825fd6f3e9a703d28039c98886 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30472ca8359ea9480479ed8301a93eb8 inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(GLuint)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a30472ca8359ea9480479ed8301a93eb8">nextTag</a></td></tr>
<tr class="separator:a30472ca8359ea9480479ed8301a93eb8 inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b647607269d0c6bce0d69459d4b7dea inherit pub_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_identifiable.html#a5b647607269d0c6bce0d69459d4b7dea">populateFrom:</a></td></tr>
<tr class="separator:a5b647607269d0c6bce0d69459d4b7dea inherit pub_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Class Methods</h2></td></tr>
<tr class="memitem:a94f6e246eb1fa349b98a48594b29ae0d"><td class="memItemLeft" align="right" valign="top">(id&lt; <a class="el" href="protocol_c_c3_shader_matcher-p.html">CC3ShaderMatcher</a> &gt;)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a94f6e246eb1fa349b98a48594b29ae0d">__deprecated</a></td></tr>
<tr class="separator:a94f6e246eb1fa349b98a48594b29ae0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7c461e470de1fc9eea0e78fe15bc7b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#add7c461e470de1fc9eea0e78fe15bc7b">addProgram:</a></td></tr>
<tr class="separator:add7c461e470de1fc9eea0e78fe15bc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703d669bfdbe590aa8bc8c6e6fae0175"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a703d669bfdbe590aa8bc8c6e6fae0175">defaultShouldAllowDefaultVariableValues</a></td></tr>
<tr class="separator:a703d669bfdbe590aa8bc8c6e6fae0175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2bae7c5c04db569ef9521b17967aaa"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_c_c3_shader_program.html">CC3ShaderProgram</a> *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a9f2bae7c5c04db569ef9521b17967aaa">getProgramNamed:</a></td></tr>
<tr class="separator:a9f2bae7c5c04db569ef9521b17967aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad32873455b259fcf3b1923d8b295e89"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#aad32873455b259fcf3b1923d8b295e89">isPreloading</a></td></tr>
<tr class="separator:aad32873455b259fcf3b1923d8b295e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dded16cf917679cd6f4845032ad732"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#aa3dded16cf917679cd6f4845032ad732">loadedProgramsDescription</a></td></tr>
<tr class="separator:aa3dded16cf917679cd6f4845032ad732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bc57669a3373f10e0c39833b4032e9"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a71bc57669a3373f10e0c39833b4032e9">programFromVertexShaderFile:andFragmentShaderFile:</a></td></tr>
<tr class="separator:a71bc57669a3373f10e0c39833b4032e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f761b3a987ab9ad9136e0afeb7c332"><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#ae5f761b3a987ab9ad9136e0afeb7c332">programNameFromVertexShaderName:andFragmentShaderName:</a></td></tr>
<tr class="separator:ae5f761b3a987ab9ad9136e0afeb7c332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3143f8735def58a93fca778cadbe4cd"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#ab3143f8735def58a93fca778cadbe4cd">programWithSemanticDelegate:fromVertexShaderFile:andFragmentShaderFile:</a></td></tr>
<tr class="separator:ab3143f8735def58a93fca778cadbe4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76429aab6c5833a513521e83883204e"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#ad76429aab6c5833a513521e83883204e">programWithSemanticDelegate:withVertexShader:andFragmentShader:</a></td></tr>
<tr class="separator:ad76429aab6c5833a513521e83883204e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb579ea59514dd8287a8b866b9fbbcbc"><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#aeb579ea59514dd8287a8b866b9fbbcbc">programWithVertexShader:andFragmentShader:</a></td></tr>
<tr class="separator:aeb579ea59514dd8287a8b866b9fbbcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2eb9a2dbc02e59cf37cd9b1e86f42f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a4b2eb9a2dbc02e59cf37cd9b1e86f42f">removeAllPrograms</a></td></tr>
<tr class="separator:a4b2eb9a2dbc02e59cf37cd9b1e86f42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340c84b15a3bc801ca5595ad2a623dd8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a340c84b15a3bc801ca5595ad2a623dd8">removeProgram:</a></td></tr>
<tr class="separator:a340c84b15a3bc801ca5595ad2a623dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8268e5341401d886dd20023a5af24509"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a8268e5341401d886dd20023a5af24509">removeProgramNamed:</a></td></tr>
<tr class="separator:a8268e5341401d886dd20023a5af24509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383c12d6c8195055fcb460ee6c207c32"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a383c12d6c8195055fcb460ee6c207c32">setDefaultShouldAllowDefaultVariableValues:</a></td></tr>
<tr class="separator:a383c12d6c8195055fcb460ee6c207c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395e0062167586457f3a9430fee52bb3"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a395e0062167586457f3a9430fee52bb3">setIsPreloading:</a></td></tr>
<tr class="separator:a395e0062167586457f3a9430fee52bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc1b912f9ebb47a5107422d450236d8"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a2cc1b912f9ebb47a5107422d450236d8">setProgramMatcher:</a></td></tr>
<tr class="separator:a2cc1b912f9ebb47a5107422d450236d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2f3ea52ff2253c8d2fd0f75d52a2f7"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a7e2f3ea52ff2253c8d2fd0f75d52a2f7">setShaderMatcher:</a></td></tr>
<tr class="separator:a7e2f3ea52ff2253c8d2fd0f75d52a2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4af0a8ec0c423821386118eb98e588"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a2f4af0a8ec0c423821386118eb98e588">setShouldAutomaticallyPreloadMatchingPureColorPrograms:</a></td></tr>
<tr class="separator:a2f4af0a8ec0c423821386118eb98e588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8eedf6142a9a6a2ee49fa96298f3ac"><td class="memItemLeft" align="right" valign="top">(id&lt; <a class="el" href="protocol_c_c3_shader_matcher-p.html">CC3ShaderMatcher</a> &gt;)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#acd8eedf6142a9a6a2ee49fa96298f3ac">shaderMatcher</a></td></tr>
<tr class="separator:acd8eedf6142a9a6a2ee49fa96298f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e0a4274b3bf4622e82b2aea53b54b8"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a25e0a4274b3bf4622e82b2aea53b54b8">shouldAutomaticallyPreloadMatchingPureColorPrograms</a></td></tr>
<tr class="separator:a25e0a4274b3bf4622e82b2aea53b54b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5131c009efb61c818f2e4beeca86b4"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_shader_program.html#a0c5131c009efb61c818f2e4beeca86b4">willBeginDrawingScene</a></td></tr>
<tr class="separator:a0c5131c009efb61c818f2e4beeca86b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Class Methods inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:a13ae00555f231e938fcfed31769b8fef inherit pub_static_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(GLint)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_identifiable.html#a13ae00555f231e938fcfed31769b8fef">instanceCount</a></td></tr>
<tr class="separator:a13ae00555f231e938fcfed31769b8fef inherit pub_static_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb2e642c739adb8e0a70f98cf1bfcde inherit pub_static_methods_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_c_c3_identifiable.html#a0eb2e642c739adb8e0a70f98cf1bfcde">resetTagAllocation</a></td></tr>
<tr class="separator:a0eb2e642c739adb8e0a70f98cf1bfcde inherit pub_static_methods_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ad9ecf69ab880895a4fb0dfb1a5891913"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#ad9ecf69ab880895a4fb0dfb1a5891913">attributeCount</a></td></tr>
<tr class="separator:ad9ecf69ab880895a4fb0dfb1a5891913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba97cbb02900e65d6e9cc34c3be22c7"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#acba97cbb02900e65d6e9cc34c3be22c7">attributes</a></td></tr>
<tr class="separator:acba97cbb02900e65d6e9cc34c3be22c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74ef8ec4f86a3195b1c4e6de6b97329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_fragment_shader.html">CC3FragmentShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#aa74ef8ec4f86a3195b1c4e6de6b97329">fragmentShader</a></td></tr>
<tr class="separator:aa74ef8ec4f86a3195b1c4e6de6b97329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3356a292b20659d69bc47f88b8002037"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#a3356a292b20659d69bc47f88b8002037">maxAttributeNameLength</a></td></tr>
<tr class="separator:a3356a292b20659d69bc47f88b8002037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0502d0ba9cb068d66be2b6bbbc48adce"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#a0502d0ba9cb068d66be2b6bbbc48adce">maxUniformNameLength</a></td></tr>
<tr class="separator:a0502d0ba9cb068d66be2b6bbbc48adce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2ba7c96585e86173449cd82e570b3a"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#ada2ba7c96585e86173449cd82e570b3a">programID</a></td></tr>
<tr class="separator:ada2ba7c96585e86173449cd82e570b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3f504494be555339ca75503203dcc4"><td class="memItemLeft" align="right" valign="top">id&lt; <a class="el" href="protocol_c_c3_shader_semantics_delegate-p.html">CC3ShaderSemanticsDelegate</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#a0d3f504494be555339ca75503203dcc4">semanticDelegate</a></td></tr>
<tr class="separator:a0d3f504494be555339ca75503203dcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ce2a2eb24e7a50d895b7ec28f8575f"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#a96ce2a2eb24e7a50d895b7ec28f8575f">shouldAllowDefaultVariableValues</a></td></tr>
<tr class="separator:a96ce2a2eb24e7a50d895b7ec28f8575f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7828cd1dda8fdaafaf443610ee3354"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#a1b7828cd1dda8fdaafaf443610ee3354">texture2DCount</a></td></tr>
<tr class="separator:a1b7828cd1dda8fdaafaf443610ee3354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b146598259db46ae1a66af25487afb"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#a94b146598259db46ae1a66af25487afb">texture2DStart</a></td></tr>
<tr class="separator:a94b146598259db46ae1a66af25487afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf02132d7472e8c3593c8819255d7fe4"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#acf02132d7472e8c3593c8819255d7fe4">textureCubeCount</a></td></tr>
<tr class="separator:acf02132d7472e8c3593c8819255d7fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea35cf53dce9cd9255ba13ad8b7d5790"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#aea35cf53dce9cd9255ba13ad8b7d5790">textureCubeStart</a></td></tr>
<tr class="separator:aea35cf53dce9cd9255ba13ad8b7d5790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53259facb086f9914ed0f533e0783972"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#a53259facb086f9914ed0f533e0783972">textureLightProbeCount</a></td></tr>
<tr class="separator:a53259facb086f9914ed0f533e0783972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4956267fc3f25a8e242d37d4125cba3"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#af4956267fc3f25a8e242d37d4125cba3">textureLightProbeStart</a></td></tr>
<tr class="separator:af4956267fc3f25a8e242d37d4125cba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c2283c6d35fa647681c7efd10be49b"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#a38c2283c6d35fa647681c7efd10be49b">uniformCount</a></td></tr>
<tr class="separator:a38c2283c6d35fa647681c7efd10be49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a85a37b10306924eebfdc831454f197"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#a2a85a37b10306924eebfdc831454f197">uniforms</a></td></tr>
<tr class="separator:a2a85a37b10306924eebfdc831454f197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74e7c727e2a1e08fdf6809bedf85f1f"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#aa74e7c727e2a1e08fdf6809bedf85f1f">uniformStorageElementCount</a></td></tr>
<tr class="separator:aa74e7c727e2a1e08fdf6809bedf85f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ec1cf13438ea304c24c6a39ca76912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_shader.html">CC3VertexShader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#ae8ec1cf13438ea304c24c6a39ca76912">vertexShader</a></td></tr>
<tr class="separator:ae8ec1cf13438ea304c24c6a39ca76912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e30736ee50d08fbaea568dd99107196"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_shader_program.html#a8e30736ee50d08fbaea568dd99107196">wasLoadedFromFile</a></td></tr>
<tr class="separator:a8e30736ee50d08fbaea568dd99107196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interface_c_c3_identifiable"><td colspan="2" onclick="javascript:toggleInherit('properties_interface_c_c3_identifiable')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="interface_c_c3_identifiable.html">CC3Identifiable</a></td></tr>
<tr class="memitem:af603104494fba5d4791f720823528f9d inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSObject *sharedUserData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#af603104494fba5d4791f720823528f9d">__deprecated</a></td></tr>
<tr class="separator:af603104494fba5d4791f720823528f9d inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cccaa59a3f724bff77683237e271b6 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#ac8cccaa59a3f724bff77683237e271b6">name</a></td></tr>
<tr class="separator:ac8cccaa59a3f724bff77683237e271b6 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deeaefbf8e9fdc758bace96cb88b716 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a2deeaefbf8e9fdc758bace96cb88b716">nameSuffix</a></td></tr>
<tr class="separator:a2deeaefbf8e9fdc758bace96cb88b716 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93489bf1874209effdcb78761e7e3480 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a93489bf1874209effdcb78761e7e3480">podIndex</a></td></tr>
<tr class="separator:a93489bf1874209effdcb78761e7e3480 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65202edca1a66ef060b5b0411cb547c3 inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a65202edca1a66ef060b5b0411cb547c3">shouldIncludeInDeepCopy</a></td></tr>
<tr class="separator:a65202edca1a66ef060b5b0411cb547c3 inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe2d1079602a9b93e1803b5d8aefdcc inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a4fe2d1079602a9b93e1803b5d8aefdcc">tag</a></td></tr>
<tr class="separator:a4fe2d1079602a9b93e1803b5d8aefdcc inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82555dcf853eeb9fcdcc5fae1c1fcd5c inherit properties_interface_c_c3_identifiable"><td class="memItemLeft" align="right" valign="top">NSObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_identifiable.html#a82555dcf853eeb9fcdcc5fae1c1fcd5c">userData</a></td></tr>
<tr class="separator:a82555dcf853eeb9fcdcc5fae1c1fcd5c inherit properties_interface_c_c3_identifiable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_protocol_c_c3_cacheable-p"><td colspan="2" onclick="javascript:toggleInherit('properties_protocol_c_c3_cacheable-p')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="protocol_c_c3_cacheable-p.html">&lt;CC3Cacheable&gt;</a></td></tr>
<tr class="memitem:af3f0574df825aa03a7b7646918212512 inherit properties_protocol_c_c3_cacheable-p"><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_c_c3_cacheable-p.html#af3f0574df825aa03a7b7646918212512">name</a></td></tr>
<tr class="separator:af3f0574df825aa03a7b7646918212512 inherit properties_protocol_c_c3_cacheable-p"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_shader_program.html" title="CC3ShaderProgram represents an OpenGL shader program, containing one vertex shader and one fragment s...">CC3ShaderProgram</a> represents an OpenGL shader program, containing one vertex shader and one fragment shader, each compiled from GLSL source code. </p>
<p><a class="el" href="interface_c_c3_shader_program.html" title="CC3ShaderProgram represents an OpenGL shader program, containing one vertex shader and one fragment s...">CC3ShaderProgram</a> manages the automatic population of the attributes and uniforms from the scene content by using semantic definitions for each attribute and uniform. This semantic mapping is handled by a delegate held in the semanticDelegate property.</p>
<p>Since a single shader program can be used by many nodes and materials, shader programs are cached. The most common, and recommended way to create shader programs is to use the programFromVertexShaderFile:andFragmentShaderFile: method, which automatically manages the cache, and only loads, compiles and links the shader program if it is not already cached. </p>
</div><h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="a94f6e246eb1fa349b98a48594b29ae0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id&lt;<a class="el" href="protocol_c_c3_shader_matcher-p.html">CC3ShaderMatcher</a>&gt;) <a class="el" href="_c_c3_point_particles_8h.html#a02634d9de0d1d095c2b947428583239b">__deprecated</a> </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000264">Deprecated:</a></b></dt><dd>Renamed to shaderMatcher. </dd></dl>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a7b18c445779d5dd95a8009b3c3fc6d69">CC3Identifiable</a>.</p>

</div>
</div>
<a class="anchor" id="add7c461e470de1fc9eea0e78fe15bc7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) addProgram: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_shader_program.html">CC3ShaderProgram</a> *)&#160;</td>
          <td class="paramname"><em>program</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified program to the collection of loaded programs. </p>
<p>The specified program should be compiled and linked prior to being added here.</p>
<p>Programs are accessible via their names through the getProgramNamed: method, and each program name should be unique. If a program with the same name as the specified program already exists in this cache, an assertion error is raised.</p>
<p>Depending on the value of the isPreloading property, the shader program may be held within this cache as a weak reference. As a result, the specified shader program may automatically be deallocated and removed from this cache once all external strong references to it have been released.</p>
<p>If the value of both the shouldAutomaticallyPreloadMatchingPureColorPrograms and isPreloading properties are set to YES, this method will ensure that a matching pure-color program is added to the cache for each regular program that is added. The pureColorProgramMatching: method, of the program matcher found in the class-side shaderMatcher property, is used to create the matching pure-color program. </p>

</div>
</div>
<a class="anchor" id="a97cf1dd2343958eb30b9beed84da0699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_attribute.html">CC3GLSLAttribute</a>*) attributeAtLocation: </td>
          <td></td>
          <td class="paramtype">(GLint)&#160;</td>
          <td class="paramname"><em>attrLocation</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vertex attribute at the specified location, or nil if no attribute is defined at the specified location. </p>

</div>
</div>
<a class="anchor" id="a77e70735c8b64e5aa8a64b8640ae3c8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_attribute.html">CC3GLSLAttribute</a>*) attributeForSemantic: </td>
          <td></td>
          <td class="paramtype">(GLenum)&#160;</td>
          <td class="paramname"><em>semantic</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vertex attribute with the specified semantic at index zero, or nil if no attribute is defined for the specified semantic. </p>

</div>
</div>
<a class="anchor" id="ac280ca6548d131bd23fd32dea0179e65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_attribute.html">CC3GLSLAttribute</a>*) <a class="el" href="interface_c_c3_shader_program.html#a77e70735c8b64e5aa8a64b8640ae3c8d">attributeForSemantic:</a> </td>
          <td></td>
          <td class="paramtype">(GLenum)&#160;</td>
          <td class="paramname"><em>semantic</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>semanticIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vertex attribute with the specified semantic and index, or nil if no attribute is defined for the specified semantic. </p>

</div>
</div>
<a class="anchor" id="ad2dbbcdc808e0790f10d3c6cf201fb64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_attribute.html">CC3GLSLAttribute</a>*) attributeNamed: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>name</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vertex attribute with the specified name, or nil if no attribute is defined for the specified name. </p>

</div>
</div>
<a class="anchor" id="a822701c0acd09750712dfa7924edd3b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) bindWithVisitor: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the currentShaderProgram property of the specified visitor to this program, binds this program to the GL engine, and populates the program attributes and uniforms. </p>

</div>
</div>
<a class="anchor" id="a8c46a2f806ba29e4e9d51a3c7b60cce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) constructorDescription </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a description formatted as a source-code line for loading this program from shader source code files. </p>
<p>During development time, you can log this string, then copy and paste it into a pre-loading function within your app code. </p>

</div>
</div>
<a class="anchor" id="a703d669bfdbe590aa8bc8c6e6fae0175"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) defaultShouldAllowDefaultVariableValues </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the initial value of the shouldAllowDefaultVariableValues for each instance. </p>
<p>See the notes for the shouldAllowDefaultVariableValues property for a full discussion.</p>
<p>The initial value of this property is NO. </p>

</div>
</div>
<a class="anchor" id="a88eec9a388ffe057058a63c08534e59d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString*) fullDescription </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a detailed description of this instance, including a description of each uniform and attribute. </p>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#af84be89f3c9397c4247d406009137b5d">CC3Identifiable</a>.</p>

</div>
</div>
<a class="anchor" id="a9f2bae7c5c04db569ef9521b17967aaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (<a class="el" href="interface_c_c3_shader_program.html">CC3ShaderProgram</a>*) getProgramNamed: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>name</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the program with the specified name, or nil if a program with that name has not been added. </p>

</div>
</div>
<a class="anchor" id="a4fd578886348e488184515bdc81bcc19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initFromVertexShaderFile: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>vshFilePath</em></td>
        </tr>
        <tr>
          <td class="paramkey">andFragmentShaderFile:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>fshFilePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this instance by setting the vertexShader and programShader properties to shaders compiled from the GLSL source code loaded from the specified files, and invoking the link and prewarm methods to prepare this instance for use. </p>
<p>Initializes this instance by compiling and linking the GLSL source code loaded from the specified vertex and fragment shader files.</p>
<p>If a shader has already been loaded, compiled, and cached, the cached shader will be reused, and will not be reloaded and recompiled from the file.</p>
<p>The specified file paths may be either absolute paths, or relative to the application resource directory. If the files are located directly in the application resources directory, the specified file paths can simply be the names of the files.</p>
<p>The semanticDelegate property is set to the default semantic delegate returned from the semanticDelegate property of the program matcher in the class-side shaderMatcher property.</p>
<p>This method uses the programNameFromVertexShaderName:andFragmentShaderName: method to set the name of this instance from the names of the vertex and fragment shaders.</p>
<p>Since a single shader program can be used by many nodes and materials, shaders are cached. Typically, this method is not invoked directly, and the programFromVertexShaderFile:andFragmentShaderFile: method is used instead.</p>
<p>If you do use this method directly, before invoking this method, you can invoke the class-side getProgramNamed: method to detemine whether a shader program with with a name derived from the programNameFromVertexShaderName:andFragmentShaderName: method already exists, and after invoking this method, you should use the class-side addProgram: method to add the new shader program instance to the program cache. </p>

</div>
</div>
<a class="anchor" id="a768fcbc041056c123d19ef08c02ab584"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithSemanticDelegate: </td>
          <td></td>
          <td class="paramtype">(id&lt; <a class="el" href="protocol_c_c3_shader_semantics_delegate-p.html">CC3ShaderSemanticsDelegate</a> &gt;)&#160;</td>
          <td class="paramname"><em>semanticDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromVertexShaderFile:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>vshFilePath</em></td>
        </tr>
        <tr>
          <td class="paramkey">andFragmentShaderFile:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>fshFilePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this instance by setting the semanticDelegate property to the specified semantic delgate, setting the vertexShader and programShader properties to shaders compiled from the GLSL source code loaded from the specified files, and invoking the link and prewarm methods to prepare this instance for use. </p>
<p>If a shader has already been loaded, compiled, and cached, the cached shader will be reused, and will not be reloaded and recompiled from the file.</p>
<p>The specified file paths may be either absolute paths, or relative to the application resource directory. If the files are located directly in the application resources directory, the specified file paths can simply be the names of the files.</p>
<p>This method uses the programNameFromVertexShaderName:andFragmentShaderName: method to set the name of this instance from the names of the vertex and fragment shaders.</p>
<p>Since a single shader program can be used by many nodes and materials, shaders are cached. Typically, this method is not invoked directly, and the programFromVertexShaderFile:andFragmentShaderFile: method is used instead.</p>
<p>If you do use this method directly, before invoking this method, you can invoke the class-side getProgramNamed: method to detemine whether a shader program with with a name derived from the programNameFromVertexShaderName:andFragmentShaderName: method already exists, and after invoking this method, you should use the class-side addProgram: method to add the new shader program instance to the program cache. </p>

</div>
</div>
<a class="anchor" id="a29a52aa66ca0b5df3f2c8cf8885f2fff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithSemanticDelegate: </td>
          <td></td>
          <td class="paramtype">(id&lt; <a class="el" href="protocol_c_c3_shader_semantics_delegate-p.html">CC3ShaderSemanticsDelegate</a> &gt;)&#160;</td>
          <td class="paramname"><em>semanticDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">withVertexShader:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_vertex_shader.html">CC3VertexShader</a> *)&#160;</td>
          <td class="paramname"><em>vertexShader</em></td>
        </tr>
        <tr>
          <td class="paramkey">andFragmentShader:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_fragment_shader.html">CC3FragmentShader</a> *)&#160;</td>
          <td class="paramname"><em>fragmentShader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this instance by setting the semanticDelegate property to the specified semantic delgate, setting the vertexShader and programShader properties to the specified shaders, and invoking the link and prewarm methods to prepare this instance for use. </p>
<p>This method uses the programNameFromVertexShaderName:andFragmentShaderName: method to set the name of this instance from the names of the vertex and fragment shaders.</p>
<p>Since a single shader program can be used by many nodes and materials, shader programs are cached. Typically, this method is not invoked directly, and the programWithVertexShader:andFragmentShader: method is used instead.</p>
<p>If you do use this method directly, before invoking this method, you can invoke the class-side getProgramNamed: method, to detemine whether a shader program with a name derived from the programNameFromVertexShaderName:andFragmentShaderName: method already exists, and after invoking this method, you should use the class-side addProgram: method to add the new shader program instance to the program cache. </p>

</div>
</div>
<a class="anchor" id="a7a560aab4e4ef0078760a65d1eebae30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithVertexShader: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_vertex_shader.html">CC3VertexShader</a> *)&#160;</td>
          <td class="paramname"><em>vertexShader</em></td>
        </tr>
        <tr>
          <td class="paramkey">andFragmentShader:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_fragment_shader.html">CC3FragmentShader</a> *)&#160;</td>
          <td class="paramname"><em>fragmentShader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this instance by setting the vertexShader and programShader properties to the specified shaders, and invoking the link and prewarm methods to prepare this instance for use. </p>
<p>The semanticDelegate property is set to the default semantic delegate returned from the semanticDelegate property of the program matcher in the class-side shaderMatcher property.</p>
<p>This method uses the programNameFromVertexShaderName:andFragmentShaderName: method to set the name of this instance from the names of the vertex and fragment shaders.</p>
<p>Since a single shader program can be used by many nodes and materials, shader programs are cached. Typically, this method is not invoked directly, and the programWithVertexShader:andFragmentShader: method is used instead.</p>
<p>If you do use this method directly, before invoking this method, you can invoke the class-side getProgramNamed: method, to detemine whether a shader program with a name derived from the programNameFromVertexShaderName:andFragmentShaderName: method already exists, and after invoking this method, you should use the class-side addProgram: method to add the new shader program instance to the program cache. </p>

</div>
</div>
<a class="anchor" id="aad32873455b259fcf3b1923d8b295e89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) isPreloading </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether shader programs are being pre-loaded. </p>
<p>See the setIsPreloading setter method for a description of how and when to use this property. </p>

</div>
</div>
<a class="anchor" id="a1663362274cc29dcbd195e0ff0968da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) link </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Links the vertex and fragment shaders into this shader program. </p>
<p>The vertexShader, fragmentShader, and semanticDelegate properties must be set prior to invoking this method.</p>
<p>This method is automatically invoked during instance initialization if the vertex and fragment shaders are provided. If you create this instance without shaders and add them later, you can invoke this method once the vertexShader and fragmentShader properties have been set. </p>

</div>
</div>
<a class="anchor" id="aa3dded16cf917679cd6f4845032ad732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString*) loadedProgramsDescription </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a description of the shader programs in this cache that were loaded from files, with each entry formatted as a source-code line to load the shader program from a file. </p>
<p>During development time, you can log this string, then copy and paste it into a pre-loading function within your app code to pre-load the shader programs for later use. </p>

</div>
</div>
<a class="anchor" id="a2c724ffed2cf9c9dabc1d43a31ea4191"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) markSceneScopeDirty </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the scene scope variables as dirty and in need of re-populating. </p>
<p>Invoked automatically at the beginning of scene rendering. </p>

</div>
</div>
<a class="anchor" id="ad12573ce51df5a8f733645ddec035a2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateDrawScopeUniformsWithVisitor: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the uniform variables that have draw scope. </p>

</div>
</div>
<a class="anchor" id="a428fe1233086f91735eb8fde41152873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateNodeScopeUniformsWithVisitor: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the uniform variables that have node scope. </p>

</div>
</div>
<a class="anchor" id="a2df7daf96d863eaf1a5c540e95dafa56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateSceneScopeUniformsWithVisitor: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the scene scope was previously marked dirty by an invocation of the markSceneScopeDirty method, this method populates all uniform variables that have scene scope, and marks the scene scope as no longer dirty. </p>
<p>Further invocations of this method will not re-populate the scene scope variables until markSceneScopeDirty is invoked.</p>
<p>This method is lazily invoked by the populateNodeScopeUniformsWithVisitor method. Therefore, scene scope will be populated on each render pass when the first node that uses this program is rendered. Under normal operations, this method need never be explicitly invoked. </p>

</div>
</div>
<a class="anchor" id="ae56ae0a4139ab64cb9979f246c5ae004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateVertexAttributesWithVisitor: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *)&#160;</td>
          <td class="paramname"><em>visitor</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the vertex attribute variables. </p>

</div>
</div>
<a class="anchor" id="adb52e22a68f33ea431bd7856ffe00684"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) prewarm </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre-warms this shader program by using it to render a small mesh node to an off-screen surface. </p>
<p>The GL engine may choose to defer some final shader program compilation steps until the first time the shader program is used to render a mesh. This can cause the first frame of the first mesh drawn with the shader program to take significantly longer than subsequent renderings with that shader program, which can often result in a transient, but noticable, "freezing" of the scene. This is particularly apparent for new meshes that are added to the scene at any point other than during scene initialization.</p>
<p>To avoid this, this method can be invoked to cause this shader program to render a small mesh to an off-screen rendering surface, in order to force this shader program to perform its final compilation and linking steps at a controlled, and predicatble, time.</p>
<p>This method is automatically invoked during instance initialization if the vertex and fragment shaders are provided. If you create this instance without shaders and add them later, you can invoke this method once the vertexShader and fragmentShader properties have been set, and the link method has been invoked.</p>
<p>Prewarming is always performed on shader programs loaded on the background thread, but is only performed on shader programs loaded on the foreground thread during the preloading phase. This is to avoid prewarming activity during lazy loading of shader programs during rendering. </p>

</div>
</div>
<a class="anchor" id="a71bc57669a3373f10e0c39833b4032e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) programFromVertexShaderFile: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>vshFilePath</em></td>
        </tr>
        <tr>
          <td class="paramkey">andFragmentShaderFile:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>fshFilePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance by setting the vertexShader and programShader properties to shaders compiled from the GLSL source code loaded from the specified files, and invoking the link and prewarm methods to prepare the instance for use. </p>
<p>If either shader has already been loaded, compiled, and cached, the cached shader will be reused, and will not be reloaded and recompiled from the file.</p>
<p>The specified file paths may be either absolute paths, or relative to the application resource directory. If the files are located directly in the application resources directory, the specified file paths can simply be the names of the files.</p>
<p>The semanticDelegate property is set to the default semantic delegate returned from the semanticDelegate property of the program matcher in the class-side shaderMatcher property.</p>
<p>Programs loaded through this method are cached. If the program was already loaded and is in the cache, it is retrieved and returned. If the program has not in the cache, it is loaded, compiled, and linked, placed into the cache, and returned. It is therefore safe to invoke this method any time the program is needed, without having to worry that the program will be repeatedly loaded and compiled from the files.</p>
<p>This method uses the programNameFromVertexShaderName:andFragmentShaderName: method to set the name of the instance from the names of the vertex and fragment shaders, and to attempt to retrieve the program from the cache, prior to creating a new program.</p>
<p>To clear a program instance from the cache, use the removeProgram: method.</p>
<p>To create the program directly, bypassing the cache, use the alloc and initWithSemanticDelegate:fromVertexShaderFile:andFragmentShaderFile: methods. This technique can be used to create the same program twice, if needed for some reason. Each distinct instance can then be given its own name, and added to the cache separately. </p>

</div>
</div>
<a class="anchor" id="ae5f761b3a987ab9ad9136e0afeb7c332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString*) programNameFromVertexShaderName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>vertexShaderName</em></td>
        </tr>
        <tr>
          <td class="paramkey">andFragmentShaderName:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>fragmentShaderName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a program name created as a simple hyphenated concatenation of the specified vertex and shader names. </p>
<p>This method is used to standardize the naming of programs, to ease in adding and retrieving programs to and from the cache. </p>

</div>
</div>
<a class="anchor" id="ab3143f8735def58a93fca778cadbe4cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) programWithSemanticDelegate: </td>
          <td></td>
          <td class="paramtype">(id&lt; <a class="el" href="protocol_c_c3_shader_semantics_delegate-p.html">CC3ShaderSemanticsDelegate</a> &gt;)&#160;</td>
          <td class="paramname"><em>semanticDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromVertexShaderFile:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>vshFilePath</em></td>
        </tr>
        <tr>
          <td class="paramkey">andFragmentShaderFile:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>fshFilePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance by setting the semanticDelegate property to the specified semantic delgate, setting the vertexShader and programShader properties to shaders compiled from the GLSL source code loaded from the specified files, and invoking the link and prewarm methods to prepare this instance for use. </p>
<p>If either shader has already been loaded, compiled, and cached, the cached shader will be reused, and will not be reloaded and recompiled from the file.</p>
<p>The specified file paths may be either absolute paths, or relative to the application resource directory. If the files are located directly in the application resources directory, the specified file paths can simply be the names of the files.</p>
<p>Programs loaded through this method are cached. If the program was already loaded and is in the cache, it is retrieved and returned. If the program has not in the cache, it is loaded, compiled, and linked, placed into the cache, and returned. It is therefore safe to invoke this method any time the program is needed, without having to worry that the program will be repeatedly loaded and compiled from the files.</p>
<p>This method uses the programNameFromVertexShaderName:andFragmentShaderName: method to set the name of the instance from the names of the vertex and fragment shaders, and to attempt to retrieve the program from the cache, prior to creating a new program.</p>
<p>To clear a program instance from the cache, use the removeProgram: method.</p>
<p>To create the program directly, bypassing the cache, use the alloc and initWithSemanticDelegate:fromVertexShaderFile:andFragmentShaderFile: methods. This technique can be used to create the same program twice, if needed for some reason. Each distinct instance can then be given its own name, and added to the cache separately. </p>

</div>
</div>
<a class="anchor" id="ad76429aab6c5833a513521e83883204e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) programWithSemanticDelegate: </td>
          <td></td>
          <td class="paramtype">(id&lt; <a class="el" href="protocol_c_c3_shader_semantics_delegate-p.html">CC3ShaderSemanticsDelegate</a> &gt;)&#160;</td>
          <td class="paramname"><em>semanticDelegate</em></td>
        </tr>
        <tr>
          <td class="paramkey">withVertexShader:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_vertex_shader.html">CC3VertexShader</a> *)&#160;</td>
          <td class="paramname"><em>vertexShader</em></td>
        </tr>
        <tr>
          <td class="paramkey">andFragmentShader:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_fragment_shader.html">CC3FragmentShader</a> *)&#160;</td>
          <td class="paramname"><em>fragmentShader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance by setting the semanticDelegate property to the specified semantic delgate, setting the vertexShader and programShader properties to the specified shaders, and invoking the link and prewarm methods to prepare the instance for use. </p>
<p>Programs loaded through this method are cached. If the program was already loaded and is in the cache, it is retrieved and returned. If the program has not in the cache, it is loaded, compiled, and linked, placed into the cache, and returned. It is therefore safe to invoke this method any time the program is needed, without having to worry that the program will be repeatedly loaded and compiled from the files.</p>
<p>This method uses the programNameFromVertexShaderName:andFragmentShaderName: method to set the name of the instance from the names of the vertex and fragment shaders, and to attempt to retrieve the program from the cache, prior to creating a new program.</p>
<p>To clear a program instance from the cache, use the removeProgram: method.</p>
<p>To create the program directly, bypassing the cache, use the alloc and initWithSemanticDelegate:withVertexShader:withFragmentShader: methods. This technique can be used to create the same program twice, if needed for some reason. Each distinct instance can then be given its own name, and added to the cache separately. </p>

</div>
</div>
<a class="anchor" id="aeb579ea59514dd8287a8b866b9fbbcbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id) programWithVertexShader: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_vertex_shader.html">CC3VertexShader</a> *)&#160;</td>
          <td class="paramname"><em>vertexShader</em></td>
        </tr>
        <tr>
          <td class="paramkey">andFragmentShader:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_fragment_shader.html">CC3FragmentShader</a> *)&#160;</td>
          <td class="paramname"><em>fragmentShader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance by setting the vertexShader and programShader properties to the specified shaders, and invoking the link and prewarm methods to prepare the instance for use. </p>
<p>The semanticDelegate property is set to the default semantic delegate returned from the semanticDelegate property of the program matcher in the class-side shaderMatcher property.</p>
<p>Programs loaded through this method are cached. If the program was already loaded and is in the cache, it is retrieved and returned. If the program has not in the cache, it is loaded, compiled, and linked, placed into the cache, and returned. It is therefore safe to invoke this method any time the program is needed, without having to worry that the program will be repeatedly loaded and compiled from the files.</p>
<p>This method uses the programNameFromVertexShaderName:andFragmentShaderName: method to set the name of the instance from the names of the vertex and fragment shaders, and to attempt to retrieve the program from the cache, prior to creating a new program.</p>
<p>To clear a program instance from the cache, use the removeProgram: method.</p>
<p>To create the program directly, bypassing the cache, use the alloc and initWithSemanticDelegate:withVertexShader:withFragmentShader: methods. This technique can be used to create the same program twice, if needed for some reason. Each distinct instance can then be given its own name, and added to the cache separately. </p>

</div>
</div>
<a class="anchor" id="abaa4370177b76515230777d19c543c23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) remove </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes this program instance from the cache. </p>

</div>
</div>
<a class="anchor" id="a4b2eb9a2dbc02e59cf37cd9b1e86f42f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) removeAllPrograms </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes from the cache all shader programs that are instances of any subclass of the receiver. </p>
<p>You can use this method to selectively remove specific types of shader programs, based on the shader program class, by invoking this method on that class. If you invoke this method on the <a class="el" href="interface_c_c3_shader_program.html" title="CC3ShaderProgram represents an OpenGL shader program, containing one vertex shader and one fragment s...">CC3ShaderProgram</a> class, this cache will be compltely cleared. However, if you invoke this method on one of its subclasses, only those shader programs that are instances of that subclass (or one of its subclasses in turn) will be removed, leaving the remaining shader programs in the cache. </p>

</div>
</div>
<a class="anchor" id="a340c84b15a3bc801ca5595ad2a623dd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) removeProgram: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_c_c3_shader_program.html">CC3ShaderProgram</a> *)&#160;</td>
          <td class="paramname"><em>program</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified program from the program cache. </p>

</div>
</div>
<a class="anchor" id="a8268e5341401d886dd20023a5af24509"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) removeProgramNamed: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>name</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the program with the specified name from the program cache. </p>

</div>
</div>
<a class="anchor" id="ae46cf709e9bc887897e0d77dc15dd4dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) resetGLState </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the GL state management used by this shader program, including the values of all variables. </p>

</div>
</div>
<a class="anchor" id="a383c12d6c8195055fcb460ee6c207c32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) setDefaultShouldAllowDefaultVariableValues: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>shouldAllow</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the initial value of the shouldAllowDefaultVariableValues for each instance. </p>
<p>See the notes for the shouldAllowDefaultVariableValues property for a full discussion.</p>
<p>The initial value of this property is NO. </p>

</div>
</div>
<a class="anchor" id="a395e0062167586457f3a9430fee52bb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) setIsPreloading: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>isPreloading</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether shader programs are being pre-loaded. </p>
<p>Shader programs that are added to this cache while the value of this property is YES will be strongly cached and cannot be deallocated until specifically removed from this cache. You must manually remove any shader programs added to this cache while the value of this property is YES.</p>
<p>Shader programs that are added to this cache while the value of this property is NO will be weakly cached, and will automatically be deallocated and removed from this cache once all references to the shader program outside this cache are released.</p>
<p>If you will be loading resources such as models and textures on a background thread while the scene is running, you will find that any shader programs that are loaded while the scene is running will often create a brief, but noticable, pause in the scene while the final stages of the shader program are conmpiled and configured.</p>
<p>You can avoid this pause by pre-loading all of the shader programs that your scene will need during scene initialization. They will then automatically be recalled from this cache when needed by the models that you load mid-scene. In order for them to be available in this cache at that time, the value of this property must be set to YES for the duration of the pre-loading stage during scene initialization.</p>
<p>You can set the value of this property at any time, and can vary it between YES and NO to accomodate your specific loading patterns.</p>
<p>The initial value of this property is NO, meaning that shader programs will be weakly cached in this cache, and will automatically be removed if not used by a model. You can set this property to YES in order to pre-load shader programs that will not be immediately used in the scene, but which you wish to keep in the cache for later use. </p>

</div>
</div>
<a class="anchor" id="a2cc1b912f9ebb47a5107422d450236d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) setProgramMatcher: </td>
          <td></td>
          <td class="paramtype">(id&lt; <a class="el" href="protocol_c_c3_shader_matcher-p.html">CC3ShaderMatcher</a> &gt;)&#160;</td>
          <td class="paramname"><em>__deprecated</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000265">Deprecated:</a></b></dt><dd>Renamed to setShaderMatcher:. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e2f3ea52ff2253c8d2fd0f75d52a2f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) setShaderMatcher: </td>
          <td></td>
          <td class="paramtype">(id&lt; <a class="el" href="protocol_c_c3_shader_matcher-p.html">CC3ShaderMatcher</a> &gt;)&#160;</td>
          <td class="paramname"><em>shaderMatcher</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This property contains a helper delegate object that determines which shaders to use when rendering a particular <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>. </p>
<p>Rendering a mesh node requires a shader program. Typically, the shader program is assigned to the mesh node when the node is created or loaded from a model resource. This is either done by the resource loader, based on configuration information, or by the application directly, via the shaderProgram or shaderContext properties on the mesh node.</p>
<p>As a convenience, once a mesh node has been constructed and configured, the application can use the shader matcher in this property to retrieve a shader program suitable for rendering that node.</p>
<p>If the application does not assign a specific shader program to a mesh node, the shader matcher in this property will be accessed automatically to assign a shader program when the node is first rendered.</p>
<p>If desired, the application can set a custom shader matcher into this property. If the value of this property is not explicitly set by the application, it is lazily initialized to an instance of <a class="el" href="interface_c_c3_shader_matcher_base.html" title="CC3ShaderMatcherBase is a basic implementation of the CC3ShaderMatcher protocol. ">CC3ShaderMatcherBase</a>, the first time it is accessed. </p>

</div>
</div>
<a class="anchor" id="a2f4af0a8ec0c423821386118eb98e588"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) setShouldAutomaticallyPreloadMatchingPureColorPrograms: </td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>shouldAdd</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether this shader program cache should automatically add a matching pure-color shader program for each normal shader program that is added to this cache during shader program preloading. </p>
<p>If both this property and the isPreloading property are set to YES, the addProgram method will ensure that a matching pure-color shader program is added for each normal shader program that is added using that method.</p>
<p>If pre-loading is not active, each shader program is loaded dynamically the first time it is needed, and is added to the cache at that time. For such dynamically-loaded shader programs, the corresponding pure-color shader program will be dynamically loaded when it is needed, in turn. Typically this will be the first time node is involved in node picking as a result of a touch event.</p>
<p>The initial value of this property is YES, ensuring that a matching pure-color program will be added for each normal shader program that is added during pre-loading. Pure-color shader programs are used when rendering a node for picking from a touch-event. You should therefore leave the value of this property at its default value, unless your app does not use touch events to pick nodes. </p>

</div>
</div>
<a class="anchor" id="acd8eedf6142a9a6a2ee49fa96298f3ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (id&lt;<a class="el" href="protocol_c_c3_shader_matcher-p.html">CC3ShaderMatcher</a>&gt;) shaderMatcher </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This property contains a helper delegate object that determines which shaders to use when rendering a particular <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh. ">CC3MeshNode</a>. </p>
<p>Rendering a mesh node requires a shader program. Typically, the shader program is assigned to the mesh node when the node is created or loaded from a model resource. This is either done by the resource loader, based on configuration information, or by the application directly, via the shaderProgram or shaderContext properties on the mesh node.</p>
<p>As a convenience, once a mesh node has been constructed and configured, the application can use the shader matcher in this property to retrieve a shader program suitable for rendering that node.</p>
<p>If the application does not assign a specific shader program to a mesh node, the shader matcher in this property will be accessed automatically to assign a shader program when the node is first rendered.</p>
<p>If desired, the application can set a custom shader matcher into this property. If the value of this property is not explicitly set by the application, it is lazily initialized to an instance of <a class="el" href="interface_c_c3_shader_matcher_base.html" title="CC3ShaderMatcherBase is a basic implementation of the CC3ShaderMatcher protocol. ">CC3ShaderMatcherBase</a>, the first time it is accessed. </p>

</div>
</div>
<a class="anchor" id="a25e0a4274b3bf4622e82b2aea53b54b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) shouldAutomaticallyPreloadMatchingPureColorPrograms </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this shader program cache should automatically add a matching pure-color shader program for each normal shader program that is added to this cache during shader program preloading. </p>
<p>If both this property and the isPreloading property are set to YES, the addProgram method will ensure that a matching pure-color shader program is added for each normal shader program that is added using that method.</p>
<p>If pre-loading is not active, each shader program is loaded dynamically the first time it is needed, and is added to the cache at that time. For such dynamically-loaded shader programs, the corresponding pure-color shader program will be dynamically loaded when it is needed, in turn. Typically this will be the first time node is involved in node picking as a result of a touch event.</p>
<p>The initial value of this property is YES, ensuring that a matching pure-color program will be added for each normal shader program that is added during pre-loading. Pure-color shader programs are used when rendering a node for picking from a touch-event. You should therefore leave the value of this property at its default value, unless your app does not use touch events to pick nodes. </p>

</div>
</div>
<a class="anchor" id="ad446ecec5c07d5f587209a70ea49febe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a>*) uniformAtLocation: </td>
          <td></td>
          <td class="paramtype">(GLint)&#160;</td>
          <td class="paramname"><em>uniformLocation</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uniform at the specified location, or nil if no uniform is defined at the specified location. </p>

</div>
</div>
<a class="anchor" id="a6e1ea69459fa7a2779257880231655a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a>*) uniformForSemantic: </td>
          <td></td>
          <td class="paramtype">(GLenum)&#160;</td>
          <td class="paramname"><em>semantic</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uniform with the specified semantic at index zero, or nil if no uniform is defined for the specified semantic. </p>

</div>
</div>
<a class="anchor" id="ae65f97854b028611dcf49aada81c94ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a>*) <a class="el" href="interface_c_c3_shader_program.html#a6e1ea69459fa7a2779257880231655a0">uniformForSemantic:</a> </td>
          <td></td>
          <td class="paramtype">(GLenum)&#160;</td>
          <td class="paramname"><em>semantic</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>semanticIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uniform with the specified semantic and index, or nil if no uniform is defined for the specified semantic. </p>

</div>
</div>
<a class="anchor" id="af6d4001e68a75cf6aee271c24dddcb3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_g_l_s_l_uniform.html">CC3GLSLUniform</a>*) uniformNamed: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"><em>name</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uniform with the specified name, or nil if no uniform is defined for the specified name. </p>

</div>
</div>
<a class="anchor" id="a0c5131c009efb61c818f2e4beeca86b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) willBeginDrawingScene </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoked automatically at the beginning of scene rendering. </p>
<p>Invokes the markSceneScopeDirty method to mark the scene scope variables as dirty and in need of re-populating. </p>

</div>
</div>
<a class="anchor" id="a0c5131c009efb61c818f2e4beeca86b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) willBeginDrawingScene </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoked to indicate that scene drawing is about to begin. </p>
<p>This method invokes the same method on each instance in the cache. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="ad9ecf69ab880895a4fb0dfb1a5891913"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) attributeCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of vertex attributes declared and in use by this program. </p>

</div>
</div>
<a class="anchor" id="acba97cbb02900e65d6e9cc34c3be22c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray*) attributes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only array of the GLSL attributes declared and used by this shader program. </p>

</div>
</div>
<a class="anchor" id="aa74ef8ec4f86a3195b1c4e6de6b97329"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_fragment_shader.html">CC3FragmentShader</a>*) fragmentShader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The fragment shader used by this program. </p>
<p>Normally this property is set during initialization. If you set this property directly, you must invoke the link method, and optionally, the prewarm method, once both shaders have been set via this property and the vertexShader property. </p>

</div>
</div>
<a class="anchor" id="a3356a292b20659d69bc47f88b8002037"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLint) maxAttributeNameLength</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the largest attribute name in this program. </p>

</div>
</div>
<a class="anchor" id="a0502d0ba9cb068d66be2b6bbbc48adce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLint) maxUniformNameLength</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the largest uniform name in this program. </p>

</div>
</div>
<a class="anchor" id="ada2ba7c96585e86173449cd82e570b3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) programID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the GL program ID. </p>

</div>
</div>
<a class="anchor" id="a0d3f504494be555339ca75503203dcc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (id&lt;<a class="el" href="protocol_c_c3_shader_semantics_delegate-p.html">CC3ShaderSemanticsDelegate</a>&gt;) semanticDelegate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On each render loop, this <a class="el" href="interface_c_c3_shader_program.html" title="CC3ShaderProgram represents an OpenGL shader program, containing one vertex shader and one fragment s...">CC3ShaderProgram</a> delegates to this object to populate the current value of each uniform variable from content within the 3D scene. </p>
<p>This property must be set prior to the program being compiled. </p>

</div>
</div>
<a class="anchor" id="a96ce2a2eb24e7a50d895b7ec28f8575f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldAllowDefaultVariableValues</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each uniform used by this shader program must have a valid value. </p>
<p>This property can be used to indicate whether a uniform, whose value cannot be determined, will use its standard default value.</p>
<p>If the value of this property is YES, and the value of a uniform has not been set via either a semantic mapping, or a uniform override in the shader context in a mesh node, a default value will be used for the variable. The default value depends on the variable type. It will be zero for scalars, (0,0,0,1) for vectors, or an identity matrix for matrices.</p>
<p>If the value of this property is NO, and the value of a uniform has not been set via either a semantic mapping, or a uniform override in the shader context in a mesh node, an assertion error will be raised. This ensures that unexpected missing uniform variables are detected directly and early in the development cycle.</p>
<p>The initial value of this property is determined by the value of the class-side defaultShouldAllowDefaultVariableValues property. By default, this will be NO, indicating that an assertion error will be raised if the value of a uniform cannot be determined. </p>

</div>
</div>
<a class="anchor" id="a1b7828cd1dda8fdaafaf443610ee3354"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) texture2DCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of 2D textures supported by this shader program. </p>

</div>
</div>
<a class="anchor" id="a94b146598259db46ae1a66af25487afb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) texture2DStart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the texture unit index of the first 2D texture supported by this shader program. </p>
<p>The 2D textures are allocated consecutive texture units beginning at the returned texture unit. </p>

</div>
</div>
<a class="anchor" id="acf02132d7472e8c3593c8819255d7fe4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) textureCubeCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of cube-map textures supported by this shader program. </p>

</div>
</div>
<a class="anchor" id="aea35cf53dce9cd9255ba13ad8b7d5790"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) textureCubeStart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the texture unit index of the first cube texture supported by this shader program. </p>
<p>The cube textures are allocated consecutive texture units beginning at the returned texture unit. </p>

</div>
</div>
<a class="anchor" id="a53259facb086f9914ed0f533e0783972"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) textureLightProbeCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of light probe textures supported by this shader program. </p>

</div>
</div>
<a class="anchor" id="af4956267fc3f25a8e242d37d4125cba3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) textureLightProbeStart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the texture unit index of the first light probe texture supported by this shader program. </p>
<p>The light probe textures are allocated consecutive texture units beginning at the returned texture unit. </p>

</div>
</div>
<a class="anchor" id="a38c2283c6d35fa647681c7efd10be49b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) uniformCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of uniforms declared and in use by this program. </p>

</div>
</div>
<a class="anchor" id="a2a85a37b10306924eebfdc831454f197"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray*) uniforms</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only array of the GLSL uniforms declared and used by this shader program. </p>

</div>
</div>
<a class="anchor" id="aa74e7c727e2a1e08fdf6809bedf85f1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (GLuint) uniformStorageElementCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of memory storage elements consumed by the uniform variables used by this program. </p>

</div>
</div>
<a class="anchor" id="ae8ec1cf13438ea304c24c6a39ca76912"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_vertex_shader.html">CC3VertexShader</a>*) vertexShader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">retain</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The vertex shader used by this program. </p>
<p>Normally this property is set during initialization. If you set this property directly, you must invoke the link method, and optionally, the prewarm method, once both shaders have been set via this property and the fragmentShader property. </p>

</div>
</div>
<a class="anchor" id="a8e30736ee50d08fbaea568dd99107196"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) wasLoadedFromFile</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this shader program was loaded from files. </p>
<p>Returns YES if both the vertex and fragment shaders were loaded from files, otherwise returns NO. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_c_c3_shaders_8h.html">CC3Shaders.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<address class="footer">
<p class="footer"/>© 2010 - 2014 The Brenwill Workshop Ltd.</p>
</address>
</body>
</html>
