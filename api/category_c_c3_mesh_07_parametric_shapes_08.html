<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Cocos3D: CC3Mesh(ParametricShapes) Category Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cocos3D
   &#160;<span id="projectnumber">2.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="category_c_c3_mesh_07_parametric_shapes_08-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CC3Mesh(ParametricShapes) Category Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#import &lt;CC3ParametricMeshes.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:acc48788e518515bb85d9607546eee23b"><td class="memItemLeft" align="right" valign="top">(GLushort *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#acc48788e518515bb85d9607546eee23b">allocateIndexedTriangles:</a></td></tr>
<tr class="separator:acc48788e518515bb85d9607546eee23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad828d0d73dd2aca5da2abab520ae6f40"><td class="memItemLeft" align="right" valign="top">(<a class="el" href="struct_c_c3_textured_vertex.html">CC3TexturedVertex</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#ad828d0d73dd2aca5da2abab520ae6f40">allocateTexturedVertices:</a></td></tr>
<tr class="separator:ad828d0d73dd2aca5da2abab520ae6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd98fc4ffd062e375c4e7d6f89b1ffe"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a1fd98fc4ffd062e375c4e7d6f89b1ffe">ensureVertexContent</a></td></tr>
<tr class="separator:a1fd98fc4ffd062e375c4e7d6f89b1ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bd5a646995672c1fe27a5b0c54df1d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a98bd5a646995672c1fe27a5b0c54df1d">populateAsCenteredRectangleWithSize:</a></td></tr>
<tr class="separator:a98bd5a646995672c1fe27a5b0c54df1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac516a0e20127107db00247a6eb37b06e"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#ac516a0e20127107db00247a6eb37b06e">populateAsCenteredRectangleWithSize:andTessellation:</a></td></tr>
<tr class="separator:ac516a0e20127107db00247a6eb37b06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a12aee31ef691ea699cb7565c8dcb9"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a87a12aee31ef691ea699cb7565c8dcb9">populateAsCubeMappedSolidBox:</a></td></tr>
<tr class="separator:a87a12aee31ef691ea699cb7565c8dcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276591a31024060be5166bb48dd98307"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a276591a31024060be5166bb48dd98307">populateAsDiskWithRadius:andTessellation:</a></td></tr>
<tr class="separator:a276591a31024060be5166bb48dd98307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa647f1105acb757f3c30de865559f67"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#aaa647f1105acb757f3c30de865559f67">populateAsHollowConeWithRadius:height:andTessellation:</a></td></tr>
<tr class="separator:aaa647f1105acb757f3c30de865559f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5aab8b6ab6777b50c564816d14d86a"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#acc5aab8b6ab6777b50c564816d14d86a">populateAsLineStripWith:vertices:andRetain:</a></td></tr>
<tr class="separator:acc5aab8b6ab6777b50c564816d14d86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb889980907f2a86b8e6557807c73cd"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a8cb889980907f2a86b8e6557807c73cd">populateAsRectangleWithSize:andRelativeOrigin:</a></td></tr>
<tr class="separator:a8cb889980907f2a86b8e6557807c73cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8619cf9746d7b4b8f39d11952720773f"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a8619cf9746d7b4b8f39d11952720773f">populateAsRectangleWithSize:andRelativeOrigin:andTessellation:</a></td></tr>
<tr class="separator:a8619cf9746d7b4b8f39d11952720773f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3839f11d94d436961ae959bbaed4e89"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#ae3839f11d94d436961ae959bbaed4e89">populateAsSolidBox:</a></td></tr>
<tr class="separator:ae3839f11d94d436961ae959bbaed4e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb56e8d12756fa43e6e59b8d12092d6"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#abcb56e8d12756fa43e6e59b8d12092d6">populateAsSolidBox:withCorner:</a></td></tr>
<tr class="separator:abcb56e8d12756fa43e6e59b8d12092d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7733df5e671cae7d60369862c79b86d"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#af7733df5e671cae7d60369862c79b86d">populateAsSphereWithRadius:andTessellation:</a></td></tr>
<tr class="separator:af7733df5e671cae7d60369862c79b86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadca0656abb5e235ba0eb2e2727e12de"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#aadca0656abb5e235ba0eb2e2727e12de">populateAsTriangle:withTexCoords:andTessellation:</a></td></tr>
<tr class="separator:aadca0656abb5e235ba0eb2e2727e12de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f12125bc3e8bddf96dd852e46588abe"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="category_c_c3_mesh_07_parametric_shapes_08.html#a8f12125bc3e8bddf96dd852e46588abe">populateAsWireBox:</a></td></tr>
<tr class="separator:a8f12125bc3e8bddf96dd852e46588abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a> extension adds a number of methods for populating the mesh of a mesh programatically to create various parametric shapes and surfaces. </p>
<p>To use the methods in this extension, instantiate a <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode. ">CC3Mesh</a>, and then invoke one of the methods in this extension to populate the mesh vertices. </p>
</div><h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="acc48788e518515bb85d9607546eee23b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (GLushort*) allocateIndexedTriangles: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>triangleCount</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000073">Deprecated:</a></b></dt><dd>Use allocatedVertexIndexCapacity = (triangleCount * 3) instead. </dd></dl>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#acc48788e518515bb85d9607546eee23b">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="ad828d0d73dd2aca5da2abab520ae6f40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="struct_c_c3_textured_vertex.html">CC3TexturedVertex</a>*) allocateTexturedVertices: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexCount</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000072">Deprecated:</a></b></dt><dd>Use the vertexContentTypes property, followed by the allocatedVertexCapacity property, instead. You can also use the prepareParametricMesh method to automatically established textured vertices if the vertexContentTypes property has not been set. </dd></dl>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#ad828d0d73dd2aca5da2abab520ae6f40">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="a1fd98fc4ffd062e375c4e7d6f89b1ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) ensureVertexContent </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that this mesh has vertexContentType defined. </p>
<p>This method is invoked by each of the populateAs... family of methods, prior to populating the mesh contents.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking any of the populateAs... family of methods, to define the content type for each vertex.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate). and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If you do not need either of the normal or texture coordinates, set the vertexContentTypes property accordingly prior to invoking any of the populateAs... methods. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#a1fd98fc4ffd062e375c4e7d6f89b1ffe">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="a98bd5a646995672c1fe27a5b0c54df1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsCenteredRectangleWithSize: </td>
          <td></td>
          <td class="paramtype">(CGSize)&#160;</td>
          <td class="paramname"><em>rectSize</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, centered at the origin, and laid out on the X-Y plane. </p>
<p>The rectangular mesh contains only one face with two triangles. The result is the same as invoking populateAsCenteredRectangleWithSize:andTessellation: with the divsPerAxis argument set to {1,1}.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#a98bd5a646995672c1fe27a5b0c54df1d">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="ac516a0e20127107db00247a6eb37b06e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsCenteredRectangleWithSize: </td>
          <td></td>
          <td class="paramtype">(CGSize)&#160;</td>
          <td class="paramname"><em>rectSize</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_foundation_8h.html#a1755badfebb13f118a6acef2c3e2543b">CC3Tessellation</a>)&#160;</td>
          <td class="paramname"><em>divsPerAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, centered at the origin, and laid out on the X-Y plane. </p>
<p>The large rectangle can be divided into many smaller divisions. Building a rectanglular surface from more than one division can dramatically improve realism when the surface is illuminated with specular lighting or a tightly focused spotlight, because increasing the face count increases the number of vertices that interact with the specular or spot lighting.</p>
<p>The divsPerAxis argument indicates how to break this large rectangle into multiple faces. The X &amp; Y elements of the divsPerAxis argument indicate how each axis if the rectangle should be divided into faces. The total number of faces in the rectangle will therefore be the multiplicative product of the X &amp; Y elements of the divsPerAxis argument.</p>
<p>For example, a value of {5,5} for the divsPerAxis argument will result in the rectangle being divided into 25 faces, arranged into a 5x5 grid.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#ac516a0e20127107db00247a6eb37b06e">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="a87a12aee31ef691ea699cb7565c8dcb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsCubeMappedSolidBox: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_box.html">CC3Box</a>)&#160;</td>
          <td class="paramname"><em>box</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular box mesh from the specified bounding box, which contains two of the diagonal corners of the box. </p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If a texture is to be wrapped around this mesh, since the single texture is wrapped around all six sides of the box, the texture will be mapped according to the layout illustrated in the texture file BoxTexture.png, included in the distribution.</p>
<p>The "front" of the box is the side that faces towards the positive-Z axis, the "top" of the box is the side that faces towards the positive-Y axis, and the "right" side of the box is the side that faces towards the positive-X axis.</p>
<p>For the purposes of wrapping the texture around the box, this method assumes that the texture is an unfolded cube. The box can be created with any relative dimensions, but if it is not a cube, the texture may appear stretched or shrunk on two or more sides. The texture will still fully wrap all six sides of the box, but the texture is stretched or shrunk to fit each side according to its dimension relative to the other sides. The appearance will be as if you had started with a textured cube and then pulled one or two of the dimensions out further.</p>
<p>For higher fidelity in applying textures to non-cube boxes, so that the texture will not be stretched to fit, use either of the populateAsSolidBox: or populateAsSolidBox:withCorner: methods, with a texture whose layout is compatible with the aspect ratio of the box.</p>
<p>Thanks to Cocos3D user andyman for contributing the prototype code and texture template file for this method. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#a87a12aee31ef691ea699cb7565c8dcb9">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="a276591a31024060be5166bb48dd98307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsDiskWithRadius: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>radius</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_foundation_8h.html#a1755badfebb13f118a6acef2c3e2543b">CC3Tessellation</a>)&#160;</td>
          <td class="paramname"><em>radialAndAngleDivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a flat, single-sided circular disk mesh of the specified radius, centered at the origin, and laid out on the X-Y plane. </p>
<p>The surface of the disk is divided into many smaller divisions, both in the radial and angular dimensions.</p>
<p>The radialAndAngleDivs argument indicates how to divide the surface of the disks into divisions. The X element of the radialAndAngleDivs argument indicates how many radial divisions will occur from the center and the circuferential edge. A value of one means that the mesh will consist of a series of radial triangles from the center of the circle to the edge. A larger value for the X element of the radialAndAngleDivs argument will structure the mesh as a series of concentric rings. This value must be at least one.</p>
<p>The Y element of the radialAndAngleDivs argument indicates how many angular divisions will occur around the circumference. This value must be at least three, which will essentially render the circle as a triangle. But, typically, this value will be larger.</p>
<p>For example, a value of {4,24} for the radialAndAngleDivs argument will result in the disk being divided into four concentric rings, each divided into 24 segments around the circumference of the circle.</p>
<p>Each segement, except those in the innermost disk is trapezoidal, and will be constructed from two triangular mesh faces. Therefore, the number of triangles in the mesh will be (2X - 1) * Y, where X = radialAndAngleDivs.x and Y = radialAndAngleDivs.y.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The texture is mapped to the tessellated disk as if a tagential square was overlaid over the circle, starting from the lower left corner, where both X and Y are at a minimum. The center of the disk maps to the center of the texture.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#a276591a31024060be5166bb48dd98307">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="aaa647f1105acb757f3c30de865559f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsHollowConeWithRadius: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>radius</em></td>
        </tr>
        <tr>
          <td class="paramkey">height:</td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>height</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_foundation_8h.html#a1755badfebb13f118a6acef2c3e2543b">CC3Tessellation</a>)&#160;</td>
          <td class="paramname"><em>angleAndHeightDivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a conical mesh of the specified radius and height. </p>
<p>The mesh is constructed so that the base of the cone is centered on the origin of the X-Z plane, and the apex is on the positive Y-axis at the specified height. The cone is open and does not have a bottom.</p>
<p>The surface of the cone is divided into many smaller divisions, as specified by the angleAndHeightsDivs parameter. The X-coordinate of this parameter indicates how many angular divisions are created around the circumference of the base, and the Y-coordinate of this parameter indicates how many vertical divisions are created between the base and the apex.</p>
<p>For example, a value of {12,8} for the angleAndHeightsDivs parameter will result in a cone with 12 divisions around the circumference of the base, and 8 divisions along the Y-axis to the apex.</p>
<p>By reducing the number of angular divisions to 3 or 4, you can use this method to create a tetrahedron or square pyramid, respectively.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate). and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If a texture is applied to this mesh, it is mapped to the cone with a simple horizontal projection. Horizontal lines in the texture will remain parallel, but vertical lines will converge at the apex. Texture wrapping begins at the negative Z-axis, so the center of the texture will be positioned at the point where the cone intersects the positive Z-axis, and the conceptual seam (where the left and right edges of the texture are stitched together) will occur where the cone intersects the negative-Z axis. This texture orientation means that the center of the texture will face the forwardDirection of the cone node. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#aaa647f1105acb757f3c30de865559f67">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="acc5aab8b6ab6777b50c564816d14d86a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsLineStripWith: </td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>vertexCount</em></td>
        </tr>
        <tr>
          <td class="paramkey">vertices:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> *)&#160;</td>
          <td class="paramname"><em>vertices</em></td>
        </tr>
        <tr>
          <td class="paramkey">andRetain:</td>
          <td></td>
          <td class="paramtype">(BOOL)&#160;</td>
          <td class="paramname"><em>shouldRetainVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a line strip with the specified number of vertex points. </p>
<p>The data for the points that define the end-points of the lines are contained within the specified vertices array. The vertices array must contain at least vertexCount elements.</p>
<p>The lines are specified and rendered as a strip, where each line is connected to the previous and following lines. Each line starts at the point where the previous line ended, and that point is defined only once in the vertices array. Therefore, the number of lines drawn is equal to one less than the specified vertexCount.</p>
<p>The shouldRetainVertices flag indicates whether the data in the vertices array should be retained by this instance. If this flag is set to YES, the data in the vertices array will be copied to an internal array that is managed by this instance. If this flag is set to NO, the data is not copied internally and, instead, a reference to the vertices data is established. In this case, it is up to you to manage the lifespan of the data contained in the vertices array.</p>
<p>If you are defining the vertices data dynamically in another method, you may want to set this flag to YES to have this instance copy and manage the data. If the vertices array is a static array, you can set this flag to NO.</p>
<p>This is a convenience method for creating a simple, but useful, shape. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#acc5aab8b6ab6777b50c564816d14d86a">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="a8cb889980907f2a86b8e6557807c73cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsRectangleWithSize: </td>
          <td></td>
          <td class="paramtype">(CGSize)&#160;</td>
          <td class="paramname"><em>rectSize</em></td>
        </tr>
        <tr>
          <td class="paramkey">andRelativeOrigin:</td>
          <td></td>
          <td class="paramtype">(CGPoint)&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, with the specified relative origin, and laid out on the X-Y plane. </p>
<p>The rectangular mesh contains only one face with two triangles. The result is the same as invoking the populateAsRectangleWithSize:andRelativeOrigin:andTessellation: with the divsPerAxis argument set to {1,1}.</p>
<p>The relative origin is a fractional point that is relative to the rectangle's extent, and indicates where the origin of the rectangular mesh is to be located. The mesh origin is the origin of the local coordinate system of the mesh, and is the basis for all transforms applied to the mesh (including the location and rotation properties).</p>
<p>The specified relative origin should be a fractional value. If it is {0, 0}, the rectangle will be laid out so that the bottom-left corner is at the origin. If it is {1, 1}, the rectangle will be laid out so that the top-right corner of the rectangle is at the origin. If it is {0.5, 0.5}, the rectangle will be laid out with the origin at the center, as in the populateAsCenteredRectangleWithSize: method.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#a8cb889980907f2a86b8e6557807c73cd">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="a8619cf9746d7b4b8f39d11952720773f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsRectangleWithSize: </td>
          <td></td>
          <td class="paramtype">(CGSize)&#160;</td>
          <td class="paramname"><em>rectSize</em></td>
        </tr>
        <tr>
          <td class="paramkey">andRelativeOrigin:</td>
          <td></td>
          <td class="paramtype">(CGPoint)&#160;</td>
          <td class="paramname"><em>origin</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_foundation_8h.html#a1755badfebb13f118a6acef2c3e2543b">CC3Tessellation</a>)&#160;</td>
          <td class="paramname"><em>divsPerAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, with the specified relative origin, and laid out on the X-Y plane. </p>
<p>The large rectangle can be divided into many smaller divisions. Building a rectanglular surface from more than one division can dramatically improve realism when the surface is illuminated with specular lighting or a tightly focused spotlight, because increasing the face count increases the number of vertices that interact with the specular or spot lighting.</p>
<p>The divsPerAxis argument indicates how to break this large rectangle into multiple faces. The X &amp; Y elements of the divsPerAxis argument indicate how each axis if the rectangle should be divided into faces. The total number of faces in the rectangle will therefore be the multiplicative product of the X &amp; Y elements of the divsPerAxis argument.</p>
<p>For example, a value of {5,5} for the divsPerAxis argument will result in the rectangle being divided into 25 faces, arranged into a 5x5 grid.</p>
<p>The relative origin is a fractional point that is relative to the rectangle's extent, and indicates where the origin of the rectangular mesh is to be located. The mesh origin is the origin of the local coordinate system of the mesh, and is the basis for all transforms applied to the mesh (including the location and rotation properties).</p>
<p>The specified relative origin should be a fractional value. If it is {0, 0}, the rectangle will be laid out so that the bottom-left corner is at the origin. If it is {1, 1}, the rectangle will be laid out so that the top-right corner of the rectangle is at the origin. If it is {0.5, 0.5}, the rectangle will be laid out with the origin at the center, as in the populateAsCenteredRectangleWithSize: method.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#a8619cf9746d7b4b8f39d11952720773f">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="ae3839f11d94d436961ae959bbaed4e89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsSolidBox: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_box.html">CC3Box</a>)&#160;</td>
          <td class="paramname"><em>box</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular box mesh from the specified bounding box, which contains two of the diagonal corners of the box. </p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If a texture is to be wrapped around this mesh, since the single texture is wrapped around all six sides of the box, the texture will be mapped according to the layout illustrated in the texture file BoxTexture.png, included in the distribution.</p>
<p>The "front" of the box is the side that faces towards the positive-Z axis, the "top" of the box is the side that faces towards the positive-Y axis, and the "right" side of the box is the side that faces towards the positive-X axis.</p>
<p>For the purposes of wrapping a texture around the box, the texture will wrap uniformly around all sides, and the texture will not appear stretched between any two adjacent sides. This is useful when you are texturing the box with a simple rectangular repeating pattern and want the texture to appear consistent across the sides, for example, a brick pattern wrapping around all four sides of a house.</p>
<p>Depending on the relative aspect of the height and width of the box, the texture may appear distorted horizontal or vertically. If you need to correct that, you can use the repeatTexture: method, and adjust one of the dimensions.</p>
<p>For higher fidelity in applying textures to non-cube boxes, so that the texture will not be stretched to fit, use the populateAsSolidBox:withCorner: method.</p>
<p>Thanks to Cocos3D user andyman for contributing the prototype code and texture template file for this method. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#ae3839f11d94d436961ae959bbaed4e89">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="abcb56e8d12756fa43e6e59b8d12092d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsSolidBox: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_box.html">CC3Box</a>)&#160;</td>
          <td class="paramname"><em>box</em></td>
        </tr>
        <tr>
          <td class="paramkey">withCorner:</td>
          <td></td>
          <td class="paramtype">(CGPoint)&#160;</td>
          <td class="paramname"><em>corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple rectangular box mesh from the specified bounding box, which contains two of the diagonal corners of the box, and configures the mesh texture coordinates so that the entire box can be wrapped in a single texture. </p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If a texture is to be wrapped around this mesh, since the single texture is wrapped around all six sides of the box, the texture will be mapped according to the layout illustrated in the texture file BoxTexture.png, included in the distribution.</p>
<p>The "front" of the box is the side that faces towards the positive-Z axis, the "top" of the box is the side that faces towards the positive-Y axis, and the "right" side of the box is the side that faces towards the positive-X axis.</p>
<p>For the purposes of wrapping the texture around the box, the corner argument specifies the relative point in the texture that will map to the corner of the box that is at the juncture of the "left", "front" and "bottom" sides (see the BoxTexture.png image for a better understanding of this point). The corner argument is specified as a fraction in each of the S &amp; T dimensions of the texture. In the CGPoint that specifies the corner, the x &amp; y elements of the CGPoint correspond to the S &amp; T dimensions of this left-front-bottom corner mapping, with each value being between zero and one.</p>
<p>Since, by definition, opposite sides of the box have the same dimensions, this single corner point identifies the S &amp; T dimensions of all six of the sides of the box. A value of (1/4, 1/3) for the corner is used when the box is a cube. A smaller value for the x-element would move the corner to the left in the texture layout, indicating that the left and right sides are shallower than they are in a cube, and that the front and back are wider than in a cube, and vice-versa for a larger value in the x-element of the corner. Similarly for the y-element. A y-element that is smaller than 1/3, moves the corner point downwards on the texture, indicating that the bottom and top are shallower than they are in a cube, or that the front and back are higher than they are in a cube.</p>
<p>The two axes defined by the corner are interrelated, because the sides need to be the same depth as the top and bottom. The best way to determine the values to use in the corner is to use the measure of this point (where the "left", "front", and "bottom" sides meet) from the layout of the texture. If the aspect of the corner on the texture does not align with the aspect of the width, height and depth of the box, the texture will appear stretched on one or two sides relative to the others.</p>
<p>Thanks to Cocos3D user andyman for contributing the prototype code and texture template file for this method. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#abcb56e8d12756fa43e6e59b8d12092d6">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="af7733df5e671cae7d60369862c79b86d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsSphereWithRadius: </td>
          <td></td>
          <td class="paramtype">(GLfloat)&#160;</td>
          <td class="paramname"><em>radius</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="_c_c3_foundation_8h.html#a1755badfebb13f118a6acef2c3e2543b">CC3Tessellation</a>)&#160;</td>
          <td class="paramname"><em>divsPerAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a spherical mesh of the specified radius, centered at the origin. </p>
<p>The surface of the sphere is divided into many smaller divisions, similar to latitude and longtitude divisions. The sphere mesh contains two poles, where the surface intersects the positive and negative Y-axis.</p>
<p>The divsPerAxis argument indicates how to divide the surface of the sphere into divisions. The X element of the divsPerAxis argument indicates how many longtitude divisions will occur around one circumnavigation of the equator. The Y element of the divsPerAxis argument indicates how many latitude divisions will occur between the north pole and the south pole.</p>
<p>For example, a value of {12,8} for the divsPerAxis argument will result in the sphere being divided into twelve divisions of longtitude around the equator, and eight divisions of latitude between the north and south poles.</p>
<p>Except at the poles, each division is roughly trapezoidal and is drawn as two triangles. At the poles, each division is a single triangle.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate). and the mesh will be populated with location, normal and texture coordinates for each vertex.</p>
<p>If a texture is applied to this mesh, it is mapped to the sphere with a simple cylindrical projection around the equator (similar to Mercator projection without the north-south stretching). This type of projection is typical of maps of the earth taken from space, and results in the smooth curving of any texture around the sphere from the equator to the poles. Texture wrapping begins at the negative Z-axis, so the center of the texture will be positioned at the point where the sphere intersects the positive Z-axis, and the conceptual seam (where the left and right edges of the texture are stitched together) will occur where the sphere intersects the plane (X = 0) along the negative-Z axis. This texture orientation means that the center of the texture will face the forwardDirection of the sphere node. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#af7733df5e671cae7d60369862c79b86d">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="aadca0656abb5e235ba0eb2e2727e12de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsTriangle: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_face.html">CC3Face</a>)&#160;</td>
          <td class="paramname"><em>face</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTexCoords:</td>
          <td></td>
          <td class="paramtype">(ccTex2F *)&#160;</td>
          <td class="paramname"><em>texCoords</em></td>
        </tr>
        <tr>
          <td class="paramkey">andTessellation:</td>
          <td></td>
          <td class="paramtype">(GLuint)&#160;</td>
          <td class="paramname"><em>divsPerSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a simple triangular mesh. </p>
<p>The specified face defines the three vertices at the corners of the triangular mesh in 3D space. The vertices within the <a class="el" href="struct_c_c3_face.html" title="Defines a triangular face of the mesh, comprised of three vertices, stored in winding order...">CC3Face</a> structure are specified in the winding order of the triangular face. The winding order of the specified face determines the winding order of the vertices in the mesh, and the direction of the normal vector applied to each of the vertices. Since the resulting triangular mesh is flat, all vertices will have the same normal vector.</p>
<p>Although the triangle can be created with the corners can be anywhere in 3D space, for simplicity of construction, it is common practice, when using this method, to specify the mesh in the X-Y plane (where all three corners have a zero Z-component), and then rotate the node containing this mesh to an orientation in 3D space.</p>
<p>The texCoords parameter is an array of ccTex2F structures, providing the texture coordinates for the cooresponding vertices of the face. This array must have three elements, one for each vertex in the specified face. If the mesh will not be covered with a texture, you can pass in any values in the elements of this array.</p>
<p>The tessellation property determines how the mesh will be tessellated into smaller faces. The specified tessellation value indicates how many divisions each side of the main triangle should be divided into. Each side of the triangular mesh is tessellated into the same number of divisions.</p>
<p>This mesh can be covered with a solid material or a single texture. If this mesh is to be covered with a texture, use the texture property of this mesh to set the texture. If a solid color is desired, leave the texture property unassigned.</p>
<p>The vertexContentType property of this mesh may be set prior to invoking this method, to define the content type for each vertex. Content types kCC3VertexContentLocation, kCC3VertexContentNormal, and kCC3VertexContentTextureCoordinate are populated by this method.</p>
<p>If the vertexContentType property has not already been set, that property is set to a value of (kCC3VertexContentLocation | kCC3VertexContentNormal | kCC3VertexContentTextureCoordinate), and the mesh will be populated with location, normal and texture coordinates for each vertex. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#aadca0656abb5e235ba0eb2e2727e12de">CC3Mesh</a>.</p>

</div>
</div>
<a class="anchor" id="a8f12125bc3e8bddf96dd852e46588abe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) populateAsWireBox: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="struct_c_c3_box.html">CC3Box</a>)&#160;</td>
          <td class="paramname"><em>box</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates this instance as a wire-frame box with the specified dimensions. </p>
<p>This is a convenience method for creating a simple, but useful, shape. </p>

<p>Extends class <a class="el" href="interface_c_c3_mesh.html#a8f12125bc3e8bddf96dd852e46588abe">CC3Mesh</a>.</p>

</div>
</div>
<hr/>The documentation for this category was generated from the following file:<ul>
<li><a class="el" href="_c_c3_parametric_meshes_8h.html">CC3ParametricMeshes.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 19 2014 21:44:20 for Cocos3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
