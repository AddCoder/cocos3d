<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Cocos3D: CC3Layer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cocos3D
   &#160;<span id="projectnumber">2.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Instance Methods</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_c_c3_layer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CC3Layer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#import &lt;CC3Layer.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3Layer:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_layer__inherit__graph.png" border="0" usemap="#_c_c3_layer_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_layer_inherit__map" id="_c_c3_layer_inherit__map">
<area shape="rect" id="node2" href="interface_c_c_layer.html" title="CCLayer" alt="" coords="9,80,84,107"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Instance Methods</h2></td></tr>
<tr class="memitem:a8afbcb73e6997deb48f899a516684a96"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_layer.html#a8afbcb73e6997deb48f899a516684a96">cc3AddGestureRecognizer:</a></td></tr>
<tr class="separator:a8afbcb73e6997deb48f899a516684a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1bd320237e85a27f0a29c6629369b6"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_layer.html#a7c1bd320237e85a27f0a29c6629369b6">cc3RemoveAllGestureRecognizers</a></td></tr>
<tr class="separator:a7c1bd320237e85a27f0a29c6629369b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1b0305c4177c197bff0946b0cd347"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_layer.html#aa0c1b0305c4177c197bff0946b0cd347">cc3RemoveGestureRecognizer:</a></td></tr>
<tr class="separator:aa0c1b0305c4177c197bff0946b0cd347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cea9c3c3a1c0a4f144403cbb2f84ed0"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_layer.html#a5cea9c3c3a1c0a4f144403cbb2f84ed0">contentSizeChanged</a></td></tr>
<tr class="separator:a5cea9c3c3a1c0a4f144403cbb2f84ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8142f0b21a278e74bb2ec2ab067d6007"><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_layer.html#a8142f0b21a278e74bb2ec2ab067d6007">handleTouchType:at:</a></td></tr>
<tr class="separator:a8142f0b21a278e74bb2ec2ab067d6007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd20963bf8a354addd7005eda1671da"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_layer.html#a0dd20963bf8a354addd7005eda1671da">initializeControls</a></td></tr>
<tr class="separator:a0dd20963bf8a354addd7005eda1671da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87816429323280209f0c657d031ec67"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_layer.html#ab87816429323280209f0c657d031ec67">onCloseCC3Layer</a></td></tr>
<tr class="separator:ab87816429323280209f0c657d031ec67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ae70be891b41519398b6e544dd8a80"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_layer.html#a57ae70be891b41519398b6e544dd8a80">onOpenCC3Layer</a></td></tr>
<tr class="separator:a57ae70be891b41519398b6e544dd8a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8605dd4b368c155d31d420499bf2904c"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_layer.html#a8605dd4b368c155d31d420499bf2904c">update:</a></td></tr>
<tr class="separator:a8605dd4b368c155d31d420499bf2904c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202b859f691d1671992aae0962e7978b"><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_c_c3_layer.html#a202b859f691d1671992aae0962e7978b">updateViewport</a></td></tr>
<tr class="separator:a202b859f691d1671992aae0962e7978b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a831905cd3956597a4bfe296627d2e19c"><td class="memItemLeft" align="right" valign="top">NSArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_layer.html#a831905cd3956597a4bfe296627d2e19c">cc3GestureRecognizers</a></td></tr>
<tr class="separator:a831905cd3956597a4bfe296627d2e19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74c2263a40e0875aca62fedff9e1bb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_scene.html">CC3Scene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_layer.html#ac74c2263a40e0875aca62fedff9e1bb0">cc3Scene</a></td></tr>
<tr class="separator:ac74c2263a40e0875aca62fedff9e1bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d18133292db46f1c81b29153e48850"><td class="memItemLeft" align="right" valign="top">Class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_layer.html#a70d18133292db46f1c81b29153e48850">cc3SceneClass</a></td></tr>
<tr class="separator:a70d18133292db46f1c81b29153e48850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f751a4559cfe48171cdd58008f3f27f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_layer.html#a4f751a4559cfe48171cdd58008f3f27f">renderStreamGroupMarker</a></td></tr>
<tr class="separator:a4f751a4559cfe48171cdd58008f3f27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ea5dd275d896a803782f109b435d5b"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_layer.html#a68ea5dd275d896a803782f109b435d5b">shouldAlwaysUpdateViewport</a></td></tr>
<tr class="separator:a68ea5dd275d896a803782f109b435d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c048c65b3e00ea9d68a60734fc5308"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_layer.html#ab7c048c65b3e00ea9d68a60734fc5308">shouldTrackViewSize</a></td></tr>
<tr class="separator:ab7c048c65b3e00ea9d68a60734fc5308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ded59a12b1643c859e15bfe2238efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_scene_drawing_surface_manager.html">CC3SceneDrawingSurfaceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_layer.html#a26ded59a12b1643c859e15bfe2238efc">surfaceManager</a></td></tr>
<tr class="separator:a26ded59a12b1643c859e15bfe2238efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34c7f588f8ce888e33205932a47f085"><td class="memItemLeft" align="right" valign="top">Class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_layer.html#ac34c7f588f8ce888e33205932a47f085">surfaceManagerClass</a></td></tr>
<tr class="separator:ac34c7f588f8ce888e33205932a47f085"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> is a Cocos2D <a class="el" href="interface_c_c_layer.html">CCLayer</a> that supports full 3D rendering in combination with normal Cocos2D 2D rendering. </p>
<p>It forms the bridge between the 2D and 3D drawing environments.</p>
<p>The <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> contains an instance of <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>, and delegates all 3D operations, for both updating and drawing 3D models, to the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance.</p>
<p>In addition, like any Cocos2D <a class="el" href="interface_c_c_layer.html">CCLayer</a>, 2D child CCNodes can be added to this layer and will be rendered either over or under the 3D scene, based on their individual Z-order. In particular, 2D controls such as menus, sprites, labels, health bars, joysticks, etc, can be overlayed on the 3D scene simply by adding them as children of this layer.</p>
<p>Like other CCNodes, this layer can be added to another 2D node, and given a contentSize, position, and scale. You can even dynamically move and scale the embedded <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> using CCActions.</p>
<p>Changes to the position and scale of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> are propagated to the viewport of the contained <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>, and to any child CC3Layers and CC3Scenes.</p>
<p>However, these properties will only be propagated if the node being moved is a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a>. If the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> is a child of a regular 2D <a class="el" href="interface_c_c_layer.html">CCLayer</a> or CCNode, and that node is moved, the resulting changes to the position or scale of the child <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> may not automatically be propagated to the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> viewport. In this case, you can use the updateViewport method of <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> to ensure that the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> viewport is aligned with the position and scale of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a>.</p>
<p>Also, although the 3D scene will be correctly rendered when this, or a parent layer is scaled, be aware that scaling of the 2D nodes affects the interaction between the 2D and 3D environments. Specifically, when the 2D layer is scaled, the following limitation apply:</p>
<ul>
<li>a 2D CCNode held by CC3Billboards whose shouldDrawAs2DOverlay property is set to YES, indicating that the 2D CCNode should be drawn as an overlay above the 3D scene, will not be rendered in the correct position, relative to the 3D scene.</li>
<li>projection and unprojection between the 2D and 3D coordinate systems, including projecting touch events onto 3D nodes, will not work correctly.</li>
</ul>
<p>When compiling with versions of Cocos2D prior to 3.0, to make use of the standard Cocos2D model updatating functionality to update and animate the 3D scene, use the scheduleUpdate method of <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> to invoke periodic callbacks to the update: method of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> instance. The update: method forwards these callbacks to the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance held by the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a>. When compiling with versions of Cocos2D 3.0 or higher, these callbacks will happen automatically, and you do not need to invoke the scheduleUpdate method.</p>
<p>To enable simple single-touch event handling for this layer, set the userInteractionEnabled property to YES. Once enabled, single-touch events will automatically be forwarded to the touchEvent:at: method on your customized <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance to support user selection of 3D nodes via touches. For more information on handling 3D node selections, see the description of the method nodeSelected:byTouchEvent:at: of <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>.</p>
<p>Since the touch-move events are both voluminous and seldom used, the implementation of ccTouchMoved:withEvent: has been left out of the default <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> implementation. To receive and handle touch-move events for object picking, copy the commented-out ccTouchMoved:withEvent: template method implementation in <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> to your customized <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> subclass.</p>
<p>For more sophisticated touch interfaces, such as multi-touch events or gestures, add event-handing behaviour to your customized <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a>, as you would for any Cocos2D application and, when required, invoke the touchEvent:at: method on your customized <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> to initiate node selection.</p>
<p>Most 3D games will be displayed in full-screen mode, so typically your custom <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> will be sized to cover the entire screen. However, the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> can indeed be set to a contentSize less that the full window size, and may be positioned on the window, or within a parent <a class="el" href="interface_c_c_layer.html">CCLayer</a> like any other CCNode.</p>
<p>You can even dyanamically move your <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> around within the window, by changing the position property (for example, by using a CCActionMoveTo action).</p>
<p>For most applications, you will create subclasses of both <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> and <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>. The customized subclass of <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> manages the behaviour of the 3D resources. The customized subclass of <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> manages the 2D artifacts, such as menus, sprites, labels, health bars, joysticks, etc, that you want to overlay on the 3D scene.</p>
<p>Typically, you will create a separate instance of <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> for each 3D scene. You can also create a distinct <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> for each scene as well or, more typically, reuse a single <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> instance across multiple <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> scenes by simply assigning a differnt <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance to the layer. Any running actions in the old scene are automatically paused, and any running actions in the new scene are automatically started. For more information on swapping 3D scenes, see the notes on the cc3Scene property.</p>
<p>To create and use your <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> and <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> pair, follow these steps:</p>
<ol type="1">
<li>Create a <a class="el" href="interface_c_c3_view_controller.html" title="An instance of CC3ViewController manages the CCGLView to support the 3D environment. ">CC3ViewController</a>.</li>
<li>Instantiate your <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> subclass on the controller, adding any 2D controls in the initializeControls method, and managing event handlers and gesture recognizers in the onOpenCC3Layer and onCloseCC3Layer methods.</li>
<li>Instantiate your <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> class, including creating or loading 3D file resources in the initializeScene method.</li>
<li>Attach your <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> to the cc3Scene property of your <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a>.</li>
<li>When compiling with versions of Cocos2D prior to 3.0, schedule regular updates in your <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> instance by invoking the scheduleUpdate method. </li>
</ol>
</div><h2 class="groupheader">Method Documentation</h2>
<a class="anchor" id="a8afbcb73e6997deb48f899a516684a96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) cc3AddGestureRecognizer: </td>
          <td></td>
          <td class="paramtype">(UIGestureRecognizer *)&#160;</td>
          <td class="paramname"><em>gesture</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the specified iOS gesture recognizer to the UIView that is displaying this layer, and tracks the gesture recognizer in the cc3GestureRecognizers property. </p>
<p>For applications that use a single <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> to cover the entire UIView, you can override the onOpenCC3Layer method to create gesture recognizers, and you can invoke this method to easily add them to the UIView.</p>
<p>When this layer is removed from the view, the gesture recognizers added using this method are automatically removed from the view, and from the cc3GestureRecognizers property. Whenever this layer is displayed again, new gesture recognizers will be created and attached to the view when the onOpenCC3Layer method runs again.</p>
<p>For applications that diplay several CC3Layers that support gesture recognizers, you may want to create centralized gesture recognizers in some other scope, and bypass adding them using this method. </p>

</div>
</div>
<a class="anchor" id="a7c1bd320237e85a27f0a29c6629369b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) cc3RemoveAllGestureRecognizers </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all iOS gesture recognizers that were previously added using the cc3AddGestureRecognizer: method, and removes them all from the UIView. </p>
<p>This method is invoked automatically when this layer is removed from the view. Usually, the application does not need to invoke this method directly, but if you need to remove all gesture recognizers prior to closing the layer, you can use this method to do so. </p>

</div>
</div>
<a class="anchor" id="aa0c1b0305c4177c197bff0946b0cd347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) cc3RemoveGestureRecognizer: </td>
          <td></td>
          <td class="paramtype">(UIGestureRecognizer *)&#160;</td>
          <td class="paramname"><em>gesture</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified iOS gesture recognizer from the UIView that is displaying this layer, and removes the gesture recognizer from the cc3GestureRecognizers property. </p>
<p>When this layer is removed from the view, the gesture recognizers added to the cc3GestureRecognizers property using the cc3AddGestureRecognizer: method are automatically removed from the view, and from the cc3GestureRecognizers property. Usually, the application does not need to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a5cea9c3c3a1c0a4f144403cbb2f84ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) contentSizeChanged </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback invoked when the contentSize property of this layer changes. </p>
<p>This implementation updates the viewport to match the new layer dimensions, and keeps track of whether the layer covers the full view. Subclasses may override to perform activities such as adjusting the layout of buttons and controls to fit the new size. </p>

</div>
</div>
<a class="anchor" id="a8142f0b21a278e74bb2ec2ab067d6007"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) handleTouchType: </td>
          <td></td>
          <td class="paramtype">(uint)&#160;</td>
          <td class="paramname"><em>touchType</em></td>
        </tr>
        <tr>
          <td class="paramkey">at:</td>
          <td></td>
          <td class="paramtype">(CGPoint)&#160;</td>
          <td class="paramname"><em>touchPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoked automatically when the touchEnabled property or mouseEnabled is set to YES, and a touch or mouse event of the specified type occurs within the bounds of this layer. </p>
<p>The specified touchPoint indicates where the touch event occurred, in the local coordinate system of this layer.</p>
<p>Under iOS, the event originates from a finger touch event. Under OSX, the event may have originated as either a finger touch event on a touch pad, or an equivalent mouse event.</p>
<p>When running under OSX, this layer treats mouse events as the corresponding touch event. The specified touchType will be one of the following:</p>
<ul>
<li>kCCTouchBegan: a mouse-down event has occurred</li>
<li>kCCTouchMoved: a mouse-drag event has occurred (with the button down)</li>
<li>kCCTouchEnded: a mouse-up event has occurred</li>
</ul>
<p>Returns whether the event was handled.</p>
<p>This implementation forwards all events to the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> touchEvent:at: method, and always returns YES. Subclasses may override this method to handle some events here instead. </p>

</div>
</div>
<a class="anchor" id="a0dd20963bf8a354addd7005eda1671da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) initializeControls </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template method that is invoked automatically during initialization. </p>
<p>You can override this method to add 2D controls to the layer.</p>
<p>This default implementation does nothing. It is not necessary to invoke this superclass implementation when overriding in a subclass. </p>

</div>
</div>
<a class="anchor" id="ab87816429323280209f0c657d031ec67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) onCloseCC3Layer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template method that is invoked automatically immediately after the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> has closed, and immediately before this layer is closed. </p>
<p>This default implementation does nothing. You can override this method in your custom subclass to perform tear-down activity prior to the scene disappearing.</p>
<p>Any gesture recognizers added in the onOpenCC3Layer method by invoking cc3AddGestureRecognizer: will be removed automatically after this method runs. You do not need to use this method to remove any gesture recognizers that you added using the cc3AddGestureRecognizer method. However, if you have bypassed the cc3AddGestureRecognizer method to create and add gesture recognizers, you can use this method to remove them. </p>

</div>
</div>
<a class="anchor" id="a57ae70be891b41519398b6e544dd8a80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) onOpenCC3Layer </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template method that is invoked automatically immediately after this layer has opened on the underlying view, and before the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> is opened. </p>
<p>This default implementation does nothing. You can override this method in your custom subclass to perform set-up activity prior to the scene becoming visible, such as adding gesture recognizers or event handlers.</p>
<p>You can invoke the cc3AddGestureRecognizer method from this method to add gesture recognizers. When creating gesture recognizers, you should use your custom <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> as the target of the action messages from the recognizers. You can then use the cc3Convert... family of methods on this instance to convert locations and movements from the gesture recognizers into the coordinate system of this layer.</p>
<p>If your application contains several CC3Layers on-screen at once, you may want to register gesture recongizers within the onEnter method of a parent grouping CCNode, instead of from within each <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a>. </p>

</div>
</div>
<a class="anchor" id="a8605dd4b368c155d31d420499bf2904c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) update: </td>
          <td></td>
          <td class="paramtype">(CCTime)&#160;</td>
          <td class="paramname"><em>dt</em></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is invoked periodically when the components in the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> are to be updated. </p>
<p>The dt argument gives the interval, in seconds, since the previous update.</p>
<p>This implementation forwards this update to the updateScene: method of the contained <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance. Subclasses can override to perform updates to 2D nodes added to this layer, but should be sure to invoke this superclass implementation, or to invoke updateScene: on the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> directly.</p>
<p>Typcially this method is scheduled to be invoked automatically at a periodic interval. When compiling with versions of Cocos2D 3.0 or higher, this will happen automatically. When compiling with versions of Cocos2D prior to 3.0, you can do so by invoking the scheduleUpdate method on this instance from the initializeControls method.</p>
<p>This method is invoked asynchronously to the frame rendering animation loop, to keep the processing of model updates separate from OpenGL ES drawing. </p>

</div>
</div>
<a class="anchor" id="a202b859f691d1671992aae0962e7978b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) updateViewport </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the viewport of the contained <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance with the dimensions of this layer. </p>
<p>This method is invoked automatically when the position, size, scale, or orientation of this layer changes. You do not need to invoke this method when changing the position or scale of the layer. These changes are forwarded to the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> viewport automatically.</p>
<p>Usually, the application should never need to invoke this method directly. However, if your application changes the orientation of this layer in a manner that is not automatically detected, you can use this method to align the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> viewport with the updated layer. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="a831905cd3956597a4bfe296627d2e19c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray*) cc3GestureRecognizers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a collection of iOS UIGestureRecognizers that were added using the cc3AddGestureRecognizer: method. </p>
<p>This property is only available under iOS. </p>

</div>
</div>
<a class="anchor" id="ac74c2263a40e0875aca62fedff9e1bb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_scene.html">CC3Scene</a>*) cc3Scene</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance that maintains the 3D models and draws the 3D content. </p>
<p>If your application contains multiple 3D scenes, you can swap between these scenes by simply setting the value of this property to the new scene. The old <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> instance is released. So if you want to swap that old scene back into this layer at some point in the future, you should cache it somewhere, or recreated it.</p>
<p>When the old scene is released, it will clean up after itself, including all the nodes and meshes it contains.</p>
<p>If this layer already has a <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> assigned, the wasRemoved method of the existing <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> is invoked to stop and remove any CCActions running on it and any nodes it contains.</p>
<p>You can set the shouldStopActionsWhenRemoved of the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> to NO if you want the CCActions attached to the scene and its nodes to be paused, but not stopped and removed. Be aware that CCActions that are paused, but not stopped, will retain the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>, and could be cause for memory leaks if not managed correctly. Please see the notes of the <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D scene, including visible mesh...">CC3Node</a> shouldStopActionsWhenRemoved property and the <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D scene, including visible mesh...">CC3Node</a> wasRemoved method for more information.</p>
<p>Setting this property while this layer is being displayed automatically invokes the open method on the new scene to ensure that the transforms are up to date before the next frame is rendered.</p>
<p>In many cases, you do not need to set this property directly. If you do not set this property directly, an instance of the Class returned by the cc3SceneClass property is automatically instantiated the first time this property is accessed. </p>

</div>
</div>
<a class="anchor" id="a70d18133292db46f1c81b29153e48850"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (Class) cc3SceneClass</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Class used to automatically instantiate a value for the cc3Scene property, if that property is not set directly. </p>
<p>The value returned by this method is a subclass of <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>.</p>
<p>This implementation attempts to derive the appropriate scene class from the name of the class of this instance by looking for a subclass of <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> whose name is one of the following (searched in this order): </p>
<h1>If the class name of this instance ends in "Layer", it is stripped and "Scene" is</h1>
<p>appended to the stripped result (eg. HelloLayer -&gt; HelloScene). </p>
<h1>If the class name of this instance ends in "Layer", it is stripped (eg. HelloLayer -&gt; Hello).</h1>
<h1>"Scene" is appended to the class name of this instance (eg. Hello -&gt; HelloScene,</h1>
<p>including HelloLayer -&gt; HelloLayerScene).</p>
<p>If that is not sufficient, you can override the getter method of this property in your custom <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a Cocos2D CCLayer that supports full 3D rendering in combination with normal Cocos2D 2D r...">CC3Layer</a> subclass to return whatever you want, or you can set the cc3Scene property directly. If you override this method, remember the value returned by this method must be a subclass of <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a>. </p>

</div>
</div>
<a class="anchor" id="a4f751a4559cfe48171cdd58008f3f27f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (const char*) renderStreamGroupMarker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a marker string that is pushed onto the GL render stream prior to rendering this node. </p>
<p>The group is popped from the GL render stream after this node is rendered.</p>
<p>This property returns a NULL pointer. Subclasses that contain renderable content can override to provide a meaningful string. Subclasses should avoid dynamically generating this property on each access, since this property is accessed each time the node is rendered. </p>

</div>
</div>
<a class="anchor" id="a68ea5dd275d896a803782f109b435d5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldAlwaysUpdateViewport</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this layer should update the 3D viewport on each rendering frame. </p>
<p>If the value of this property is YES, the 3D viewport will be updated before each frame is drawn. This is sometimes useful if the layer is changing in a way that is not automatically tracked by the 3D scene.</p>
<p>You do not need to set this property when changing the position or scale of the layer. These changes are forwarded to the 3D scene automatically.</p>
<p>The initial value of this property is NO. Unless you encounter issues when modifying the layer, leave this property set to NO, to avoid the overhead of calculating an unnecessary transformation matrix on each frame render.</p>
<p>As an alternate to updating the viewport on every frame render, consider invoking the updateViewport method whenever your application changes the orientation of this layer in a manner that is not automatically propagated to the <a class="el" href="interface_c_c3_scene.html" title="CC3Scene is a CC3Node that manages a 3D scene. ">CC3Scene</a> viewport. </p>

</div>
</div>
<a class="anchor" id="ab7c048c65b3e00ea9d68a60734fc5308"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) shouldTrackViewSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this layer should track the size of the underlying view. </p>
<p>If the value of this property is YES, when the size of the underlying view changes (eg- through a device rotation on iOS, or a window resizing on OSX), the contentSize property of this layer will be set to the new size of the view.</p>
<p>The initial value of this property is YES. It is automatically set to NO if the contentSize property of this layer is set to a value other than the size of the underlying view.</p>
<p>You can directly set the value of this property if you have some other sizing management scheme, but be aware that this property will be set to NO each time the contentSize property is set to a value that is not the same size of the view. </p>

</div>
</div>
<a class="anchor" id="a26ded59a12b1643c859e15bfe2238efc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_c_c3_scene_drawing_surface_manager.html">CC3SceneDrawingSurfaceManager</a>*) surfaceManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">write</span><span class="mlabel">nonatomic</span><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The surface manager that manages the surfaces associated with this layer, and used to render the scene from this layer. </p>
<p>If this property is not explicitly set, it is initialized to an instance of the class returned by the surfaceManager class when this property is first accessed. At a minimum, the surface manager contains the pickingSurface used to pick nodes from touch events. If this layer will be using additional surfaces, you should consider subclassing the <a class="el" href="interface_c_c3_scene_drawing_surface_manager.html" title="Manages the render surfaces that are tied to the size of a CC3Layer. ">CC3SceneDrawingSurfaceManager</a> class and overriding the surfaceManagerClass property.</p>
<p>When setting this property, the surfaces in the surface manager are automatically resized to the contentSize of this layer. </p>

</div>
</div>
<a class="anchor" id="ac34c7f588f8ce888e33205932a47f085"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">- (Class) surfaceManagerClass</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span><span class="mlabel">nonatomic</span><span class="mlabel">assign</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The class that will be used to automatically populate the surfaceManager property when it is first accessed. </p>
<p>By default, this property returns the <a class="el" href="interface_c_c3_scene_drawing_surface_manager.html" title="Manages the render surfaces that are tied to the size of a CC3Layer. ">CC3SceneDrawingSurfaceManager</a> class. If this layer will be using additional surfaces, you should consider subclassing the <a class="el" href="interface_c_c3_scene_drawing_surface_manager.html" title="Manages the render surfaces that are tied to the size of a CC3Layer. ">CC3SceneDrawingSurfaceManager</a> class and overriding this property to return that class. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_c_c3_layer_8h.html">CC3Layer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 19 2014 21:44:18 for Cocos3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
