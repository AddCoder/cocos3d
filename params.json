{"name":"Cocos3d","tagline":"Cocos3D is a sophisticated, yet intuitive and easy-to-use, 3D application development framework for the iOS platform. With Cocos3D, you can build sophisticated, dynamic 3D games and applications using Objective-C.","body":"![Cocos3D Logo](https://github.com/cocos3d/cocos3d/wiki/images/cocos3d-Banner-150h.png)\r\n\r\nCocos3D\r\n=======\r\n\r\nTable of Contents\r\n-----------------\r\n\r\n- [About Cocos3D][]\r\n- [Installation][]\r\n- [Your First Cocos3D Project][]\r\n- [Learning Cocos3D][]\r\n- [Demo Applications][]\r\n    - [CC3HelloWorld][] - a basic, easy to understand, starter app\r\n    - [CC3DemoMashUp][] - demos all key Cocos3D features\r\n    - [CC3Demo3DTiles][] - demos adding running many concurrent layers and scenes\r\n    - [CC3Performance][] - demos performance capabilities and testing\r\n    - [CC3DemoMultiScene][] - demos using Cocos3D with Xcode Storyboards\r\n- [Adding Cocos3D to an existing Cocos2D Project][]\r\n- [Using Cocos3D with SpriteBuilder][]\r\n- [Cocos2D Version Compatibility][]\r\n- [Compiling for Android][]\r\n- [Creating POD 3D Model Files][]\r\n- [Demo Models][]\r\n\r\n\r\n<a name=\"about\"></a>\r\n\r\nAbout Cocos3D\r\n-------------\r\n\r\nCocos3D is a sophisticated, yet intuitive. and easy-to-use, 3D application development\r\nframework for the iOS, Android, and Mac OSX platforms. With Cocos3D, you can build\r\nsophisticated, dynamic 3D games and applications using Objective-C.\r\n\r\n- Build 3D apps for iOS devices, Android devices, or Mac computers running OSX. The same 3D\r\n  content and game logic will run unchanged under iOS, Android, or Mac OSX.\r\n- Use OpenGL programmable pipelines for sophisticated GLSL shader rendering, or use OpenGL \r\n  fixed pipelines for simpler configurable rendering.\r\n- Supports OpenGL ES 2.0 or OpenGL ES 1.1 on iOS and Android devices, and OpenGL on Mac OSX.\r\n- Seamless integration with Cocos2D. Rendering of all 3D model objects occurs within a special \r\n  Cocos2D layer, which fits seamlessly into the Cocos2D node hierarchy, allowing 2D nodes such \r\n  as controls, labels, and health bars to be drawn under, over, or beside 3D model objects. \r\n  With this design, 2D objects, 3D objects, and sound can interact with each other to create \r\n  a rich, synchronized audio-visual experience.\r\n- Seamless integration with the iOS UIViewController framework.\r\n- Pluggable loading framework for 3D models exported from familiar 3D editors such as Blender, \r\n  3ds Max or Cheetah3D, or through industry standard 3D object files such as Collada or PowerVR POD,\r\n  or even from your own customized object file formats.\r\n- Loading 3D models, textures and GLSL shaders can be performed on a background thread while the\r\n  scene is being displayed, and automatically added to the scene when loading is complete.\r\n- 3D models can be selected and positioned by touch events and gestures, allowing intuitive user\r\n  interaction with the objects in the 3D world.\r\n- 3D models can include animation sequences, with full or fractional animation, in multiple tracks. \r\n  Animation tracks can be blended together, and cross-fading actions can be used to smoothly \r\n  transition between tracks.\r\n- 3D model objects can be arranged in sophisticated structural assemblies, allowing child objects\r\n  to be moved and oriented relative to their parent structure.\r\n- 3D models and assemblies can be easily duplicated. Each duplicated model can be independently\r\n  controlled, animated, colored, or textured. But fear not, underlying mesh data is shared between\r\n  models. You can quickly and easily create swarming hoards to populate your 3D world, without\r\n  worrying about device memory limitations.\r\n- 3D models, cameras, and lighting can be manipulated and animated using familiar Cocos2D Actions,\r\n  allowing you to quickly and easily control the dynamics of your 3D world, in a familiar, and\r\n  easy-to-use programming paradigm.\r\n- 3D objects can be covered with dynamic materials and textures to create rich, realistic imagery.\r\n- Multi-texturing and bump-mapped textures are available, allowing you to create sophisticated surface effects.\r\n- Vertex skinning, also often referred to as bone rigging, allowing soft-body meshes to be \r\n  realistically deformed based on the movement of an underlying skeleton constructed of bones and joints.\r\n- Automatic shadowing of models using shadow volumes.\r\n- Collision detection between nodes.\r\n- Ray-casting for nodes intersected by a ray, and the local location of intersection on a node\r\n  or mesh, right down to the exact mesh intersection location and face.\r\n- The 3D camera supports both perspective and orthographic projection options.\r\n- Objects can dynamically track other objects as they move around the world. The 3D camera \r\n  can dynamically point towards an object as it moves, and other objects can dynamically point\r\n  towards the camera as it moves.\r\n- Lighting effects include multiple lights, attenuation with distance, spotlights, and fog effects.\r\n- Mesh data can be shared between 3D objects, thereby saving precious device memory.\r\n- Mesh data can freely, and automatically, use OpenGL vertex buffer objects to improve performance\r\n  and memory management.\r\n- Culling of 3D objects outside of the camera frustum is automatic, based on pluggable, \r\n  customizable object bounding volumes.\r\n- Automatic ordering and grouping of 3D objects minimizes OpenGL state changes and improves\r\n  rendering performance. Pluggable sorters allow easy customization of object sorting, ordering,\r\n  and grouping for optimal application performance.\r\n- Rendering to texture for dynamic textures within a scene, or to create sophisticated post-processing effects.\r\n- Automatic rendering of the scene to an environment map texture, to create automatic environment\r\n  reflections and refractions.\r\n- Integrated particle systems:\r\n\t- 3D point particles provide efficient but sophisticated particle effects.\r\n\t- 3D mesh particles allow particles to be created from any 3D mesh template (eg- spheres,\r\n\t  cones, boxes, POD models, etc).\r\n- Automatic OpenGL state machine shadowing means that the OpenGL functions are invoked only when a\r\n  state really has changed, thereby reducing OpenGL engine calls, and increasing OpenGL throughput.\r\n- Sophisticated performance metrics API and tools collect real-time application drawing and updating\r\n  performance statistics, for logging or real-time display.\r\n- Sophisticated math library eliminates the need to use OpenGL ES function calls for matrix mathematics.\r\n- Fully documented API written entirely in familiar Objective-C. No need to switch to C or C++ to work with 3D artifacts.\r\n- Extensive logging framework to trace program execution, including all OpenGL ES function calls.\r\n- Includes demo applications and Xcode templates to get you up and running quickly.\r\n\r\n\r\n<a name=\"install\"></a>\r\n\r\nInstallation\r\n------------\r\n\r\n1. The Cocos3D framework works with [Cocos2D](http://www.cocos2d-swift.org). Before installing\r\n   Cocos3D, you must [download](http://www.cocos2d-swift.org/download) and install Cocos2D.<br/>\r\n\r\n\tThe same Cocos3D distribution can be used with `Cocos2D 3.x`, `Cocos2D 2.1` or `Cocos2D 1.1`.\r\n\tLink to `Cocos2D 3.x` or `Cocos2D 2.1` to make use of the more advanced shader-based \r\n\tprogrammable-pipeline available with OpenGL ES 2.0 (iOS) or OpenGL (OSX). Or link to \r\n\t`Cocos2D 1.1` to use the simpler configurable fixed-pipeline of OpenGL ES 1.1 (iOS), \r\n\tand avoid the need to write GLSL shaders.\r\n\r\n2. Download the [latest Cocos3D release](https://github.com/cocos3d/cocos3d/releases).\r\n\r\n3. Unzip the Cocos3D distribution file.\r\n\r\n4. Open a Terminal session, navigate to the unzipped Cocos3D distribution directory, and run \r\n   the `install-cocos3d` script as follows:\r\n\r\n\t\t./install-cocos3d.sh -2 path-to-cocos2d\r\n\r\n\tA Cocos2D distribution must be installed. With the -2 option, you specify the version\r\n\tof Cocos2D to which the Cocos3D demo apps and starter projects should be linked.\r\n\r\n\tAs the name implies, the ***path-to-cocos2d*** parameter is the path to the Cocos2D\r\n\tdistribution that was downloaded into the specified folder. You may use either a \r\n\trelative path, or an absolute path. If for some reason the relative path \r\n\tcannot be correctly resolved on your system, or the resulting links to the Cocos2D \r\n\tlibrary are not accurate, try again using the full absolute path. An example of using\r\n\ta relative path is:\r\n\r\n\t\t./install-cocos3d.sh -2 \"../cocos2d-swift-3.2.1\"\r\n\r\n\tWhen using Cocos2D 3.1 or earlier, you also have the option of setting ***path-to-cocos2d***\r\n\tto one of (`v3`, `v2`, or `v1`), which will link the Cocos3D demo apps to the Cocos2D Xcode\r\n\ttemplate libraries that were most recently installed. When using this format, you must have \r\n\tpreviously installed the corresponding version of Cocos2D. **This option is not available with \r\n\tCocos2D 3.2 and later because, as of Cocos2D 3.2, Xcode template projects are no longer available.**\r\n\r\n\tIf you encounter errors during installation, it's typically because you are trying\r\n\tto run the installer without first navigating to the Cocos3D distribution directory.\r\n\tBe sure to run the installer from the Cocos3D distribution directory.\r\n\r\n5. That's it!\r\n\r\nKeep in mind that Cocos3D does not \"patch\" your Cocos2D installation. Instead, you install\r\nCocos3D alongside Cocos2D, and link to it using the installation script.\r\n\r\n\r\n<a name=\"project1\"></a>\r\n\r\nYour First Cocos3D Project\r\n-----------------------------------\r\n\r\nThe Cocos3D distribution includes a starter app Xcode project that you can use as a starting \r\npoint for developing your own app. Copy the `Projects/CC3HelloWorld` folder from the Cocos3D \r\ndistribution folder to the location where you want to develop your application. Once copied, \r\nyou can rename the Xcode project to the name of your own app.\r\n\r\nThe starter app presents a 3D take on the ubiquitous ***hello, world*** application. \r\nIn addition to demonstrating how to load and display a 3D model, this application animates the \r\nmodel, and includes simple user interaction by having the 3D object visibly respond to finger touches.\r\n\r\nThe `CC3HelloWorldScene.m` file is where all the interesting action happens. To add your own 3D\r\ncontent, or to change the activty and interactivity of the 3D content, edit the methods in that file.\r\n\r\nYou can also edit the `application:didFinishLaunchingWithOptions:` method in the `AppDelegate.m` \r\nfile to tweak the basic setup of your Cocos3D application. This method is where the Cocos3D \r\nframework is hooked into the Cocos2D framework, and Apple's OpenGL ES framework.\r\n\r\nNOTE: The `hello-world.pod` 3D model data file used for the ***hello, world*** message model\r\nis fairly large, because converting a font to a mesh results in a LOT of triangles.\r\nWhen adapting this template project for your own application, don't forget to remove the\r\n'hello-world.pod' from the Resources folder of your project!\r\n\r\n\r\n<a name=\"learning\"></a>\r\n\r\nLearning Cocos3D\r\n----------------\r\n\r\nWondering how to get started? View Harry Dart-O’Flynn’s wonderful [Starting Cocos3D](http://www.youtube.com/playlist?list=PLU4bmVOOYXK-fV0Wt-ES5n3k8qTTyqgYu) \r\ncollection of video tutorials!\r\n\r\nTo learn more about Cocos3D, please refer to the [Cocos3D Programming Guide](http://brenwill.com/2011/cocos3d-programming-guide/)\r\nand the latest [API documentation](http://brenwill.com/docs/cocos3d/2.0.1/api/).\r\n\r\nYou can create a local copy of the API documentation using `Doxygen` to extract the documentation\r\nfrom the source files. There is a `Doxygen` configuration file to output the API documents in the\r\nsame format as appears online in the folder Docs/API within the Cocos3D distribution.\r\n\r\nThe best way to understand what Cocos3D can do is to look at the examples and code in the demo\r\napplications that are included in the Cocos3D distribution, as described in the [next section](#demos).\r\n\r\n\r\n<a name=\"demos\"></a>\r\n\r\nDemo Applications\r\n-----------------\r\n\r\nThe best way to understand what Cocos3D can do is to look at the examples and code in the demo\r\napplications that are included in the Cocos3D distribution. These demos, particularly the \r\n`CC3HelloWorld` and `CC3DemoMashUp` apps, will help you understand how to use Cocos3D, and \r\ndemonstrate many of the key features and capabilities of Cocos3D.\r\n\r\nFor convenience, to access all of the demos together, open either the `cocos3d-iOS.xcworkspace`\r\nor `cocos3d-OSX.xcworkspace` Xcode workspace. You can also open each demo project individually\r\nin the Projects folder.\r\n\r\nAt the time of this release, the current version of Cocos2D is `3.2.1`, and by default, the demo\r\napps within the Cocos3D distribution are pre-configured to use that version. To build and run\r\nthe demo apps with a different version of Cocos2D, follow the steps described below in the \r\nsection titled [Cocos2D Version Compatibility][].\r\n\r\nThe following demo apps are included in the Cocos3D distribution:\r\n\r\n\r\n<a name=\"cc3helloworld\"></a>\r\n\r\n###CC3HelloWorld\r\n\r\nThis basic, easy-to-understand, starter app presents a 3D take on the ubiquitous ***hello, world***\r\napplication. In addition to demonstrating how to load and display a 3D model, this application\r\nanimates the model, and includes simple user interaction by having the 3D object visibly respond\r\nto finger touches.\r\n\r\nThe `CC3HelloWorld` Xcode project is also designed to be used as the starting point for developing\r\nyour own app. To do so, copy the `Projects/CC3HelloWorld` folder from the  Cocos3D distribution\r\nfolder to the location where you want to develop your application. Once copied you can rename the\r\nXcode project to the name of your own app. For more info, see the section titled\r\n[Your First Cocos3D Project][], and read the `README.md` file within the `CC3HelloWorld` Xcode project.\r\n\r\n\r\n<a name=\"cc3demomashup\"></a>\r\n\r\n###CC3DemoMashUp\r\n\r\nPlease read the class notes of the `CC3DemoMashUpScene` class for a full description of how to\r\nrun and interact with this demo, and what features it covers.\r\n\r\nYour camera hovers over a scene that includes animated robots, bouncing beach-balls,\r\nspinning globes, and a selection of animated teapots. This is a sophisticated demo that\r\nshowcases many interesting features of Cocos3D, including:\r\n\r\n- loading mesh models, cameras and lights from 3D model files stored in the PowerVR POD format\r\n- creating mesh models from static header file data\r\n- sharing mesh data across several nodes with different materials\r\n- loading 3D models from a POD file converted from a Collada file created in a 3D editor (Blender)\r\n- assembling nodes into a hierarchical parent-child structual assembly.\r\n- programatic creation of spherical, box and plane meshes using parametric definitions.\r\n- texturing a 3D mesh from a CCTexture image\r\n- transparency and alpha-blending\r\n- translucent and transparent textures\r\n- coloring a mesh with a per-vertex color blend\r\n- multi-texturing an object using texture units by combining several individual textures into overlays\r\n- DOT3 bump-map texturing of an object to provide high-resolution surface detail on a model\r\n  with few actual vertices\r\n- Vertex skinning with a soft-body mesh bending and flexing based on the movement of skeleton bone nodes.\r\n- Copying soft-body nodes to create a completely separate character, with its own skeleton, that can be\r\n  manipulated independently of the skeleton of the original.\r\n- animating 3D models using a variety of standard Cocos2D CCActionIntervals\r\n- overlaying the 3D scene with 2D Cocos2D controls such as joysticks and buttons\r\n- embedding 2D Cocos2D text labels into the 3D scene\r\n- incorporating 2D Cocos2D CCParticleEmitters into the 3D scene (as a sun and explosion fire)\r\n- emitting 3D point particles from a moving nozzle, with realistic distance attenuation\r\n- emitting two different types of 3D mesh particles, with distinct textures, from a moving nozzle,\r\n  with each particle moving, rotating, and fading independently\r\n- creating a tightly focused spotlight whose intensity attenuates with distance\r\n- directing the 3D camera to track a particular target object\r\n- directing an object to track the camera, always facing (looking at) the camera (aka halo objects)\r\n- directing an object to track another object, always facing (looking at) that object\r\n- selecting a 3D object by touching the object on the screen with a finger\r\n- placing a 3D object on another at a point that was touched with a finger\r\n- adding a small CC3Layer/CC3Scene pair as a child window to a larger CC3Layer/CC3Scene pair.\r\n- moving, scaling and fading a CC3Layer and its CC3Scene\r\n- creating parametric boxes and texturing all six sides of the box with a single texture.\r\n- adding an object as a child of another, but keeping the original orientation of the child\r\n  (addAndLocalizeChild:)\r\n- handling touch-move events to create swipe gestures to spin a 3D object using rotation\r\n  around an arbitrary axis\r\n- toggling between opacity and translucency using the isOpaque property\r\n- choosing to cull or display backfaces (shouldCullBackFaces)\r\n- creating and deploying many independent copies of a node, while sharing the underlying mesh data\r\n- drawing a descriptive text label on a node using CC3Node shouldDrawDescriptor property.\r\n- drawing a wireframe bounding box around a node using CC3Node shouldDrawWireframeBox property.\r\n- automatically zooming the camera out to view all objects in the scene\r\n- constructing and drawing a highly tessellated rectangular plane mesh using CC3PlaneNode\r\n- caching mesh data into GL vertex buffer objects and releasing vertex data from application memory\r\n- retaining vertex location data in application memory (retainVertexLocations) for subsequent calculations\r\n- moving the pivot location (origin) of a mesh to the center of geometry of the mesh.\r\n- attaching application-specific userData to any node\r\n- applying a texture to all six sides of a parametric box\r\n- displaying direction marker lines on a node to clarify its orientation during development.\r\n- displaying a repeating texture pattern across a mesh\r\n- creating and displaying shadow volumes to render shadows for selected nodes\r\n- detecting the local location of where a node was touched using ray tracing\r\n- collision detection between nodes\r\n- texturing a node with only a small section of single texture\r\n- using the CC3Scene onOpen method to initiate activity when a scene opens\r\n- using pinch and pan gestures to control the movement of the 3D camera\r\n- using tap gestures to select 3D objects, and pan gestures to spin 3D objects\r\n- bitmapped font text labels\r\n- moving individual vertex location programmatically\r\n- using OpenGL ES 2.0 shaders.\r\n- loading PowerVR PFX effects files and applying them to materials\r\n- environmental reflections using a cube mapped texture.\r\n- render-to-texture the scene for display within the scene.\r\n- render-to-texture to create additional visual effects using post-rendering image processing.\r\n- render depth-to-texture to visualize the contents of the depth buffer.\r\n- read pixels from a rendered framebuffer\r\n- replace framebuffer and texture pixels with programmatic content\r\n- create CGImageRef from a rendered framebuffer\r\n- dynamically generate an environmental cube-map for creating a real-time dynamic reflective surfaces.\r\n- apply multiple animation tracks to a model, blend them together, and smoothly transition between\r\n  animation tracks using a cross-fade action.\r\n\r\nIn addition, there are a number of interesting options for you to play with by uncommenting\r\ncertain lines of code in the methods of this class that build objects in the 3D scene,\r\nincluding experimenting with:\r\n\r\n- simple particle generator with multi-colored, light-interactive, particles\r\n- simple particle generator with meshes updated less frequently to conserve performance \r\n- different options for ordering nodes when drawing, including ordering by mesh or texture\r\n- configuring the camera for parallel/isometric/orthographic projection instead of the default\r\n  perpective projection\r\n- mounting the camera on a moving object, in this case a bouncing ball\r\n- mounting the camera on a moving object, in this case a bouncing ball, and having the\r\n  camera stay focused on the rainbow teapot as both beach ball and teapot move and rotate\r\n- directing an object to track another object, always facing that object, but only\r\n  rotating in one direction (eg- side-to-side, but not up and down).\r\n- displaying 2D labels (eg- health-bars) overlayed on top of the 3D scene at locations \r\n  projected from the position of 3D objects\r\n- disabling animation for a particular node, in this case the camera and light\r\n- invading with an army of teapots instead of robots\r\n- ignore lighting conditions when drawing a node to draw in pure colors and textures\r\n- displaying descriptive text and wireframe bounding boxes on every node\r\n- displaying a dynamic bounding box on a 3D particle emitter.\r\n- making use of a fixed bounding volume for the 3D particle emitter to improve performance.\r\n- permitting a node to cast a shadow even when the node itself is invisible by using the \r\n  shouldCastShadowsWhenInvisible property\r\n- Skybox using a cube mapped texture.\r\n- Cocos2D CCSprite displaying the television screen rendered texture\r\n\r\n\r\n<a name=\"cc3demo3dtiles\"></a>\r\n\r\n###CC3Demo3DTiles\r\n\r\nA simple demo that lays out multiple small Cocos3D scenes as layers in a larger controllable\r\nCocos2D layer. The effect is a grid of tiles, with each tile displaying a separate 3D scene,\r\neach containing its own camera and lighting. The main node in each 3D tile can be rotated\r\nunder touch control.\r\n\r\nThis demonstrates the ability to simply include 3D objects in an otherwise 2D game, and \r\ntechniques for optimizing under those conditions. It also demonstrates touch control when\r\nmany 3D scene are visible concurrently.\r\n\r\n\r\n<a name=\"cc3performance\"></a>\r\n\r\n###CC3Performance\r\n\r\nThis is a simple demo of the performance characteristics of Cocos3D. It demonstrates how to\r\ncollect detailed statistics about your application's performance. In doing so, it presents\r\na number of models, and, through the user interface, allows you to control the type of model\r\nloaded, and how many copies to render.\r\n\r\nYou can dynamically experiment with how different model types, sizes and quantities affect\r\nthe performance of Cocos3D. You can also use this performance demo app to compare performance\r\nacross different devices.\r\n\r\n\r\n<a name=\"cc3demomultiscene\"></a>\r\n\r\n###CC3DemoMultiScene\r\n\r\nThis demo app is a sophisticated combination of the three demo apps listed above. It \r\ndemonstrates how to include Cocos3D in a UIView using Xcode Storyboards. Using standard\r\nUIKit controls, you can load any of the Cocos3D demos listed above, then shut down the \r\nrunning demo, and load a different Cocos3D demo.\r\n\r\n\r\n<a name=\"cocos2d\"></a>\r\n\r\nAdding Cocos3D to an existing Cocos2D Project\r\n---------------------------------------------\r\n\r\nInstead of starting with the `CC3HelloWorld` starter application project, you can add Cocos3D \r\nto an existing Cocos2D application (for example `MyCocos2DApp`), to allow you to add 3D content\r\nto your existing 2D application or game.\r\n\r\n1. The first step is to add the Cocos3D Static Library project as a subproject to your Cocos2D\r\n   Xcode project, as follows:\r\n\r\n\t1. Copy the `Projects/CC3StatLib` folder from the Cocos3D distribution to the\r\n\t   `MyCocos2DApp/MyCocos2DApp/Libraries` folder within your Cocos2D app.\r\n\t   \r\n\t2. Open your `MyCocos2DApp.xcodeproj` Xcode project.\r\n\r\n\t3. Drag the Cocos3D static library Xcode subproject at \r\n\t   `MyCocos2DApp/MyCocos2DApp/Libraries/CC3StatLib/cocos3d-iOS.xcodeproj` to the `Libraries`\r\n\t   group in the *Project Navigator* panel of your `MyCocos2DApp` Xcode project (if you are \r\n\t   building an OSX app, drag the `cocos3d-OSX.xcodeproj` subproject instead).\r\n\r\n\t4. Drag the Cocos3D GLSL shader folder at `MyCocos2DApp/MyCocos2DApp/Libraries/CC3StatLib/cocos3d-GLSL`\r\n\t   to the `MyCocos2DApp` group in the *Project Navigator* panel of your `MyCocos2DApp` Xcode project.\r\n\t   When prompted for the target to add the source code to, select the `MyCocos2DApp` target. \r\n\t   Once added, these files will appear in the *Copy Bundle Resources* list on the *Build Phases* \r\n\t   tab of the `MyCocos2DApp` target.\r\n\r\n2. Next, within Xcode, you need to tell your Cocos2D app project how to link to the code \r\n   and components of the Cocos3D subproject:\r\n\r\n\t1. Select your `MyCocos2DApp` project in the Xcode *Project Navigator* panel.\r\n\r\n\t2. Select the *Build Phases* tab of the `MyCocos2DApp` target\r\n\t\t1. Open the *Target Dependencies* list and add the `cocos3d` target to the list.\r\n\t\t2. Open the *Link Binary with Libraries* list, and add the `libcocos3d.a` library to the list.\r\n\r\n\t3. Select the *Build Settings* tab\r\n\t\t1. In the **Header Search Paths** (aka `HEADER_SEARCH_PATHS`) entry, add an entry to\r\n\t\t   `\"$(SRCROOT)/$(PROJECT_NAME)/Libraries/CC3StatLib/cocos3d\"` (including the double-quote marks),\r\n\t\t   and mark it as `recursive`.\r\n\t\t2. In the **Other Linker Flags** (aka `OTHER_LDFLAGS`) entry, add an entry for `-lstdc++`.\r\n\r\n3. Cocos3D requires a depth buffer to provide 3D depth realism. You can add a depth buffer \r\n   in your application code in the `AppDelegate.m` file. For Cocos2D 3.x, in the \r\n   `application:didFinishLaunchingWithOptions:` method, add the following line in the \r\n   constructor for the config dictionary passed to the `setupCocos2dWithOptions:` method:\r\n\r\n\t\tCCSetupDepthFormat: @GL_DEPTH_COMPONENT16,         // Cocos3D requires a depth buffer\r\n\t\t\r\n\tThis will create a basic 16-bit depth buffer, which covers most needs. If you want higher depth\r\n\taccuracy, you can use @GL\\_DEPTH\\_COMPONENT24\\_OES. And if you will be using shadow volume effects, \r\n\tuse @GL\\_DEPTH24\\_STENCIL8\\_OES to create a combined depth and stencil buffer.\r\n\r\n4. Add your custom `CC3Layer` and `CC3Scene` source files (`MyCC3Layer.h`, `MyCC3Layer.m`, \r\n   `MyCC3Scene.h`, and `MyCC3Scene.m`), and any 3D resources your app requires, to the \r\n   `MyCocos2DApp` target of your `MyCocos2DApp.xcodeproj` Xcode project.\r\n\r\n5. You can add a 3D component by adding code similar to the following within one of your \r\n   customized 2D scene layouts (eg - `MyCocos2DScene.m`):\r\n\r\n\t\t#import \"MyCC3Layer.h\"\r\n\t\t\r\n\t\t...\r\n\t\t\r\n\t\tCC3Layer* cc3Layer = [[MyCC3Layer alloc] init];\r\n\t\tcc3Layer.contentSize = CGSizeMake(300.0, 200.0);\r\n\t\tcc3Layer.position = CGPointMake(100.0, 100.0);\r\n\t\t[self addChild: cc3Layer];\r\n\r\n\r\n<a name=\"spritebuilder\"></a>\r\n\r\nUsing Cocos3D with SpriteBuilder\r\n--------------------------------\r\n\r\nYou can use Cocos3D to add 3D content to games created with [SpriteBuilder](http://www.spritebuilder.com).\r\nAdding Cocos3D to SpriteBuilder is similar to adding Cocos3D to an existing Cocos2D app, as described above\r\nin [Adding Cocos3D to an existing Cocos2D Project][]. To add Cocos3D your SpriteBuilder project, create your \r\nSpriteBuilder app (for example `MySpriteBuilderApp.spritebuilder`) as you normally would, then follow these\r\ninstructions to add Cocos3D to it:\r\n\r\n1. The first step is to add the Cocos3D Static Library project as a subproject to your SpriteBuilder Xcode \r\n   project, as follows:\r\n\r\n\t1. Copy the `Projects/CC3StatLib` folder from the Cocos3D distribution to the \r\n\t   `MySpriteBuilderApp.spritebuilder/Source/libs` folder within your SpriteBuilder app.\r\n\t   \r\n\t2. Open your `MySpriteBuilderApp.xcodeproj` Xcode project.\r\n\r\n\t3. Drag the Cocos3D static library Xcode subproject at \r\n\t   `MySpriteBuilderApp.spritebuilder/Source/libs/CC3StatLib/cocos3d-iOS.xcodeproj` to the\r\n\t   `libs` group in the *Project Navigator* panel of your `MySpriteBuilderApp` Xcode project\r\n\t   (if you are building an OSX app, drag the `cocos3d-OSX.xcodeproj` subproject instead).\r\n\r\n\t4. Drag the Cocos3D GLSL shader folder at `MySpriteBuilderApp.spritebuilder/Source/libs/CC3StatLib/cocos3d-GLSL`\r\n\t   to the *Project Navigator* panel of your `MySpriteBuilderApp` Xcode project.\r\n\t   When prompted for the target to add the source code to, select the `MySpriteBuilderApp` \r\n\t   target. Once added, these files will appear in the *Copy Bundle Resources* list on the\r\n\t   *Build Phases* tab of the `MySpriteBuilderApp` target.\r\n\r\n2. Next, within Xcode, you need to tell your SpriteBuilder app project how to link to the code \r\n   and components of the Cocos3D subproject:\r\n\r\n\t1. Select your `MySpriteBuilderApp` project in the Xcode *Project Navigator* panel.\r\n\r\n\t2. Select the *Build Phases* tab of the `MySpriteBuilderApp` target\r\n\t\t1. Open the *Target Dependencies* list and add the `cocos3d` target to the list.\r\n\t\t2. Open the *Link Binary with Libraries* list, and add the `libcocos3d.a` library to the list.\r\n\r\n\t3. Select the *Build Settings* tab\r\n\t\t1. In the **Header Search Paths** (aka `HEADER_SEARCH_PATHS`) entry, add an entry to\r\n\t\t   `\"Source/libs/CC3StatLib/cocos3d\"` (including the double-quote marks), and mark it as `recursive`.\r\n\t\t2. In the **Other Linker Flags** (aka `OTHER_LD_FLAGS`) entry, add an entry for `-lstdc++`.\r\n\r\n3. Cocos3D requires a depth buffer to provide 3D depth realism. You can add a depth buffer in your\r\n   application code in the `AppDelegate.m` file. In the `AppContoller application:didFinishLaunchingWithOptions:`\r\n   method, add the following line somewhere ***before*** the call to `setupCocos2dWithOptions:`\r\n\r\n\t\tcocos2dSetup[CCSetupDepthFormat] = @GL_DEPTH_COMPONENT16;        // Cocos3D requires a depth buffer\r\n\t\t\r\n\tThis will create a basic 16-bit depth buffer, which covers most needs. If you want higher depth\r\n\taccuracy, you can use @GL\\_DEPTH\\_COMPONENT24\\_OES. And if you will be using shadow volume effects,\r\n\tuse @GL\\_DEPTH24\\_STENCIL8\\_OES to create a combined depth and stencil buffer.\r\n\r\n4. Add your custom `CC3Layer` and `CC3Scene` source files (`MyCC3Layer.h`, `MyCC3Layer.m`, \r\n   `MyCC3Scene.h`, and `MyCC3Scene.m`), and any 3D resources your app requires, to the \r\n   `MySpriteBuilderApp` target of your `MySpriteBuilderApp.xcodeproj` Xcode project.\r\n\r\n5. You're now ready to add 3D content to your SpriteBuilder interface. As with any Cocos3D\r\n   application, you provide 3D content by creating a custom subclass of `CC3Layer`. Open your\r\n   `MySpriteBuilderApp.spritebuilder` project, and add your custom `CC3Layer` to your SpriteBuilder \r\n   layout as follows:\r\n\t1. Drag a *Node* from the SpriteBuilder component palette to your layout.\r\n\t2. Set the *Custom class* property of the new component to the name of your custom `MyCC3Layer` class.\r\n\t3. Set the *Content size* property to the size at which you want your want your 3D scene to be displayed.\r\n\t4. When first placed, the `MyCC3Layer` component will be added as a child of the root node of the \r\n\t   SpriteBuilder scene. If you want the `MyCC3Layer` node to move as part of another node, you can use \r\n\t   the SpriteBuilder timeline hierarchy to reposition the node to be a child of a different parent.\r\n\t5. *Save* and *Publish* your new SpriteBuilder layout.\r\n\t6. Build and run your app from Xcode to see your new 3D content.\r\n\t7. Repeat for all 3D sprites that you want to add to your SpriteBuilder scene.\r\n\r\n\r\n<a name=\"cocos2dversions\"></a>\r\n\r\nCocos2D Version Compatibility\r\n-----------------------------\r\n\r\nCocos3D under iOS and Android is compatible with `Cocos2D` `3.x` and `Cocos2D` `2.1`, for \r\nusing programmable-pipeline OpenGL ES 2.0, and is compatible with `Cocos2D` `1.1`, for \r\nusing fixed-pipeline OpenGL ES 1.1.\r\n\r\nCocos3D under OSX is compatible with `Cocos2D` `3.x` and `Cocos2D` `2.1`, for using\r\nprogrammable-pipeline OpenGL. Cocos3D is not compatible with `Cocos2D` `1.1` under OSX.\r\n\r\nAt the time of this release, the current version of Cocos2D is `3.2.1`, and by default, the demo\r\napps within the Cocos3D distribution are pre-configured to use that version. To build and run\r\nthe demo apps with a different version of Cocos2D, follow the steps described here:\r\n\r\n1. Run the `install-cocos3d.sh` script again and identify the new version of `Cocos2D` to be linked.\r\n   Keep in mind that you must link `Cocos2D` `3.x` or `Cocos2D 2.1` if you want to use OpenGL ES 2.0\r\n   (iOS & Android) or OpenGL (OSX) with a programmable rendering pipeline, and you must link\r\n   `Cocos2D 1.1` if you want to use OpenGL ES 1.1 (iOS & Android) with a fixed rendering pipeline.\r\n\r\n2. In the Xcode *Project Navigator* panel, delete the reference to the *cocos2d* group in the\r\n   `cocos2d-library-iOS` or `cocos2d-library-OSX` project.\r\n\r\n3. Add the newly linked Cocos2D files to the project by dragging the `cocos2d` folder from the \r\n   Cocos3D distribution folder into the `cocos2d-library-iOS` or `cocos2d-library-OSX` \r\n   project in the Xcode *Project Navigator* panel. When prompted for the target to add the source\r\n   code to, select the `cocos2d` target.\r\n\r\n4. In the Xcode *Project Navigator* panel, delete the reference to the *cocos2d-chipmunk* group\r\n   in the `cocos2d-chipmunk-library-iOS` or `cocos2d-chipmunk-library-OSX` project.\r\n\r\n5. Add the newly linked Cocos2D Chipmunk files to the project by dragging the `cocos2d-chipmunk`\r\n   folder from the Cocos3D distribution folder into the `cocos2d-chipmunk-library-iOS` or \r\n   `cocos2d-chipmunk-library-OSX` project in the Xcode *Project Navigator* panel. When prompted\r\n   for the target to add the source code to, select the `cocos2d-chipmunk` target.\r\n\r\n6. If you are using Cocos2D 3.2 or later, configure the `CCNoARC.m` file to use Manual Refernce Counting:\r\n\r\n\t1. Select the `cocos2d-library-iOS` or `cocos2d-library-OSX` project.\r\n\t\r\n\t2. Select the *Build Phases* tab of the `cocos2d` target.\r\n\r\n\t2. Open the *Compile Sources* list and locate the entry for the `CCNoARC.m` file.\r\n\r\n\t3. On the `CCNoARC.m` entry, double-click the *Compiler Flags* column and enter the \r\n\t   `-fno-objc-arc` compiler flag. As the name implies, the  `CCNoARC.m` file uses Manual\r\n\t   Refernce Counting (MRC) instead of Automatic Reference Counting (ARC), to improve performance.\r\n\r\n7. `Cocos2D` `3.x` uses Automatic Reference Counting (ARC). `Cocos2D` `2.1` and `Cocos2D` `1.1`\r\n   do not. You must set the appropriate compiler build setting to ensure the compiler will use\r\n   the correct technique.\r\n\t1. In the `cocos2d-library-iOS` or `cocos2d-library-OSX` project, select the `cocos2d` \r\n\t   target in your project settings.\r\n\t2. Select the *Build Settings* tab.\r\n\t3. Locate the **Objective-C Automatic Reference Counting** (aka `CLANG_ENABLE_OBJC_ARC`)\r\n\t   setting for the `cocos2d` target. If you are now linking to `Cocos2D` `3.x`, set this\r\n\t   property to `YES`. If you are now linking to `Cocos2D` `2.1` or `Cocos2D` `1.1`, set \r\n\t   this property to NO. Make sure you change only the setting for the `cocos2d` target \r\n\t   within your project. Do not change the setting for the `cocos2d-library-iOS` or \r\n\t   `cocos2d-library-OSX` project itself.\r\n\t4. The `cocos2d-chipmunk` part of the `Cocos2D` `3.x` library does *not* use ARC. Ensure\r\n\t   the **Objective-C Automatic Reference Counting** (aka `CLANG_ENABLE_OBJC_ARC`) setting\r\n\t   of the `cocos2d-chipmunk` target is always set to NO.\r\n8. `Cocos2D` `3.x` supports compiling to the ARM64 architecture. `Cocos2D` `2.1` and\r\n   `Cocos2D` `1.1` do *not* support compiling to the ARM64 architecture. Because of this,\r\n   by default, the **Valid Architectures** (aka `VALID_ARCHS`) build setting for all demo \r\n   Xcode Projects in the Cocos3D distribution is set to `$(ARCHS_STANDARD_32_BIT)` (which \r\n   resolves to **armv7 armv7s**), so that the demo projects will compile with all versions\r\n   of `Cocos2D`. If you are now linking to `Cocos2D` `3.x`, you can set this property to\r\n   `$(ARCHS_STANDARD)` (or simply remove this setting from the Project), in all demo Projects,\r\n   to allow compilation to include the ARM64 architecture.\r\n9. As a development optimization, if you are now linking to `Cocos2D` `3.x`, you can set the \r\n   value of the **Build Active Architecture Only** (aka `ONLY_ACTIVE_ARCH`) build setting in \r\n   the *Debug* configuration in all demo projects to `YES`. You should not do this if you are\r\n   linking to `Cocos2D` `2.1` or `Cocos2D` `1.1`, as this will prohibit you from building\r\n   the demo apps on devices that use the ARM64 processor.\r\n10. If you have already built the demo app using the old version of `Cocos2D`, delete the \r\n   contents of your `~/Library/Developer/Xcode/DerivedData` folder before attempting to compile again.\r\n\r\n\r\n<a name=\"android\"></a>\r\n\r\nCompiling for Android\r\n---------------------\r\n\r\nCocos3D (along with Cocos2D) is written in Objective-C. Cocos3D has partnered with \r\n[Apportable](http://www.apportable.com) to bring your 3D apps and games to the Android\r\nplatform. The Apportable SDK is a free SDK for porting Objective-C applications to Android.\r\n\r\nTo build and install your app or game project for the Android platform:\r\n\r\n1. Download and install the Apportable SDK.\r\n2. Open a `Terminal` window and navigate to the Xcode project folder of your Cocos3D app.\r\n3. Run the command: `apportable install` to build and install your Cocos3D app on an\r\n   Android device connected to your computer.\r\n\t\r\nPlease refer to the Apportable SDK documentation for more information about building,\r\ninstalling, and debugging your app on Android. If you are building an OpenGL ES 1.1 app, \r\nyou will need to modify the `configuration.json` file in your Xcode project, as indicated\r\nin that file.\r\n\r\n\r\n<a name=\"pod\"></a>\r\n\r\nCreating POD 3D Model Files\r\n---------------------------\r\n\r\nCocos3D reads 3D model content from POD files.\r\n\r\nIf you are using *Blender*, *Maya*, or *3DS Max* as your 3D editor, you can install the *PVRGeoPOD*\r\nplugin from Imagination Technologies to export directly from your editor to the POD file format.\r\n\r\nFor other editors, you can export your 3D model to a file in `COLLADA 1.4` format, and then use\r\nthe standalone *PVRGeoPOD* app to convert the COLLADA file to the POD format.\r\n\r\nBoth the standalone and plugin versions of *PVRGeoPOD* are available free of charge from\r\nImagination Technologies, the supplier of the GPU's used in iOS devices.\r\n\r\nRead the [full instructions](http://brenwill.com/2011/cocos3d-importing-converting-collada-to-pod/)\r\nfor more info on where to get the *PVRGeoPOD* converter, and how to use it to generate POD files.\r\n\r\nIf you are using *Blender* as your 3D editor, and have many `.blend` files to export to POD format,\r\nyou can use the command-line batch tool available in the `Tools/Blender-POD Batch Converter`\r\nfolder in the Cocos3D distribution. See the `README.txt` file in that folder for instructions.\r\nThe `Blender-POD Batch Converter` tool was created by Cocos3D user Nikita Medvedev.\r\n\r\n\r\n<a name=\"models\"></a>\r\n\r\nDemo Models\r\n-----------\r\n\r\nSome of the POD models that appear in the demo and template apps were designed in Blender and\r\nexported to POD files using the PowerVR *PVRGeoPOD* converter.\r\n\r\nAs a reference for the creation of your own 3D models for use in Cocos3D, you can find the original\r\n*Blender* files for these POD models in the `Models` folder in the Cocos3D distribution.\r\n\r\n\r\n\r\n[About Cocos3D]: #about\r\n[Installation]: #install\r\n[Your First Cocos3D Project]: #project1\r\n[Demo Applications]: #demos\r\n[CC3HelloWorld]: #cc3helloworld\r\n[CC3DemoMashUp]: #cc3demomashup\r\n[CC3Demo3DTiles]: #cc3demo3dtiles\r\n[CC3Performance]: #cc3performance\r\n[CC3DemoMultiScene]: #cc3demomultiscene\r\n[Adding Cocos3D to an existing Cocos2D Project]: #cocos2d\r\n[Using Cocos3D with SpriteBuilder]: #spritebuilder\r\n[Cocos3D and Cocos2D Static Libraries]:\r\n[Cocos2D Version Compatibility]: #cocos2dversions\r\n[Compiling for Android]: #android\r\n[Learning Cocos3D]: #learning\r\n[Creating POD 3D Model Files]: #pod\r\n[Demo Models]: #models\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}